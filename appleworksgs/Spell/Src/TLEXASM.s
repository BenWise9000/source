		CASE	OBJECT ;------------------------------------------;; Equates from procedure Tlexcmp;;------------------------------------------TFLAGSIND	equ $ff;------------------------------------------;; Equates from procedure Tlexphon;;------------------------------------------TNPHON	equ 58TE_LRIND	equ 4;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	Tlexblkptr	IMPORT	Tlexgramtab	IMPORT	Tlexmingrm	IMPORT	Tlexstrip	IMPORT	Tscendptr*******************************************************************   LEXASM.SRC - Various routines from lex.src I hand-coded**   Robert A. Hearn******************************************************************	LOAD 'macros.dump'*****************************************************************Tlexcmp	PROC		EXPORT		input	str1:l,str2:l		output   result:w		begin		lda #0		shortmloop	lda [str2]		beq done		cmp [str1]		bne different		longm		inc str1		inc str2		shortm		bra loopdifferent	cmp #TFLAGSIND		beq done		cmp [str1]		bmi done		longm		moveword #-1,result		bra reallydone	lda [str1]		longm		sta resultreally	return		ENDP*****************************************************************;lexstrip START;;IW_COMMON	  gequ 1;;		 input eptr:l;;		 begin;;		 dec eptr;		 dec eptr;		 stz Sctag;;		 lda [eptr];		 tax;		 and #$ff;		 cmp #TFLAGSIND;		 beq goahead;		 moveword #IW_COMMON,Scfdecomp;		 brl done;;goahead  lda #0;		 sta [eptr];		 txa;		 xba;		 and #$ff;		 sta Scfdecomp;;done	 return;;		 END*****************************************************************Tlexphon	PROC		EXPORT		local endptr:l,blkptr:l,gramtab:l		begin		movelong Tscendptr,endptr						; endptr = Tscendptr;		movelong Tlexblkptr,blkptr						; blkptr = lp->lx_blkptr;loop	lda [blkptr]									; while (cc = ctoi(*blkptr++)) {		incl blkptr		and #$ff		tax		jeq iszero;		{			if_ x,³,#TNPHON,else1						;		if (cc < Scphon.ph_nphon) {;			{				sta [endptr]							;			*endptr++ = (UCHAR)cc;				incl endptr				if_ x,­,#TE_LRIND,loop				;			if (cc  == TE_LRIND) {;				{					shortm					while_ [blkptr],­,#TFLAGSIND		;				while ((cc = ctoi(*blkptr++)) != TFLACSIND) {;					{						sta [endptr]					;					*endptr++ = (UCHAR)cc;						longm						incl blkptr						incl endptr						shortm;					}									;				}					endwhile_					longm;;					This is not needed, since blkptr is incremented AFTER the test ^^^ in;					|	the while loop.	ÑÑMSL 8/3/89							   |||;				    v;					decl blkptr							;				--blkptr;;				}										;			}				bra loop;			}else1		if_ x,<,Tlexmingrm,iszero					;		} else if (cc < lp->lx_mingrm)														;			break;			if_ x,³,#TFLAGSIND,else2					;		else if (cc < TFLAGSIND) {;			{				movelong Tlexgramtab,gramtab			;			*endptr++ = lp->lx_gramtab[cc][0];				txa										;			*endptr++ = lp->lx_gramtab[cc][1];				asl a				tay				moveword [gramtab]:y,[endptr]				incl endptr				incl endptr				brl loop;			}											;		} else {else2	;	{														*endptr++ = (UCHAR)cc;				txa										;			*endptr++ = *blkptr++;				sta [endptr]				; this is safe				incl endptr				moveword [blkptr],[endptr]	; because this 				incl blkptr					; writes the next 				incl endptr					; byte, & this ;			}								; is safe too		}			brl loop						; because ...;		}												;	}iszero	lda #0											;	*endptr = 0;		shortm								; this will 		sta [endptr]						; always write 		longm								; one more byte.		movelong endptr,Tscendptr						; 	Tscendptr = endptr;		decl blkptr										; 	lp->lx_blkptr = blkptr - 1;		movelong blkptr,Tlexblkptr		pushlong endptr									; 	lexstrip(endptr);		call Tlexstrip		ply		ply		return		ENDP*****************************************************************;Tlexbinnext   START;;NUMBACK  gequ 16;;		 output result:w;		 local blkptr:l,temp:w,tptr:l;;		 begin;;		 movelong Tlexblkptr,blkptr;;		 lda [blkptr];		 inc blkptr;		 and #$ff;		 bne ok;		 call Tlexnextblk;		 sta result;		 brl done;;ok	   cmp Tlexminbsd;		 bpl else;		 sec;		 sbc #TNPHON;		 sta temp;		 lda Tscendptr;		 sbc temp;		 sta Tscendptr;		 lda #NUMBACK-1;		 cmp temp;		 bne around;		 lda [blkptr];		 inc blkptr;		 and #$ff;		 sec;		 sbc #TNPHON;		 sta temp;		 lda Tscendptr;		 sbc temp;		 sta Tscendptr;		 bra around;;else	 tax;		 asl a;		 asl a;		 tay;		 movelong Tlexdelta,tptr;		 pushlong [tptr]:y;		 txy;		 movelong Tlexbs,tptr;		 lda [tptr],y;		 and #$ff;		 sta temp;		 pushword Tscendptr+2;		 lda Tscendptr;		 sec;		 sbc temp;		 pha;		 call strecpy;		 ply;		 ply;		 ply;		 ply;		 sta Tscendptr;		 stx Tscendptr+2;;around   movelong blkptr,Tlexblkptr;		 call Tlexphon;		 moveword #1,result;;done	 return;;		 END		END