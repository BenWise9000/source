		CASE	OBJECT ;------------------------------------------;; Equates from procedure lexcmp;;------------------------------------------FLAGSIND	equ $ff;------------------------------------------;; Equates from procedure lexstrip;;------------------------------------------IW_COMMON	equ 1IW_TAG	equ $80;------------------------------------------;; Equates from procedure lexphon;;------------------------------------------NPHON	equ 58E_LRIND	equ 4;------------------------------------------;; Equates from procedure lexbinnext;;------------------------------------------NUMBACK	equ 16;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	Lexblkptr	IMPORT	Lexbs	IMPORT	Lexdelta	IMPORT	Lexgramtab	IMPORT	Lexminbsd	IMPORT	Lexmingrm	IMPORT	Scendptr	IMPORT	Scfdecomp	IMPORT	Sctag	IMPORT	lexnextblk	IMPORT	strecpy*******************************************************************   LEXASM.SRC - Various routines from lex.src I hand-coded**   Robert A. Hearn******************************************************************	LOAD 'macros.dump'*****************************************************************lexcmp	PROC		EXPORT		input	str1:l,str2:l		output   result:w		begin		lda #0		shortmloop	lda [str2]		beq done		cmp [str1]		bne different		longm		inc str1		inc str2		shortm		bra loopdifferent	cmp #FLAGSIND		beq done		cmp [str1]		bmi done		longm		moveword #-1,result		bra reallydone	lda [str1]		longm		sta resultreally	return		ENDP*****************************************************************lexstrip	PROC		EXPORT		input eptr:l		local fptr:l		begin		dec eptr		dec eptr		movelong #Scfdecomp,fptr		stz Sctag		lda [eptr]		and #$ff		cmp #FLAGSIND		beq loop1		moveword #IW_COMMON,Scfdecomp		brl doneloop1	dec eptr		dec eptr		lda [eptr]		and #$ff		cmp #FLAGSIND		beq loop1		inc eptr		inc eptrgoahead	lda [eptr]		and #$ff00		sta [eptr]		inc eptrloop2	lda [eptr]		and #$ff		tax		and #IW_TAG		beq else		stx Sctag		bra nextelse	txa		sta [fptr]		inc fptrnext	inc eptr		lda [eptr]		inc eptr		and #$ff		bne loop2		moveword #0,[fptr]		lda Scfdecomp		and #$ff		bne done		moveword #IW_COMMON,[fptr]done	return		ENDP*****************************************************************lexphon	PROC		EXPORT		local endptr:l,blkptr:l,ptr:l,gramtab:l		begin		movelong Scendptr,endptr		movelong Lexblkptr,blkptrloop	lda [blkptr]		inc blkptr		and #$ff		tax		jeq iszero;		{		if_ x,³,#NPHON,else1;		{		sta [endptr]		inc endptr		if_ x,­,#E_LRIND,loop;		{		shortm		while_ [blkptr],­,#FLAGSIND;		{		sta [endptr]		longm		inc blkptr		inc endptr		shortm;		}		endwhile_		longm;		}		bra loop;		}else1	if_ x,<,Lexmingrm,iszero		if_ x,³,#FLAGSIND,else2;		{		movelong Lexgramtab,gramtab		txa		asl a		tay		moveword [gramtab]:y,[endptr]		inc endptr		inc endptr		brl loop;		}else2	;{		txa		sta [endptr]		inc endptr		moveword [blkptr],[endptr]		inc blkptr		inc endptr;		}		brl loop;		}iszero	lda #0		shortm		sta [endptr]		longm		lda endptr		sta Scendptr		lda blkptr		dec a		sta Lexblkptr		pushlong endptr		call lexstrip		return		ENDP*****************************************************************lexbinnext	PROC		EXPORT		output result:w		local blkptr:l,temp:w,tptr:l		begin		movelong Lexblkptr,blkptr		lda [blkptr]		inc blkptr		and #$ff		bne _ok		call lexnextblk		sta result		brl done_ok		cmp Lexminbsd		bpl else		sec		sbc #NPHON		sta temp		lda Scendptr		sbc temp		sta Scendptr		lda #NUMBACK-1		cmp temp		bne around		lda [blkptr]		inc blkptr		and #$ff		sec		sbc #NPHON		sta temp		lda Scendptr		sbc temp		sta Scendptr		bra aroundelse	tax		asl a		asl a		tay		movelong Lexdelta,tptr		pushlong [tptr]:y		txy		movelong Lexbs,tptr		lda [tptr],y		and #$ff		sta temp		pushword Scendptr+2		lda Scendptr		sec		sbc temp		pha		call strecpy		ply		ply		ply		ply		sta Scendptr		stx Scendptr+2around	movelong blkptr,Lexblkptr		call lexphon		moveword #1,resultdone	return		ENDP		END