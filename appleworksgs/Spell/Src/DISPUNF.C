/***********************************************************************\    Filename: dispunf.c\***********************************************************************/#include <string.h>#include "thes.h"#include "thesmisc.h"#define SCR_LM 13/* strings to indicate part of speech */char    *Posstr[] ={    "adj",    "adj",    "adv",    "conj",    "interj",    "noun",    "noun",    "noun",    "prep",    "pron",    "verb",    "verb",    "verb",};int Nposstr = sizeof(Posstr) / sizeof(Posstr[0]);static char *Relstr[32] ={    NULL,       "past/past participle",    NULL,       "past",    NULL,       "past participle",    NULL,       "plural",    NULL,       "adjective",    "verb",     "comparative",    NULL,       "superlative",    NULL,       "noun",    "verb",     "adverb",    "adjective","noun",    "adjective","present 3rd person sing.",    NULL,       "present participle",    NULL,       "past/past participle",    NULL,       "plural",    NULL,       "plural or second person singular",    NULL,       "first person singular",};/* This function will translate an encoded meaning string to a string   that displays details of unflection (if any) along with the meaning   cores. */dispunf(query, unfstr, meanno, def)char   *query;char   *unfstr;int     meanno;char   *def;{char   *printpos();char    *unfstrptr;int     rel;int     pos;int     poschange;char    *unfquery;    unfstrptr = unfstr;    pos = (int) *def++ - 1;    /* rel indexes into the array Relstr[] to return the string       that is descriptive of the unflection. */    if (!(rel = (int) *def++))    {        unfstrptr = printpos(unfstrptr,pos);        while (unfstrptr - unfstr < SCR_LM)            *unfstrptr++ = ' ';        strecpy(unfstrptr, def);        return;    }    def = strchr(unfquery = def, 0) + 1;    poschange = FALSE;    /* Determine if the unflection involved a change in the part of       speech. */    switch (pos)    {        case NOUN:        case SPNOUN:            poschange = (rel != SI_PL && rel != SP_PL);            break;        case VERB:        case VERBSP:            poschange = (rel == VB_NN || rel == VB_AJ);            break;        case ADJ:        case ADJSP:            poschange = !(rel == RE_CM || rel == RE_SU);            break;        default:            break;    }    if (!poschange)    {        unfstrptr = printpos(unfstrptr, pos);        while (unfstrptr - unfstr < SCR_LM)            *unfstrptr++ = ' ';        if (rel == SI_PL && (pos == VERB || pos == VERBSP))        {            unfstrptr = strecpy(unfstrptr, (char *) Relstr[TP_SI]);            unfstrptr = strecpy(unfstrptr, " of ");            unfstrptr = strecpy(unfstrptr, unfquery);        }        else        {            unfstrptr = strecpy(unfstrptr, (char *) Relstr[rel]);            if (strcmp(query, unfquery) != 0 || rel != SI_PL && rel != SP_PL)            {                unfstrptr = strecpy(unfstrptr, " of ");                unfstrptr = strecpy(unfstrptr, unfquery);            }        }    }    else    {        unfstrptr = strecpy(unfstrptr, (char *)Relstr[rel]);        while (unfstrptr - unfstr < SCR_LM)            *unfstrptr++ = ' ';        unfstrptr = strecpy(unfstrptr, "of ");        unfstrptr = strecpy(unfstrptr, unfquery);        unfstrptr = strecpy(unfstrptr, ", (");        unfstrptr = strecpy(unfstrptr,(char *) Posstr[pos]);        *unfstrptr++ = ')';        *unfstrptr++ = ' ';    }    *unfstrptr++ = ':';    *unfstrptr++ = ' ';    unfstrptr = strecpy(unfstrptr, def);}/* Return the string that describes the part of speech corresponding to   pos. */static char *printpos(str, pos)char   *str;int     pos;{    if (pos < 0 || pos >= Nposstr)        return (strecpy(str, "unknown part of speech "));    else        return (strecpy(str, (char *)Posstr[pos]));}