/***********************************************************************\   Filename: corrphon.c\***********************************************************************/#include <language.h>#include "spath.h"#include "clam.h"#include "lex.h"#include "correct.h"#include "environ.h"/* Info for the current word. */int Convplex;            /* non-vowel complexity */int Cophlen;             /* Length of Cophquery */int Coplex;              /* complexity of word *//* Info for the query. */int Coqnvplex;           /* non-vowel complexity */int Coqphlen;            /* length of Coqfull. */int Coqplex;             /* complexity of word */char *Cophquery;        /* The phonetic form of the query. */char *Coqfull;          /* The fully encoded form of the query. */extern pascal int  lexbinnext();/* This is the mainline for phonetic correction.  It returns true if the    correction was interrupted.  */extern pascal void rankword();intcordophon(){extern void phbin();extern void phencode();SPENTRY *pathptr;char    qbin[3];char    qfull[4*MAXWORD];char    phquery[MAXPHWORD];char    expword[4*MAXWORD];/* expanded word from lexicon */char    fullw[6*MAXWORD];/* the fully encoded phonetic word */    /* phonetically encode the query. */    phencode(Sclookup, phquery);    Cophlen = strlen((char *) phquery);    phbin(phquery, qbin);    /* Construct the correction form of the query. */    Coqphlen  = corrform(Cophquery = phquery, Coqfull = qfull);    Coqplex   = Coplex;    Coqnvplex = Convplex;    /* scan Searchpath for word lists which have Correct information and        which match the current environment */     for (pathptr = Srchpath; pathptr < Srchend; ++pathptr)    {        if (!(pathptr->sp_flags & SP_CORRECT))            continue;        Sccurlist = pathptr->sp_access;        /* Determine the wordlist type */        switch (pathptr->sp_type)        {            case IW_LEX >> 8:                if (Lexprod & SHORTLEX)                    break;                lexfetch(qbin);                while (Scdecomp[0] == qbin[0] && Scdecomp[1] == qbin[1])                {                    rankword(Scdecomp + 2, expword, fullw);                    if (!lexbinnext())                        break;                }                break;            case IW_CLAM >> 8:                if (clfindbin(qbin))                    while (Scdecomp[0] == qbin[0] && Scdecomp[1] == qbin[1])                    {                        rankword(Scdecomp + 2, expword, fullw);                        if (!clbinnext())                            break;                    }        }    }    return (FALSE);}/* Construct the correction word. */corrform(str, finptr0)char   *str;char   *finptr0;{int cc;        /* character in str */char *finptr; /* pointer into completed word */int prevnvgph; /* previous non vowel group phonetic char */int     prevgphc;       /* previous group phonetic char */    Coplex = 0;    Convplex = 0;    prevnvgph = prevgphc = E_LOGPH;    finptr = finptr0;    while ((cc = ctoi(*str++)) && cc != E_LRSEP)    {        if (cc != E_FILL)            *finptr++ = cc;        cc = ctoi(*str++);        /* Ignore E_FILL, E_REPEAT and invalid phonetic characters.   */        if (cc < E_LOPH || cc > E_HIPH)            continue;        ++Coplex;        /* '0' and '9' are just added. */        if (cc < E_LOGPH || cc > E_HIGPH)        {            *finptr++ = cc;            ++Convplex;            continue;        }                /* If this is the same as the previous phonetic group,                    ignore it; also, multiple vowels do not contribute to the                    phonetic complexity.  */         if (cc == prevgphc)        {            if (cc == E_VOWEL)                --Coplex;            continue;        }        if (cc != E_VOWEL)        {            ++Convplex;            if (cc != prevnvgph)            {                *finptr++ = E_TCBASE + (prevnvgph - E_LOGPH) +                  ((cc - E_LOGPH) << 3);                prevnvgph = cc;            }        }        /* Store the phonetic character. */        *finptr++ = prevgphc = cc;    }    *finptr = 0;    /* Return the length of the encoded word. */    return (finptr - finptr0);}