	LOAD	'Macros.dump'	INCLUDE 'Pict.equ'	INCLUDE	'Driver.equ'	IMPORT	Q_ChangePictSize	IMPORT	Q_Copy2	IMPORT	Q_Copy4	IMPORT	D_KillFont	IMPORT	D_NeedHandle	IMPORT	Q_Nop	IMPORT	Q_PixRect	IMPORT	D_SelectFont	IMPORT	Q_addbytes	IMPORT	count	IMPORT	oldptr	IMPORT	Q_pictSCB	IMPORT	Q_picterr	IMPORT	temp	IMPORT	Q_theBGcolor	IMPORT	Q_theChExtra	IMPORT	Q_theFGcolor	IMPORT	Q_theFontFlags	IMPORT	Q_theMask	IMPORT	Q_thePnSize	IMPORT	Q_theSpExtra	IMPORT	Q_theTxFont	IMPORT	Q_theTxLoc	IMPORT	Q_theTxMode	IMPORT	Q_txtBounds	IMPORT	Q_txtHandle	IMPORT	Q_txtHsize	IMPORT	Q_txtImage	IMPORT	Q_txtPort	IMPORT	Q_txtPortLoc	IMPORT	Q_txtRect	IMPORT	Q_txtSCB	IMPORT	Q_txtWidth	ENTRY	Q_MakeTextImage*****************************************************************															  ;*			  Q_Text rotating and flipping routines			 ;*______________________________________________________________**															  ;*	FUTURE EXTENSIONS:										;*															  ;*		-- Don't actually record Q_Text size, style,			;*		   font, color, and flags opcodes in the			  ;*		   mangled picture									;*															  ;*		-- Record them as part of a PicComment, along		 ;*		   with the orientation of the Q_Text image, so		 ;*		   that they can be restored as actual Q_Text		   ;*		   call if the picture is restored to its			 ;*		   original orientation.							  ;*															  ;*		-- Add PostScript PicComments so that the			 ;*		   rotated/flipped Q_Text still prints out nice		 ;*		   and pretty.										;*															  ;**********************************************************************************************************************************   Q_TextOps -- handle picture opcodes for Q_Text*****************************************************************Q_TextOps	PROC		EXPORT			;Using	Q_PictData		EXPORT	Q_FgColor		EXPORT	Q_BgColor		EXPORT	Q_TxFont		EXPORT	Q_TxFace		EXPORT	Q_TxSize		EXPORT	Q_TxMode		EXPORT	Q_ChExtra		EXPORT	Q_SpExtra		EXPORT	Q_FontFlags		EXPORT	Q_Text		EXPORT	Q_DhText		EXPORT	Q_DvText		EXPORT	Q_DhDvText		EXPORT	Q_LongText*--------------------------------------------------------------**				 Remember the foreground color				;*--------------------------------------------------------------*Q_FgColor		;				jsl	  Q_Nop			 ; move the opcode		moveword [<oldptr],Q_theFGcolor		jmp	  Q_Copy2		   ; move the color*--------------------------------------------------------------**				 Remember the background color				;*--------------------------------------------------------------*Q_BgColor		;				jsl	  Q_Nop		moveword [<oldptr],Q_theBGcolor		jmp	  Q_Copy2*--------------------------------------------------------------**				   Remember the current font				  ;*--------------------------------------------------------------*Q_TxFont		;				jsl	  Q_Nop		movelong [<oldptr],Q_theTxFont		jmp	  Q_Copy4*--------------------------------------------------------------**				  Remember the current style				  ;*--------------------------------------------------------------*Q_TxFace		;				jsl	  Q_Nop		movebyte [<oldptr],Q_theTxFont+2		jmp	  Q_Copy2*--------------------------------------------------------------**				Remember the current Q_Text size				;*--------------------------------------------------------------*Q_TxSize		;				jsl	  Q_Nop		movebyte [<oldptr],Q_theTxFont+3		jmp	  Q_Copy2*--------------------------------------------------------------**				Remember the current Q_Text mode				;*--------------------------------------------------------------*Q_TxMode		;				jsl	  Q_Nop		moveword [<oldptr],Q_theTxMode		jmp	  Q_Copy2*--------------------------------------------------------------**				Remember the current char extra			   ;*--------------------------------------------------------------*Q_ChExtra		;				jsl	  Q_Nop		moveword [<oldptr],Q_theChExtra		jmp	  Q_Copy2*--------------------------------------------------------------**			   Remember the current space extra			   ;*--------------------------------------------------------------*Q_SpExtra		;				jsl	  Q_Nop		movelong [<oldptr],Q_theSpExtra		jmp	  Q_Copy2*--------------------------------------------------------------**				Remember the current Q_Text mode				;*--------------------------------------------------------------*Q_FontFlags		;				jsl	  Q_Nop		moveword [<oldptr],Q_theFontFlags		jmp	  Q_Copy2*****************************************************************															  ;*					 Q_Text DRAWING OPCODES					 ;*															  ;*****************************************************************--------------------------------------------------------------**				   Handle a Q_LongText opcode				   ;*--------------------------------------------------------------*Q_Text		;				movelong [<oldptr]:#2,Q_theTxLoc		moveword #7,txtparams		brl	  doText*--------------------------------------------------------------**				  Handle a DHLongText opcode				  ;*--------------------------------------------------------------*Q_DhText		;				moveword [<oldptr]:#2,a  ; get DH		and	  #$ff		clc		adc	  Q_theTxLoc+2		sta	  Q_theTxLoc+2		moveword #4,txtparams		brl	  DoText*--------------------------------------------------------------**				  Handle a DVLongText opcode				  ;*--------------------------------------------------------------*Q_DvText		;				moveword [<oldptr]:#2,a  ; get DV		and	  #$ff		clc		adc	  Q_theTxLoc		sta	  Q_theTxLoc		moveword #4,txtparams		brl	  DoText*--------------------------------------------------------------**				 Handle a DHDVLongText opcode				 ;*--------------------------------------------------------------*Q_DhDvText		;				moveword [<oldptr]:#2,a  ; get DV		and	  #$ff		clc		adc	  Q_theTxLoc		sta	  Q_theTxLoc		moveword [<oldptr]:#3,a  ; get DH		and	  #$ff		clc		adc	  Q_theTxLoc+2		sta	  Q_theTxLoc+2		moveword #5,txtparams		brl	  DoText*--------------------------------------------------------------**				 Handle a RealLongText opcode				 ;*--------------------------------------------------------------*Q_LongText		;				movelong [<oldptr]:#2,Q_theTxLoc		moveword #6,txtparams		ldy	  #5		lda	  [<oldptr],y		brl	  gotcount		; More than just a byte!*--------------------------------------------------------------**					Generalized Q_Text stuff					;*--------------------------------------------------------------*DoText	ldy	  txtparams	   ; how much room does this opcode use?		dey		lda	  [<oldptr],y		and	  #$ff			; low byte onlygotcount	sta	  <count		clc		adc	  txtparams		eor	  #$ffff		inc	  a		sta	  Q_addbytes			   ; Don't copy the Q_Text stuff!		moveword #$ffff,Q_addbytes+2		jsl	  Q_ChangePictSize		jcs	  byebye		addwl	txtparams,<oldptr	  ; Q_Point oldptr at the Q_Text		ldx	  Q_theTxMode	   ; ---- look at the Q_Text mode ----		txa					  ; (keep it in x for a while)		and	  #4			  ; fore-something?		jne	  foresomething		moveword Q_theTxMode,themode	  ; set the obvious parameters...		moveword Q_theFGcolor,fore		moveword Q_theBGcolor,back		jsr	  StuffText			  ; ...and stuff it!		jcs	  byebye		brl	  stuffedforesomething	txa		and	  #3			  ; (not)forecopy?		jeq	  forecopy		txa		and	  #$fffB		  ; take out the fore-		sta	  themode		moveword Q_theFGcolor,fore		txa		and	  #$8000		  ; not-foresomething?		bne	  notfore		moveword #0,back		 ; Set the background color so that		bra	  gotbg		   ;   the background Q_Pixels have nonotfore	moveword #15,back		;   effect with the current modegotbg	jsr	  StuffText	   ; stuff it!		jcs	  byebye		brl	  stuffedforecopy	txa		and	  #$8000		  ; is it notforecopy?		jne	  not_forecopy		moveword #3,theMode	  ; srcBIC -- erase the Q_Text before		moveword #15,fore		; drawing again with the right colors		moveword #0,back		jsr	  StuffText		jcs	  byebye		moveword #1,theMode	  ; srcOr		moveword Q_theFGcolor,fore		jsr	  StuffText		jcs	  byebye		brl	  stuffednot_forecopy	moveword #$8003,theMode  ; notBIC		moveword #0,fore		moveword #15,back		jsr	  StuffText		jcs	  byebye		moveword #$8001,themode  ; notOr		moveword Q_theFGcolor,fore		jsr	  StuffText		jcs	  byebye		brl	  stuffedstuffed	addwl	<count,<oldptr   ; adjust the src pointerbyebye	rtl*--------------------------------------------------------------**   Now that we have all the Q_Text params, use them to D_Create   ;*   something for the D_New picture!							 ;*--------------------------------------------------------------*StuffText	pushword <count		pushlong <oldptr		pushword themode		 ; mode		pushword fore			; fg color		pushword back			; bg color		jsl	  Q_MakeTextImage		jcs	  nostuff		cmpl	 Q_txtHsize,#0	 ; if zero size, put nothing in the pict		jeq	  nostuff		movelong Q_txtHsize,Q_addbytes		jsl	  Q_ChangePictSize		jcs	  nostuff		pushlong <oldptr		 ; hide this for a minute		movelong Q_txtHandle,<temp ; pull data from the FAKE picture		movelong [<temp],<oldptr		jsl	  Q_PixRect		 ; FINALLY put the image into the pict		pulllong <oldptr		 ; okay, give it back.		pushlong Q_txtHandle		_DisposeHandlenostuff	pushlong #Q_txtPort		_ClosePort		rts*--------------------------------------------------------------*txtparams		DS.B 2					 ; size of Q_Text params + opcodethemode		DS.B 2fore		DS.B 2back		DS.B 2		ENDP******************************************************************   Q_MakeTextImage(txtcount:w,txtptr:l,mode:l,fg:w,bg:w) --*		creates a pixel image of the input Q_Text and fills in*		TxPortLoc with port location information, Q_txtHandle*		handles a record containing reasonable Q_PixRect*		information (including the actual Q_Text image), and*		Q_txtHsize contains the size of Q_txtHandle.*_______________________________________________________________**   Inputs:*		txtcount	   number of characters in the Q_Text*		txtptr		 pointer to the Q_Text*		mode		   mode to be used in Q_PixRect info*		fg			 foreground color of the Q_Text*		bg			 background color of the Q_Text*****************************************************************Q_MakeTextImage	PROC		EXPORT			;Using	Q_PictData		input	txtcount:w,txtptr:l,mode:w,fg:w,bg:w		local	txtpoint:l,ihand:l,iptr:l		begin		spacelong				; D_Save the port		_GetPort		pushlong #Q_txtPort		_OpenPort		pushlong #Q_txtPort		_SetPort		pushlong #Q_txtPortLoc		_GetPortLoc		jsl	  D_KillFont		movelong Q_theTxFont,ax		moveword #0,y			; black...it doesn't matter.		jsl	  D_SelectFont		_PenNormal		pushlong Q_theSpExtra		_SetSpaceExtra		pushlong Q_theChExtra		_SetCharExtra		pushlong #0			  ; move to 0,0		_MoveTo		pushlong txtptr		  ; how big is the Q_Text?		pushword txtcount		pushlong #Q_txtRect		_TextBounds		lda	  Q_txtRect		 ; find out where to move to before		eor	  #$ffff		  ; drawing the Q_Text into the pixel map		inc	  a		sta	  txtPoint		lda	  Q_txtRect+2		eor	  #$ffff		inc	  a		sta	  txtPoint+2		subword  Q_txtRect+4,Q_txtRect,Q_txtRect+4	; adjust to 0,0		subword  Q_txtRect+6,Q_txtRect+2,Q_txtRect+6		movelong #0,Q_txtRect		lda	  Q_txtRect+6	   ; zero width?		jeq	  notext		lda	  Q_txtRect+4	   ; height?		jeq	  notext		movelong #0,Q_txtBounds		moveword Q_txtRect+4,Q_txtBounds+4  ; store height of bounds Q_Rect		lda	  Q_txtRect+6	   ; compute the ;byte* width		dec	  a		lsr	  a		ldx	  Q_txtSCB		  ; same as MasterSCB??		beq	  shifted		 ; am I in 640 mode?		lsr	  ashifted	inc	  a		sta	  Q_txtWidth		; got it!		eor	  #7			  ; well, almost.		inc	  a			   ; It has to be a multiple of 8 <sigh>		and	  #7		clc		adc	  Q_txtWidth		sta	  Q_txtWidth		; NOW I've got it.		asl	  a			   ; compute the adjusted ;pixel* width		ldx	  Q_txtSCB		  ; 320 or 640?		beq	  gotbnds		asl	  agotbnds	sta	  Q_txtBounds+6	 ; got it!		spacelong		pushword Q_txtWidth		pushword Q_txtBounds+4		_Multiply		addlong  s,#34,Q_txtHsize  ; (34 bytes for Q_PixRect parameters)		spacelong				; allocate image handle		pushlong Q_txtHsize		pushword #$8010		  ; lock it within one bank		jsl	  D_NeedHandle		sta	  Q_picterr		 ; store the error code		pulllong ihand		jcs	  abort		   ; (uh oh.)		movelong [ihand],iptr		addlong  iptr,#34,Q_txtImage	  ; Adjust ptr back for portLoc		movelong ihand,Q_txtHandle		pushlong #Q_txtPortLoc		_SetPortLoc		_PenNormal		pushword bg		_SetSolidPenPat		pushlong #Q_txtBounds		_PaintRect		pushlong Q_thePnSize		_SetPenSize		pushlong #Q_theMask		_SetPenMask		pushword fg		_SetForeColor		pushword bg		_SetBackColor		pushword Q_theFontFlags		_SetFontFlags		pushword #4			  ; foreCopy		_SetTextMode		pushlong txtPoint		_MoveTo		pushlong txtPtr		  ; FINALLY!  Draw the Q_Text!		pushword txtCount		_DrawText		jsl	  D_KillFont*--------------------------------------------------------------**		   Set up the fake BitsRect opcode structure		  ;*--------------------------------------------------------------*		moveword #$90,[iptr]			; BitsRect opcode		moveword Q_pictSCB,[iptr]:#2	  ; SCB (MUST be same as picture's)		moveword #0,[iptr]:#4		   ; BWvsColor		moveword Q_txtWidth,[iptr]:#6	 ; width		movelong #0,[iptr]:#8		   ; top left of bounds Q_Rect		moveword Q_txtBounds+4,[iptr]:#12 ; bottom of bounds Q_Rect		lda	  Q_txtWidth		asl	  a			   ; recompute the adjusted pixel width		ldx	  Q_pictSCB		 ; 320 or 640?		beq	  gotbnds2		asl	  agotbnds2	moveword a,[iptr]:#14	; store it		movelong Q_txtRect,[iptr]:#16	 ; top left of src Q_Rect (ADJUST?)		moveword Q_txtRect+4,[iptr]:#20   ; bottom of src Q_Rect		lda	  Q_txtRect+6	   ; ---- ADJUST SOURCE Q_Rect RIGHT ----		ldx	  Q_txtSCB		  ; what mode was the Q_Text in?		beq	  was320		ldx	  Q_pictSCB		 ; 640.  Is the picture?		bne	  putright		dec	  a			   ; nope.  adjust the source bounds		lsr	  a		inc	  a		bra	  putrightwas320	ldx	  Q_pictSCB		 ; 320.  Is the picture?		beq	  putright		asl	  a			   ; nope.  adjust it.putright	moveword a,[iptr]:#22	; store it.		subword  Q_theTxLoc,txtPoint,[iptr]:#24		   ; top of dest.		subword  Q_theTxLoc+2,txtPoint+2,[iptr]:#26	   ; left of dest.		addword  [iptr]:#20,[iptr]:#24,[iptr]:#28	   ; bot. of dest.		addword  [iptr]:#22,[iptr]:#26,[iptr]:#30	   ; right of dest.		moveword mode,[iptr]:#32 ; mode		bra	  abortnotext	movelong #0,Q_txtHsizeabort	_SetPort				 ; restore the old port		return   Q_picterr		ENDP		END