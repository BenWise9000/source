		LOAD		'Macros.dump'		INCLUDE	'SS.equ';		INCLUDE	'Driver.equ';		INCLUDE	'Heap.aii.i';-----------------------------------------------;;	Imported addresses;;-----------------------------------------------		IMPORT	D_FastMult		IMPORT	S_CellWidth		IMPORT	S_ColLabRect		IMPORT	S_CurBScrl		IMPORT	S_CurContHt		IMPORT	S_CurContRect		IMPORT	S_CurContWd		IMPORT	S_CurContXpt		IMPORT	S_CurContYpt		IMPORT	S_CurEditRect		IMPORT	S_CurLEHandle		IMPORT	S_CurMaxTLCell		IMPORT	S_CurTLCell		IMPORT	S_CurVPageSize		IMPORT	S_DrawBorders		IMPORT	S_DrawBothTitles		IMPORT	S_DrawColLabels		IMPORT	S_DrawColTitles		IMPORT	S_DrawRegion		IMPORT	S_DrawRowLabels		IMPORT	S_DrawRowTitles		IMPORT	S_RowLabRect		IMPORT	S_SetVertLines		IMPORT	S_SwapIn		IMPORT	S_WhichCell;-----------------------------------------------;;	Forward addresses and entries;;-----------------------------------------------		ENTRY	S_ScrlUpdate;-------------------------------------------------------------------------;; S_HScrlAction ( PartCode:word, ControlHandle:long ): Result:word;;S_HScrlAction	PROC		EXPORT			;Using	S_CurrentData			input	PartCode:w,ControlHandle:l			output	Result:w			local	MaxColumn:w,Workspace:w,Value:w,Temp:w			local	ScrollRect:r,UpdateRgn:l,dh:w			BEGIN	+b	; Determine if the part is the thumb, or meaningless.			lda		PartCode			cmp		#5			blt		Exit			cmp		#9			bge		Exit	; Get the scroll bars current value.			out		Value:w			in		ControlHandle:l			XTool	_GetCtlValue	; Call the appropriate subroutine depending on which partcode	; is passed.			lda		PartCode			sec			sbc		#5			asl		a			tax			jsr		(HScrollTable,x)Exit			ReturnHScrollTable			DC.W		hScrlLf			DC.W		hScrlRt			DC.W		hPageLf			DC.W		hPageRt;-----------------------------------------------------------------------------	;	All of the entry points must make sure that dh contains the	;	number of Pixels to scroll, value contains the New value for	;	the scroll bar, and Temp contains the New column for the New	;	TLCellhScrlLf			lda		S_CurTLCell+2			dec		a			sta		Temp			jeq		quit			Call		S_CellWidth,in=(a:w),out=(dh:w)			dec		Value			jmp		hScrollRecthPageLf			SubWord	S_CurContWd,S_CurContXpt,Workspace			lda		S_CurTLCell+2			sta		Temp			stz		dh			bra		cond1loop1			Call		S_CellWidth,in=(Temp:w),out=(a:w)			AddWord	a,dh,a			cmp		Workspace			bge		full1			sta		dh			dec		Valuecond1		dec		Temp			bne		loop1endloop1			inc		Temp			lda		dh			jeq		quit			jmp		hScrollRectfull1			tay								; a = next divider			inc		Temp			lda		dh			jne		hScrollRect			MoveWord	y,dh			dec		Value			dec		Temp			jmp		hScrollRect;------------------------------------------hScrlRt			MoveWord	S_CurTLCell+2,Temp			CmpWord	S_CurMaxTLCell+2,Temp			jeq		quit			Call		S_CellWidth,in=(Temp:w),out=(a:w)			eor		#$FFFF				; make a 2's comp neg number			inc		a			sta		dh			inc		Temp			inc		Value			jmp		hScrollRecthPageRt			MoveWord	S_CurMaxTLCell+2,MaxColumn			SubWord	S_CurContXpt,S_CurContWd,Workspace			stz		dh			MoveWord	S_CurTLCell+2,Temp			bra		cond2loop2			Call		S_CellWidth,in=(Temp:w),out=(:w)			SubWord	dh,s,a			cmp		Workspace			blt		full2			beq		full2			sta		dh			inc		Value			inc		Tempcond2			CmpWord	Temp,MaxColumn			blt		loop2endloop2			lda		dh			jeq		quit			jmp		hScrollRectfull2			tay								; a = next divider			lda		dh			bne		hScrollRect			MoveWord	y,dh			inc		Value			inc		Temp;------------------------------------------hScrollRect			MoveWord	Temp,S_CurTLCell+2			Tool		_SetCtlValue,in=(Value:w,ControlHandle:l)			MoveWord	#S_EditHeight+2,ScrollRect			AddWord	S_CurContXpt,#2,ScrollRect+2			MoveLong	S_CurContRect+4,ScrollRect+4			Tool		_NewRgn,out=(UpdateRgn:l)			Tool		_ScrollRect,in=(!ScrollRect:l,dh:w,#0:w,UpdateRgn:l)			Call		S_ScrlUpdate,in=(UpdateRgn:l)			Tool		_DisposeRgn,in=(UpdateRgn:l)quit			rts			ENDP;-------------------------------------------------------------------------;; S_ScrlUpdate ( Region:l );;	S_ScrlUpdate will Update the current graf port after scrolling has been;	done, according to the current sheet.S_ScrlUpdate	PROC		EXPORT			;Using	S_CurrentData			input	Region:l			local	FCell:l,LCell:l,Xpt:w,Ypt:w,RgnPtr:l			local	Xpt2:w,Ypt2:w,OldClipRgn:l			local	OffBottom:w,OffRight:w,Rect:r,RectPtr:l			BEGIN			Tool		_EmptyRgn,in=(Region:l),out=(a:w)			jne		Exit			Tool		_NewRgn,out=(OldClipRgn:l)			Tool		_GetClip,in=(OldClipRgn:l)			Tool		_SetClip,in=(Region:l)			stz		OffBottom			stz		OffRight			MoveLong	[Region],RgnPtr	;	Determine the range to Update, and their coordinates	;			in		[RgnPtr]:#2:l			out		FCell:l,Xpt:w,Ypt:w			XCall	S_WhichCell;			in		[RgnPtr]:#6:l;			out		LCell:l,Xpt2:w,Ypt2:w;			XCall	S_WhichCell			SpaceLong			SpaceWord			SpaceWord			MoveWord	[RgnPtr]:#8,a	; The right and bottom sides			cmp		#2			blt		push1			cmp		S_CurContWd			bge		push1			dec		a				; of the Region are shortened			dec		a				; so that on left and uppush1			pha						; scrolling, only the number			MoveWord	[RgnPtr]:#6,a		; rows or cols inserted are			beq		push2			cmp		S_CurContHt			bge		push2			dec		a				; drawn.;			dec		a				; (mistake)push2			pha			jsl		S_WhichCell			PullWord	Ypt2			PullWord	Xpt2			PullLong	LCell	;	Check to see if either the right or bottom edges show	;			lda		LCell			cmp		#10000				; first non-row			blt		OK1			sta		OffBottom			MoveWord	#9999,LCellOK1			lda		LCell+2			cmp		#$02BF				; first non-col			blt		OK2			sta		OffRight			MoveWord	#$02BE,LCell+2OK2	;	Make the second coordinates Point to the bottom right corner,	;	instead of the top right.			lda		OffBottom			bne		skip1			AddWord	Ypt2,#S_RowHeight,Ypt2skip1			lda		OffRight			bne		skip2			Call		S_CellWidth,in=(LCell+2:w),out=(:w)			AddWord	s,Xpt2,Xpt2skip2	;	Redraw any label Rects necessary	;;			MoveWord	S_CurContWd,S_ColLabRect+6			Tool		_RectInRgn,in=(#S_ColLabRect:l,Region:l),out=(a:w)			beq		skip3			in		Xpt:w,FCell+2:w,LCell+2:w			XCall	S_DrawColLabelsskip3			MoveLong	!Rect,RectPtr			MoveWord	#S_EditHeight+S_ColLabelHeight,Rect			MoveWord	S_CurContXpt,Rect+2			MoveWord	S_CurContYpt,Rect+4			MoveWord	S_CurContWd,Rect+6			Tool		_RectInRgn,in=(RectPtr:l,Region:l),out=(a:w)			beq		skip4			in		Xpt:w,FCell+2:w,LCell+2:w			XCall	S_DrawColTitlesskip4			MoveWord	#S_EditHeight,Rect			stz		Rect+2			MoveWord	S_CurContYpt,Rect+4			MoveWord	S_CurContXpt,Rect+6			Tool		_RectInRgn,in=(RectPtr:l,Region:l),out=(a:w)			beq		skip5			Call		S_DrawBothTitlesskip5;			MoveWord	S_CurContHt,S_RowLabRect+4			Tool		_RectInRgn,in=(#S_RowLabRect:l,Region:l),out=(a:w)			beq		skip6			in		Ypt:w,FCell:w,LCell:w			XCall	S_DrawRowLabelsskip6			MoveWord	S_CurContYpt,Rect			MoveWord	#S_NumLabelWidth,Rect+2			MoveWord	S_CurContHt,Rect+4			MoveWord	S_CurContXpt,Rect+6			Tool		_RectInRgn,in=(RectPtr:l,Region:l),out=(a:w)			beq		skip7			in		Ypt:w,FCell:w,LCell:w			XCall	S_DrawRowTitlesskip7	;	Draw the cells	;			lda		OffRight			ora		OffBottom			beq		borderDone			in		OffRight:w,OffBottom:w,Xpt2:w,Ypt2:w			XCall	S_DrawBordersborderDone			in		Xpt2:w,Ypt2:w,Xpt:w,Ypt:w			in		FCell:l,LCell:l,#1:w			in		S_CurContXpt:w			XCall	S_DrawRegion	;	Clean Up	;			Tool		_SetClip,in=(OldClipRgn:l)			Tool		_DisposeRgn,in=(OldClipRgn:l)Exit			RETURN			ENDP;-------------------------------------------------------------------------;; S_Thumb ( Control:l );;	S_Thumb will handle moving the thumb in any of the scroll bars.S_Thumb		PROC		EXPORT			;Using	S_CurrentData			input	Control:l			local	ScrollRect:r,UpdateRgn:l,CtrlValue:w			local	dh:w,dv:w,OldTLRow:w,OldTLCol:w,WorkCol:w			local	negDH:w			BEGIN			stz		negDH			stz		dh			stz		dv			Tool		_GetCtlValue,in=(Control:l),out=(CtrlValue:w)	;	Determine which scroll bar has been affected	;			CmpLong	Control,S_CurBScrl			beq		doHthumbdoVthumb	;	Reset S_CurTLCell and set the Update Region	;			MoveWord	S_CurTLCell,OldTLRow			lda		CtrlValue			inc		a			sta		S_CurTLCell			SubWord	a,OldTLRow,a			jeq		Exit			eor		#-1					; negate the answer			inc		a			tay							; calculate dv			ldx		#S_RowHeight			Call		D_FastMult			sta		dv			lda		S_CurContYpt			inc		a			sta		ScrollRect			stz		ScrollRect+2			brl		rgnSetdoHthumb	;	Reset S_CurTLCell and set the Update Region	;			MoveWord	S_CurTLCell+2,OldTLCol			lda		CtrlValue			inc		a			sta		S_CurTLCell+2			cmp		OldTLCol			jeq		Exit			blt		includeDest	;	The original TLCell is to the left			inc		negDH			tax			MoveWord	OldTLCol,WorkCol			stx		OldTLCol			bra		startLoop	;	The New TLCell is to the leftincludeDest			sta		WorkColstartLoop			Call		S_CellWidth,in=(WorkCol:w),out=(dh:w)hLoop			inc		WorkCol			CmpWord	WorkCol,OldTLCol			beq		doneLoop			Call		S_CellWidth,in=(WorkCol:w),out=(:w)			AddWord	s,dh,dh			cmp		S_CurContWd			blt		hLoopdoneLoop			lda		negDH			beq		finishHthumb			lda		dh				; negate dh			eor		#-1			inc		a			sta		dhfinishHthumb			Call		S_SetVertLines			MoveWord	#S_EditHeight+2,ScrollRect			AddWord	S_CurContXpt,#2,ScrollRect+2rgnSet			MoveLong	S_CurContRect+4,ScrollRect+4	;	Do the content Update	;			Tool		_NewRgn,out=(UpdateRgn:l)			Tool		_ScrollRect,in=(!ScrollRect:l,dh:w,dv:w,UpdateRgn:l)			Call		S_ScrlUpdate,in=(UpdateRgn:l)			Tool		_DisposeRgn,in=(UpdateRgn:l)Exit			RETURN			ENDP;-------------------------------------------------------------------------;; S_UpdateDoc ( Window:l );;	S_UpdateDoc will Update the given window.S_UpdateDoc	PROC		EXPORT			;Using	S_CurrentData			input	Window:l			local	ClipRect:r			local	ClipRgn:l,LongTemp:l,SUpdateRgn:l			BEGIN	+b	;	Swap in sheet to Update	;			Call		S_SwapIn,in=(Window:l)	;	Draw the controls	;			Tool		_DrawControls,in=(Window:l)			Tool		_EraseRect,in=(#S_CurEditRect:l)			Tool		_LEUpdate,in=(S_CurLEHandle:l)	;	Draw the Seperator Line between the edit field and the sheet	;			Tool		_SetPenSize,in=(#S_ThickPen:l)			Tool		_MoveTo,in=(#0:w,#S_EditHeight:w)			AddWord	S_CurContWd,#S_GrowWidth,s			Tool		_LineTo,in=(:w,#S_EditHeight:w)			Tool		_SetPenSize,in=(#S_NormalPen:l)	;	Everything drawn after this Point must be clipped to the	;	content area			Tool		_NewRgn,out=(ClipRgn:l);			Tool		_GetClip,in=(ClipRgn:l)			Tool		_GetVisRgn,in=(ClipRgn:l)			MoveWord	#S_EditHeight+2,ClipRect			stz		ClipRect+2			MoveWord	S_CurContHt,ClipRect+4			MoveWord	S_CurContWd,ClipRect+6			Tool		_NewRgn,out=(SUpdateRgn:l)			Tool		_RectRgn,in=(SUpdateRgn:l,!ClipRect:l)			Tool		_SectRgn,in=(SUpdateRgn:l,ClipRgn:l,SUpdateRgn:l)			Call		S_ScrlUpdate,in=(SUpdateRgn:l)	;	Clean up	;;			Tool		_SetClip,in=(ClipRgn:l)			Tool		_DisposeRgn,in=(ClipRgn:l)			Tool		_DisposeRgn,in=(SUpdateRgn:l)			RETURN			ENDP;-------------------------------------------------------------------------;;	S_VScrlAction ( PartCode:word, ControlHandle:long ): Result:word;;	S_VScrlAction	PROC		EXPORT			;Using	S_CurrentData			input	PartCode:w,ControlHandle:l			output	Result:w			local	MaxValue:w,ViewSize:w,DataSize:w,Value:w			local	ScrollSize:w,ScrollRect:r,UpdateRgn:l,dv:w			BEGIN	+b	; Determine if the part is the thumb, or meaningless.			lda		PartCode			cmp		#5			blt		Exit			cmp		#9			bge		Exit	; Determine the maximum value for the scroll bar.			lda		S_CurMaxTLCell			dec		a			sta		MaxValue	; Get the scroll bars current value.			in		ControlHandle:l			out		Value:w			XTool	_GetCtlValue	; Call the appropriate subroutine depending on which partcode	; is passed.			lda		PartCode			sec			sbc		#5			asl		a			tax			jsr		(VScrollTable,x)Exit	ReturnVScrollTable			DC.W		vScrlUp			DC.W		vScrlDn			DC.W		vPageUp			DC.W		vPageDn;-----------------------------------------------------------------------------vScrlUp			lda		#1			bra		vUpMainvPageUp			lda		S_CurVPageSizevUpMain										; 'a' contains number of			sta		ScrollSize				; rows to scroll up			lda		Value			jeq		quit			cmp		ScrollSize			blt		vupto0			SubWord	a,ScrollSize,Value			bra		vScrollRectvupto0			sta		ScrollSize			stz		Value			bra		vScrollRect;------------------------------------------vScrlDn		lda		#1			bra		vDnMainvPageDn		lda		S_CurVPageSizevDnMain										; 'a' contains the number			sta		ScrollSize				; of rows to scroll down			lda		Value			cmp		MaxValue			jeq		quit			AddWord	a,ScrollSize,a			cmp		MaxValue			bge		vdntoend			sta		Value			bra		vdnnormalvdntoend			SubWord	MaxValue,Value,ScrollSize			MoveWord	MaxValue,Valuevdnnormal			lda		ScrollSize			eor		#$FFFF				; dn -> negative disp.			inc		a			sta		ScrollSize;------------------------------------------	;	ScrollSize contains the number of rows to scroll, and	;	Value contains the New value for the scroll control.vScrollRect	;	Multiply the number of rows to scroll by #S_RowHeight.	;	This multiply works for negative numbers, too.			ldy		ScrollSize			ldx		#S_RowHeight			Call		D_FastMult			sta		dv	;	Update the window variables	;			SubWord	S_CurTLCell,ScrollSize,S_CurTLCell			Tool		_SetCtlValue,in=(Value:w,ControlHandle:l)	;	Scroll the contents of the window	;			lda		S_CurContYpt			inc		a			sta		ScrollRect			stz		ScrollRect+2			MoveLong	S_CurContRect+4,ScrollRect+4			Tool		_NewRgn,out=(UpdateRgn:l)			Tool		_ScrollRect,in=(!ScrollRect:l,#0:w,dv:w,UpdateRgn:l)			Call		S_ScrlUpdate,in=(UpdateRgn:l)			Tool		_DisposeRgn,in=(UpdateRgn:l)quit			rts			ENDP			END