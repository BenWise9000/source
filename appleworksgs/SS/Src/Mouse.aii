		LOAD		'Macros.dump'		INCLUDE	'SS.equ'		INCLUDE	'Driver.equ'		INCLUDE	'Heap.aii.i';		IMPORT	ArrowCursor;		IMPORT	LeftRightCursor;		IMPORT	OkBox;		IMPORT	appleKey;		IMPORT	shiftKey;-----------------------------------------------;;	Imported addresses;;-----------------------------------------------		IMPORT	D_AlertBox		IMPORT	D_BitMapChanged		IMPORT	D_BitMapPtr		IMPORT	D_MemoryError		IMPORT	D_SetCursor		IMPORT	S_ActivateScrlBars		IMPORT	S_ActiveWindow		IMPORT	S_AdjustCell		IMPORT	S_AdjustPoint		IMPORT	S_AdjustSheetColumns		IMPORT	S_CalculateSheet		IMPORT	S_Cell2Str		IMPORT	S_ChangeColWidth		IMPORT	S_ColLabRect		IMPORT	S_CurBRSelect		IMPORT	S_CurBScrl		IMPORT	S_CurContHt		IMPORT	S_CurContWd		IMPORT	S_CurContXpt		IMPORT	S_CurContYpt		IMPORT	S_CurEditFlag		IMPORT	S_CurEditRect		IMPORT	S_CurGrow		IMPORT	S_CurLEHandle		IMPORT	S_CurRScrl		IMPORT	S_CurTLCell		IMPORT	S_CurTLSelect		IMPORT	S_CurTwiceVertLines		IMPORT	S_CurVertLines		IMPORT	S_CurWindow		IMPORT	S_DashMask		IMPORT	S_DeltaMove		IMPORT	S_DoChecks		IMPORT	S_DoMove		IMPORT	S_DrawLocation		IMPORT	S_DrawMove		IMPORT	S_FindRect		IMPORT	S_FixLE		IMPORT	S_GrowDoc		IMPORT	S_HScrlAction		IMPORT	S_HiliteCells		IMPORT	S_MoveSrcBR		IMPORT	S_MoveSrcTL		IMPORT	S_NoMoveReasonMsg		IMPORT	S_NormalMask		IMPORT	S_RefreshScreen		IMPORT	S_RowLabRect		IMPORT	S_SetCurFormat		IMPORT	S_SetEdittingMenus		IMPORT	S_SetUndoOn		IMPORT	S_SetVertLines		IMPORT	S_SwapIn		IMPORT	S_Thumb		IMPORT	S_VScrlAction		IMPORT	S_WhereCell		IMPORT	S_WhichCell;-----------------------------------------------;;	Forward addresses and entries;;-----------------------------------------------		ENTRY	S_ColLabelClick		ENTRY	S_GIFinish		ENTRY	S_GIMiddle		ENTRY	S_GIScroll		ENTRY	S_GIStart		ENTRY	S_PointShootMove		ENTRY	S_SelectCells		ENTRY	S_SelectFinish		ENTRY	S_SelectMiddle		ENTRY	S_SelectScroll		ENTRY	S_SelectStart		ENTRY	S_TrackVertLine;-------------------------------------------------------------------------;; S_MouseInfo ( TaskRecordPtr:l );;	S_MouseInfo is called by the driver to handle a mouse down event in; the currently active window's info bar.S_MouseInfo	PROC		EXPORT			input	TaskRecordPtr:l			BEGIN	; +b			RETURN			ENDP;-------------------------------------------------------------------------;; S_MouseUp ( TaskRecordPtr:l );;	S_MouseUp is called by the driver when the preceding mouse down was in; an SS window and a mouse up has occured.S_MouseUp		PROC		EXPORT			input	TaskRecordPtr:l			BEGIN	; +b			RETURN			ENDP;-------------------------------------------------------------------------;; S_MouseDown ( Click:w,TaskRecordPtr:l,ClickPt2:l,ClickPt3:l );;	S_MouseDown is called by the driver to handle a mouse down event in; SS's currently active window.S_MouseDown	PROC		EXPORT			;Using	S_CurrentData			input	Click:w,TaskRecordPtr:l,ClickPt2:l,ClickPt3:l			local	Point:l,Control:l			local	ModField:w,Rect:r			BEGIN	+b			Call		S_SwapIn,in=(S_ActiveWindow:l)			Tool		_SetPort,in=(S_ActiveWindow:l)			MoveLong	[TaskRecordPtr]:#10,Point			MoveWord	[TaskRecordPtr]:#14,ModField			out		a:w			in		!Control:l,Point:l,S_CurWindow:l			XTool	_FindControl			jeq		notcontroldocontrol			Call		D_SetCursor,in=(#ArrowCursor:w)			CmpLong	Control,S_CurGrow			bne		dotrack			out		:l			in		#200:w,#70:w,Point:l,S_CurWindow:l			XTool	_GrowWindow			Tool		_SizeWindow,in=(:l,S_CurWindow:l)			Call		S_GrowDoc,in=(S_CurWindow:l)			brl		Exitdotrack			Tool		_GetCtlRefCon,in=(Control:l),out=(ax:l)			asl		a			asl		a			tax			in		Point:l,ActionTable:x:l,Control:l			out		a:w			XTool	_TrackControl			beq		skipThumb	; Check if thumb was tracked.			cmp		#$81			bne		skipThumb			Call		S_Thumb,in=(Control:l)skipThumb			Call		S_SetVertLines			brl		Exitnotcontrol			Tool		_GlobalToLocal,in=(!Point:l)	;	Handle Line Edit click	;			Tool		_PtInRect,in=(!Point:l,#S_CurEditRect:l),out=(a:w)			beq		notEdit			CmpLong	S_CurTLSelect,S_CurBRSelect			jne		Exit			lda		S_CurEditFlag			and		#S_EditingBit			bne		doLEClick			lda		S_CurEditFlag			ora		#S_EditingBit			sta		S_CurEditFlag			Tool		_LEActivate,in=(S_CurLEHandle:l)			Call		S_SetCurFormat,in=(S_CurTLSelect:l)			Call		S_SetEdittingMenusdoLEClick			Tool		_LEClick,in=(TaskRecordPtr:l,S_CurLEHandle:l)			brl		ExitnotEdit	; Any other mouse down in window checks can go here.;			MoveWord	S_CurContWd,S_ColLabRect+6			Tool		_PtInRect,in=(!Point:l,#S_ColLabRect:l),out=(a:w)			beq		chkRowSelect			Call		S_ColLabelClick,in=(Point:l,ModField:w)			brl		ExitchkRowSelect;			MoveWord	S_CurContHt,S_RowLabRect+4			Tool		_PtInRect,in=(!Point:l,#S_RowLabRect:l),out=(a:w)			beq		chkContent			lda		S_CurEditFlag			and		#S_EditingBit			jne		Exit			lda		ModField			and		#shiftKey			beq		doRowSelect			lda		S_CurTLSelect+2			cmp		#1			jne		Exit			lda		S_CurBRSelect+2			cmp		#702			jne		ExitdoRowSelect			in		Point:l,ModField:w,#1:w,#0:w			in		#S_SelectStart:l,#S_SelectMiddle:l,#S_SelectFinish:l			in		#S_SelectScroll:l			XCall	S_SelectCells			brl		ExitchkContent			MoveWord	S_CurContYpt,Rect			MoveWord	S_CurContXpt,Rect+2			MoveWord	S_CurContHt,Rect+4			MoveWord	S_CurContWd,Rect+6			Tool		_PtInRect,in=(!Point:l,!Rect:l),out=(a:w)			beq		Exit			lda		S_CurEditFlag			and		#S_EditingBit			beq		notGraphInput			ldx		#0			in		Point:l,x:w,x:w,x:w			in		#S_GIStart:l,#S_GIMiddle:l,#S_GIFinish:l			in		#S_GIScroll:l			XCall	S_SelectCells			bra		ExitnotGraphInput			lda		ModField			and		#appleKey			beq		doContSelect			Call		S_PointShootMove,in=(Point:l)			bra		ExitdoContSelect			ldx		#0			in		Point:l,ModField:w,x:w,x:w			in		#S_SelectStart:l,#S_SelectMiddle:l,#S_SelectFinish:l			in		#S_SelectScroll:l			XCall	S_SelectCellsExit			RETURNActionTable	DC.L		S_VScrlAction			DC.L		S_HScrlAction			DC.L		0			ENDP;-----------------------------------------------------------------------;;S_ColLabelClick	PROC		EXPORT				;Using	S_CurrentData			input	Point:l,ModField:w			local	VertLineHandle:l			local	EditCol:w,VertLines:l,CurXPos:w			local	NewWidth:w,PrevVertLine:w			BEGIN			ldx		S_CurTwiceVertLines			jeq		notColWd			MoveLong	S_CurVertLines,VertLineHandle			MoveLong	[VertLineHandle],VertLines			txy			lda		Point+2			and		#$FFFCloop			dey			dey			jmi		notColWd			cmp		[VertLines],y			blt		loop			jne		notColWd			sty		EditCol			sta		CurXPos			tya			beq		first				; first vert line			dey			dey			MoveWord	[VertLines]:y,PrevVertLine			bra		trackItfirst			MoveWord	S_CurContXpt,PrevVertLinetrackIt			Call		D_SetCursor,in=(#LeftRightCursor:w)			SpaceWord			PushWord	CurXPos			AddWord	PrevVertLine,#S_MinCellWidth,s			AddWord	1:s,#S_MaxCellWidth-S_MinCellWidth,s			cmp		S_CurContWd			blt		contTrack			lda		S_CurContWd			dec		a			and		#$FFFC			sta		1,scontTrack			PushWord	#S_EditHeight+2			PushWord	S_CurContHt			Call		S_TrackVertLine,in=(:w,:w,:w,:w,:w)	; out= New pos			pla			CmpWord	a,CurXPos			jeq		Exit			SubWord	a,PrevVertLine,NewWidth;			Call		D_SetCursor,in=(#WatchCursor:w)			lda		EditCol			lsr		a			AddWord	a,S_CurTLCell+2,a			Call		S_ChangeColWidth,in=(a:w,NewWidth:w)			bcs		memError			Call		S_ActivateScrlBars			Call		S_SetUndoOn,in=(#S_UndoColWdType:w)			Call		S_AdjustSheetColumns			bra		refreshScreenmemError			Call		D_MemoryErrorrefreshScreen			Call		S_RefreshScreen,in=(#1:w)			bra		ExitnotColWd			lda		S_CurEditFlag			and		#S_EditingBit			bne		Exit			lda		ModField			and		#shiftKey			beq		doSelect			lda		S_CurTLSelect			cmp		#1			bne		Exit			lda		S_CurBRSelect			cmp		#9999			bne		ExitdoSelect			in		Point:l,ModField:w,#0:w,#1:w			in		#S_SelectStart:l,#S_SelectMiddle:l,#S_SelectFinish:l			in		#S_SelectScroll:l			XCall	S_SelectCellsExit			RETURN			ENDP;-------------------------------------------------------------------------;; S_SelectCells;S_SelectCells	PROC		EXPORT			;Using	S_CurrentData			input	Xpt:w,Ypt:w,Modfield:w,FixedCol:w,FixedRow:w			input	StartRoutine:l,MiddleRoutine:l,FinishRoutine:l			input	ScrollRoutine:l			local	OldClipRgn:l,NewClipRgn:l			local	WorkClipRgn:l,Work2Rgn:l			local	ClipRect:r			local	NewPt:l,MouseStatus:w			local	AnchorCell:l,NewCell:l,OldCell:l			local	ContWd:w,ContHt:w			BEGIN			MoveWord	StartRoutine,StartCall+1			sta		StartCall2+1			MoveWord	StartRoutine+1,StartCall+2			sta		StartCall2+2			MoveWord	MiddleRoutine,MiddleCall+1			MoveWord	MiddleRoutine+1,MiddleCall+2			MoveWord	FinishRoutine,FinishCall+1			MoveWord	FinishRoutine+1,FinishCall+2			MoveWord	ScrollRoutine,ScrollCall+1			MoveWord	ScrollRoutine+1,ScrollCall+2			MoveWord	#S_EditHeight+2,ClipRect			stz		ClipRect+2			MoveWord	S_CurContHt,ClipRect+4			sta		ContHt			MoveWord	S_CurContWd,ClipRect+6			sta		ContWd	;	Set the Clip Rgn	;			Tool		_NewRgn,out=(:l)			MoveLong	1:s,OldClipRgn			Tool		_GetClip,in=(:l)			Tool		_NewRgn,out=(:l)			MoveLong	1:s,NewClipRgn			Tool		_RectRgn,in=(:l,!ClipRect:l)			Tool		_SectRgn,in=(NewClipRgn:l,OldClipRgn:l,NewClipRgn:l)			Tool		_SetClip,in=(NewClipRgn:l)			Tool		_NewRgn,out=(WorkClipRgn:l)			Tool		_NewRgn,out=(Work2Rgn:l)	;	Common loop initialization	;			in		Xpt:w,Ypt:w			out		AnchorCell:l,a:w,a:w			XCall	S_WhichCell			CmpWord	AnchorCell+2,#703			jge		cleanup			CmpWord	AnchorCell,#10000			jge		cleanup			MoveLong	#$02BE270F,NewCell	;	Check if shift-Select or just Select	;chkSelect			lda		ModField			and		#shiftKey			bne		ShiftSelectdoStart			SpaceLong			SpaceLong			PushLong	AnchorCell			PushWord	FixedRow			PushWord	FixedCol			PushLong	WorkClipRgn			PushLong	Work2RgnStartCall			jsl		*			PullLong	OldCell			PullLong	AnchorCell			brl		loop	;	Initialize loop for shift-Select	;ShiftSelect			lda		FixedRow			bne		rowSet2			MoveWord	AnchorCell,NewCellrowSet2			lda		FixedCol			bne		colSet2			MoveWord	AnchorCell+2,NewCell+2colSet2			MoveLong	S_CurTLSelect,AnchorCell			MoveLong	S_CurBRSelect,OldCell			lda		FixedRow			bne		OKanchorRow			CmpWord	NewCell,AnchorCell	; compare rows only			bge		OKanchorRow			MoveWord	OldCell,AnchorCell			MoveWord	S_CurTLSelect,OldCellOKanchorRow			lda		FixedCol			bne		OKanchorCol			CmpWord	NewCell+2,AnchorCell+2	; compare cols only			bge		OKanchorCol			MoveWord	OldCell+2,AnchorCell+2			MoveWord	S_CurTLSelect+2,OldCell+2OKanchorCol			lda		#0			pha			pha			pha			pha			pha			pha			pha			pha			PushLong	WorkClipRgn			PushLong	Work2RgnStartCall2			jsl		*			pla			pla			pla			pla			MoveWord	#-1,MouseStatus			brl		doMiddle	;	Track mouse loop	;loop			Tool		_GetMouse,in=(!NewPt:l)			MoveWord	#-1,MouseStatus			Tool		_EventAvail,in=(#4:w,#EventRec:l),out=(a:w)			beq		stillDown			Tool		_GlobalToLocal,in=(#MousePos:l)			MoveLong	MousePos,NewPt			stz		MouseStatusstillDown			Call		S_AdjustPoint,in=(NewPt:l)			PullLong	NewPtchkScrolls			lda		FixedCol			bne		chkTop			CmpWord	NewPt+2,S_CurContXpt			bge		chkRight			jsr		scrollLeft			bra		chkTopchkRight			cmp		ContWd			blt		chkTop			jsr		scrollRight			MoveWord	ContWd,NewPt+2chkTop			lda		FixedRow			bne		OKScroll			CmpWord	NewPt,S_CurContYpt			bge		chkBottom			jsr		scrollUp			bra		OKscrollchkBottom			cmp		ContHt			blt		OKscroll			jsr		scrollDown			MoveWord	ContHt,NewPtOKscroll			in		NewPt:l			out		:l,:l			XCall	S_WhichCell			Call		S_AdjustCell,in=(:l,:l)			pla			pla			pla			plx			ldy		FixedRow			bne		rowStored			sta		NewCellrowStored			ldy		FixedCol			bne		colStored			stx		NewCell+2colStored			lda		MouseStatus			beq		mouseUp			CmpLong	NewCell,OldCell			bne		doMiddle			brl		loopmouseUp			CmpLong	NewCell,OldCell			beq		doFinishdoMiddle			PushLong	AnchorCell			PushLong	OldCell			PushLong	NewCellMiddleCall			jsl		*			MoveLong	NewCell,OldCell			lda		MouseStatus			beq		doFinish			brl		loopdoFinish			PushLong	AnchorCell			PushLong	OldCellFinishCall			jsl		*	;	Clean up	;cleanup			Call		S_SetVertLines			Tool		_DisposeRgn,in=(WorkClipRgn:l)			Tool		_DisposeRgn,in=(Work2Rgn:l)			Tool		_DisposeRgn,in=(NewClipRgn:l)			Tool		_SetClip,in=(OldClipRgn:l)			Tool		_DisposeRgn,in=(OldClipRgn:l)			RETURN;--------------------------------scrollLeft			lda		#5			bra		ScrollHscrollRight			lda		#6ScrollH			pha			pha			PushLong	S_CurBScrl			jsr		doScrollRoutine			Tool		_SetClip,in=(OldClipRgn:l)			Call		S_HScrlAction			Tool		_SetClip,in=(NewClipRgn:l)			jsr		doScrollRoutine			pla			rts;--------------------------------scrollUp			lda		#5			bra		ScrollVscrollDown			lda		#6ScrollV			pha			pha			PushLong	S_CurRScrl			jsr		doScrollRoutine			Tool		_SetClip,in=(OldClipRgn:l)			Call		S_VScrlAction			Tool		_SetClip,in=(NewClipRgn:l)			jsr		doScrollRoutine			pla			rts;--------------------------------doScrollRoutine			PushLong	AnchorCell			PushLong	OldCellScrollCall			jsl		*			rts;--------------------------------EventRec		DS.B 	10MousePos		DS.B 	6			ENDP;--------------------------------------------------------------------------S_SelectData	PROC		EXPORT		EXPORT	S_SelectWorkRgn		EXPORT	S_SelectWork2RgnS_SelectWorkRgn	DS.B 	4S_SelectWork2Rgn	DS.B 	4			ENDP;-----------------------------------------------------------------------------;;S_SelectScroll	PROC		EXPORT			input	Cell1:l,Cell2:l			BEGIN			RETURN			ENDP;-----------------------------------------------------------------------------;;S_SelectStart	PROC		EXPORT			;Using	S_CurrentData			;Using	S_SelectData			output	AnchorCell:l,OldCell:l			input	StartCell:l,FixedRow:w,FixedCol:w			input	WorkClipRgn:l,Work2Rgn:l			BEGIN			MoveLong	WorkClipRgn,S_SelectWorkRgn			MoveLong	Work2Rgn,S_SelectWork2Rgn			lda		StartCell			ora		StartCell+2			beq		Exit	;	Initialize loop for Select	;			lda		FixedRow			ora		FixedCol			bne		hiliteCell			CmpLong	StartCell,S_CurTLSelect			bne		hilitecell			CmpLong	StartCell,S_CurBRSelect			beq		setAnchorhiliteCell			Call		S_HiliteCells			MoveLong	#$00010001,S_CurTLSelect			MoveLong	#$02BE270F,S_CurBRSelect			lda		FixedRow			bne		rowSet			MoveWord	StartCell,S_CurTLSelect			sta		S_CurBRSelectrowSet			lda		FixedCol			bne		colSet			MoveWord	StartCell+2,S_CurTLSelect+2			sta		S_CurBRSelect+2colSet			Call		S_HiliteCellssetAnchor			MoveLong	S_CurTLSelect,AnchorCell			MoveLong	S_CurBRSelect,OldCellExit			RETURN			ENDP;------------------------------------------------------------------------;;S_SelectMiddle	PROC		EXPORT			;Using	S_CurrentData			;Using	S_SelectData			input	AnchorCell:l,OldCell:l,NewCell:l			local	OldRect:r,NewRect:r			BEGIN			PushLong	AnchorCell			PushLong	OldCell			pha			pha			pha			pha			Call		S_FindRect			PullLong	OldRect			PullLong	OldRect+4			pla			pla			pla			pla			inc		OldRect			inc		OldRect+2			inc		OldRect+2			inc		OldRect+4			inc		OldRect+6			inc		OldRect+6			Tool		_RectRgn,in=(S_SelectWorkRgn:l,!OldRect:l)			PushLong	AnchorCell			PushLong	NewCell			pha			pha			pha			pha			Call		S_FindRect			PullLong	NewRect			PullLong	NewRect+4			PullLong	S_CurBRSelect			PullLong	S_CurTLSelect			inc		NewRect			inc		NewRect+2			inc		NewRect+2			inc		NewRect+4			inc		NewRect+6			inc		NewRect+6			Tool		_RectRgn,in=(S_SelectWork2Rgn:l,!NewRect:l)			in		S_SelectWorkRgn:l,S_SelectWork2Rgn:l,S_SelectWorkRgn:l			XTool	_XorRgn			Tool		_InvertRgn,in=(S_SelectWorkRgn:l)			RETURN			ENDP;------------------------------------------------------------------------;;S_SelectFinish	PROC		EXPORT			;Using	S_CurrentData			input	AnchorCell:l,OldCell:l			BEGIN			Call		S_FixLE			Call		S_DoChecks			Call		S_DrawLocation			RETURN			ENDP;-----------------------------------------------------------------------------;;S_GIScroll	PROC		EXPORT			;Using	S_CurrentData			;Using	S_SelectData			input	Cell1:l,Cell2:l			local	Rect:r			BEGIN			Tool		_SetPenMode,in=(#$8002:w)	; not Xor Mode			PushLong	Cell1			PushLong	Cell2			pha			pha			pha			pha			Call		S_FindRect			PullLong	Rect			PullLong	Rect+4			pla			pla			pla			pla			inc		Rect			inc		Rect+2			inc		Rect+2			Tool		_FrameRect,in=(!Rect:l)			Tool		_SetPenMode,in=(#0:w)			RETURN			ENDP;-----------------------------------------------------------------------------;;S_GIStart		PROC		EXPORT			;Using	S_CurrentData			;Using	S_SelectData			output	AnchorCell:l,OldCell:l			input	StartCell:l,FixedRow:w,FixedCol:w			input	WorkClipRgn:l,Work2Rgn:l			local	Rect:r			BEGIN			MoveLong	WorkClipRgn,S_SelectWorkRgn			MoveLong	Work2Rgn,S_SelectWork2Rgn			MoveWord	StartCell,AnchorCell			sta		OldCell			MoveWord	StartCell+2,AnchorCell+2			sta		OldCell+2			Tool		_SetPenMode,in=(#$8002:w)	; not Xor Mode			in		StartCell:l			out		Rect+4:l,Rect:l			XCall	S_WhereCell			inc		Rect			inc		Rect+2			inc		Rect+2			Tool		_FrameRect,in=(!Rect:l)			Tool		_SetPenMode,in=(#0:w)			RETURN			ENDP;------------------------------------------------------------------------;;S_GIMiddle	PROC		EXPORT			;Using	S_CurrentData			;Using	S_SelectData			input	AnchorCell:l,OldCell:l,NewCell:l			local	Rect:r,RectPtr:l			BEGIN			Tool		_SetPenMode,in=(#$8002:w)	; not Xor Mode			MoveLong	!Rect,RectPtr			PushLong	AnchorCell			PushLong	OldCell			pha			pha			pha			pha			Call		S_FindRect			PullLong	Rect			PullLong	Rect+4			pla			pla			pla			pla			inc		Rect			inc		Rect+2			inc		Rect+2			Tool		_FrameRect,in=(RectPtr:l)			PushLong	AnchorCell			PushLong	NewCell			pha			pha			pha			pha			Call		S_FindRect			PullLong	Rect			PullLong	Rect+4			pla			pla			pla			pla			inc		Rect			inc		Rect+2			inc		Rect+2			Tool		_FrameRect,in=(RectPtr:l)			Tool		_SetPenMode,in=(#0:w)			RETURN			ENDP;------------------------------------------------------------------------;;S_GIFinish	PROC		EXPORT			;Using	S_CurrentData			;Using	D_GlobalData			input	Cell1:l,Cell2:l			local	Len:w,Len2:w,TextPtr:l,Text2Ptr:l,Rect:r			BEGIN			Tool		_SetPenMode,in=(#$8002:w)	; not Xor Mode			PushLong	Cell1			PushLong	Cell2			pha			pha			pha			pha			Call		S_FindRect			PullLong	Rect			PullLong	Rect+4			pla			pla			pla			pla			inc		Rect			inc		Rect+2			inc		Rect+2			Tool		_FrameRect,in=(!Rect:l)			Tool		_SetPenMode,in=(#0:w)			Tool		_ClipRect,in=(#S_CurEditRect:l)			MoveLong	>D_BitMapPtr,TextPtr			MoveWord	#1,>D_BitMapChanged			Call		S_Cell2Str,in=(TextPtr:l,Cell1:l)			lda		[TextPtr]			and		#$00FF			sta		Len			incl		TextPtr			CmpLong	Cell1,Cell2			beq		insertText			MoveWord	#$2E2E,[TextPtr]:Len		; hex for '..'			tya			inc		a			inc		a			sta		Len			AddLong	a,TextPtr,Text2Ptr			Call		S_Cell2Str,in=(Text2Ptr:l,Cell2:l)			lda		[Text2Ptr]			and		#$00FF			sta		Len2			AddWord	a,Len,Len			ldy		#1loop			lda		[Text2Ptr],y			dey			sta		[Text2Ptr],y			iny			iny			cpy		Len2			blt		loopinsertText			Tool		_LEDelete,in=(S_CurLEHandle:l)			Tool		_LEInsert,in=(TextPtr:l,Len:w,S_CurLEHandle:l)Exit			RETURN			ENDP;-------------------------------------------------------------------------;; S_TrackVertLine( CurXPos:w,MinXPos:w,MaxXPos:w,TopVerPos:w,BottomVerPos:w );													:NewXPos:w;;	CurXPos, MinXPos and MaxXPos are x-coordinates with the lowest 2 bits;	cleared.S_TrackVertLine	PROC		EXPORT				;Using	S_ConstantData			output	NewXPos:w			input	CurXPos:w,MinXPos:w,MaxXPos:w			input	TopVerPos:w,BottomVerPos:w			local	NewPt:l,MouseStatus:w,FieldPtr:l			BEGIN	; Set pen mode and mask to draw dotted line.setPen			Tool		_SetPenMode,in=(#$8002:w)		; not Xor Mode			Tool		_SetPenMask,in=(#S_DashMask:l)			CmpWord	CurXPos,MinXPos			blt		set2Min			cmp		MaxXPos			blt		drawLineset2Max			MoveWord	MaxXPos,CurXPos			bra		drawLineset2Min			MoveWord	MinXPos,CurXPosdrawLine			Tool		_MoveTo,in=(CurXPos:w,TopVerPos:w)			Tool		_LineTo,in=(CurXPos:w,BottomVerPos:w)	; Wait for the user to either let go of the mouse or move it.waitloop		Tool		_GetMouse,in=(!NewPt:l)			Tool		_StillDown,in=(#0:w),out=(MouseStatus:w)			Call		S_AdjustPoint,in=(NewPt:l)			PullLong	NewPt			and		#$FFFC			sta		NewPt+2			cmp		MinXPos			blt		setNewMin			cmp		MaxXPos			blt		NewSetsetNewMax			MoveWord	MaxXPos,NewPt+2			bra		NewSetsetNewMin			MoveWord	MinXPos,NewPt+2NewSet			lda		MouseStatus			beq		doUnLine			CmpWord	NewPt+2,CurXPos			beq		waitloop	; Undraw the old line.doUnline			Tool		_MoveTo,in=(CurXPos:w,TopVerPos:w)			Tool		_LineTo,in=(CurXPos:w,BottomVerPos:w)	; Set the New draw point.setnew			MoveWord	NewPt+2,CurXPos	; If the user has not let go of the mouse then repeat loop.endloop		lda		MouseStatus			jne		drawLine	; User has released mouse so adjust New position of form bottom line	; and Update the view rect.Exit			Tool		_SetPenMode,in=(#0:w)			Tool		_SetPenMask,in=(#S_NormalMask:l)			MoveWord	CurXPos,NewXPos			RETURN			ENDP;----------------------------------------------------------------------------;;S_PointShootMove	PROC		EXPORT				;Using	S_CurrentData				;Using	S_MoveData				;Using	S_ErrorData			input	Point:l			local	DestTL:l			error	ErrFlag			BEGIN			stz		ErrFlag			in		Point:l			out		DestTL:l,ax:l			XCall	S_WhichCell			SubWord	DestTL,S_CurTLSelect,S_DeltaMove			SubWord	DestTL+2,S_CurTLSelect+2,S_DeltaMove+2			lda		S_DeltaMove			ora		S_DeltaMove+2			bne		contMove			Call		D_AlertBox,in=(#OkBox:w,#S_NoMoveReasonMsg:l),out=(a:w)			bra		ExitcontMove			MoveLong	S_CurTLSelect,S_MoveSrcTL			MoveLong	S_CurBRSelect,S_MoveSrcBR			Call		S_DoMove,err=ErrFlag			bcc		doHilite			lda		ErrFlag			and		#$FF00			cmp		#$0200			bne		ExitmemError			Call		D_MemoryErrordoHilite			Call		S_HiliteCells			AddWord	S_CurTLSelect+2,S_DeltaMove+2,S_CurTLSelect+2			AddWord	S_CurTLSelect,S_DeltaMove,S_CurTLSelect			AddWord	S_CurBRSelect+2,S_DeltaMove+2,S_CurBRSelect+2			AddWord	S_CurBRSelect,S_DeltaMove,S_CurBRSelect			Call		S_HiliteCells			Call		S_DrawMove			Call		S_DrawLocation			Call		S_SetUndoOn,in=(#S_UndoMoveType:w)			lda		S_CurEditFlag			and		#S_ManCalcBit			bne		Exit			Call		S_CalculateSheetExit			RETURN			ENDP			END