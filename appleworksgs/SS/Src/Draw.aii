		LOAD		'Macros.dump'		INCLUDE	'SS.equ'		INCLUDE	'Driver.equ'		INCLUDE	'Heap.aii.i'		INCLUDE	'Eval.aii.i';-----------------------------------------------;;	Imported addresses;;-----------------------------------------------		IMPORT	D_FastMult		IMPORT	D_Set4Pat		IMPORT	D_DrawText		IMPORT	D_DrawString		IMPORT	X_FormatValue		IMPORT	S_Cell2Str		IMPORT	S_CellWidth		IMPORT	S_ClipHandle		IMPORT	S_ColLab2Text		IMPORT	S_ColLabRect		IMPORT	S_CurBRSelect		IMPORT	S_CurBRTitle		IMPORT	S_CurContHt		IMPORT	S_CurContWd		IMPORT	S_CurContXpt		IMPORT	S_CurContYpt		IMPORT	S_CurEditFlag		IMPORT	S_CurPrinting		IMPORT	S_CurTLCell		IMPORT	S_CurTLSelect		IMPORT	S_CurTLTitle		IMPORT	S_DashMask		IMPORT	S_GetCellPtr		IMPORT	S_NormalMask		IMPORT	S_RowLabRect		IMPORT	S_WhereCell		IMPORT	S_WhichCell;-----------------------------------------------;;	Forward addresses and entries;;-----------------------------------------------		ENTRY	S_BackPat		ENTRY	S_DrawRegion		ENTRY	S_FindLeftContent		ENTRY	S_FindRightContent;----------------------------------------------------------------------------;	S_DrawBorders (OffRight:w,OffBottom:w,Xpt:w,Ypt:w);				S_DrawBorders	PROC		EXPORT			input	OffRight:w,OffBottom:w,Xpt:w,Ypt:w			local	Rect:r			BEGIN			lda		OffRight			beq		chkBottom			Tool		_SetPenPat,in=(#S_BackPat:l)			MoveWord	#S_EditHeight+2,Rect			MoveWord	Xpt,Rect+2			AddWord	Ypt,#S_RowHeight,Rect+4			AddWord	Xpt,#S_MaxCellWidth,Rect+6			Tool		_PaintRect,in=(!Rect:l)			Tool		_SetPenPat,in=(#S_NormalPat:l)			Tool		_MoveTo,in=(Xpt:w,#S_EditHeight+2:w)			Tool		_LineTo,in=(Xpt:w,Ypt:w)			inc		Xpt			inc		Xpt			Tool		_MoveTo,in=(Xpt:w,#S_EditHeight+2:w)			Tool		_LineTo,in=(Xpt:w,Ypt:w)chkBottom			lda		OffBottom			beq		Exit			Tool		_SetPenPat,in=(#S_BackPat:l)			MoveWord	Ypt,Rect			MoveWord	#0,Rect+2			AddWord	Ypt,#S_RowHeight,Rect+4			AddWord	Xpt,#S_MaxCellWidth,Rect+6			Tool		_PaintRect,in=(!Rect:l)			Tool		_SetPenPat,in=(#S_NormalPat:l)			Tool		_MoveTo,in=(#0:w,Ypt:w)			Tool		_LineTo,in=(Xpt:w,Ypt:w)			inc		Ypt			Tool		_MoveTo,in=(#0:w,Ypt:w)			Tool		_LineTo,in=(Xpt:w,Ypt:w)Exit			RETURN			EXPORT	S_BackPatS_BackPat			DC.W		$F3F3,$3F3F,$F3F3,$3F3F			DC.W		$F3F3,$3F3F,$F3F3,$3F3F			DC.W		$F3F3,$3F3F,$F3F3,$3F3F			DC.W		$F3F3,$3F3F,$F3F3,$3F3FS_NormalPat			DC.W		0,0,0,0			DC.W		0,0,0,0			DC.W		0,0,0,0			DC.W		0,0,0,0			ENDP;------------------------------------------------------------------------------;	S_DrawCell(Cell:l,Xpt:w,Ypt:w);;	This routine will draw the given cell's value at the given x,y;	coordinates, and bounded by the given width. It clips to appropriate;	rectangle.S_DrawCell	PROC		EXPORT			;Using	S_CurrentData			;Using	D_GlobalData			input	Cell:l,Xpt:w,Ypt:w			local	CellPtr:l,StringPtr:l			local	Format:l,Rect:r,ChkPtr:l			local	Offset:w,ContCell:l,Color:w			local	ClipRight:w,ClipLeft:w,Justify:w			error	ErrorFlag			BEGIN			stz		ErrorFlag			stz		Offset			in		Cell:l			out		CellPtr:l			XCall	S_GetCellPtr			ora		CellPtr			jeq		Quit	;	Cell exists	;			MoveWord	#1,ClipRight			sta		ClipLeft			MoveLong	Cell,ContCell			MoveLong	[CellPtr]:#S_CellFormat,Format			lda		Format			and		#S_CellType			cmp		#S_CellTypeEmpty			jeq		Quit			Tool		_GetTextFace,out=(:w)	; leave on stack for 'Exit'	;	Is it an overlap cell	;			lda		Format			and		#S_CellType			jmi		doOverlap			lda		Format			and		#S_CellBold			beq		textFaceSet			lda		1,s			ora		#$01					; set bold bit on			Tool		_SetTextFace,in=(a:w)textFaceSet			lda		Format			and		#S_CellTypeValue		; either constant or function			bne		doNumber	;	Cell is of type Text	;			lda		S_CurEditFlag			and		#S_ViewFormulaBit			beq		doText			lda		Format			and		#S_CellTypeTextForm			bne		doFormuladoText			lda		Format+2			and		#S_CellCircular			jne		circularCell			jsr		ClrLeft			jsr		ClrRight			jsr		SetText			jsr		DrawString			brl		ExitdoFormula			MoveWord	#4,Offset			H_GetBlockPtr	[CellPtr]:#S_CellContent,StringPtr			in		Cell:l,StringPtr:l			out		StringPtr:l			XCall	E_ExpandFormula			jsr		DrawString			brl		ExitdoNumber			lda		S_CurEditFlag			and		#S_ViewFormulaBit			beq		doValue			lda		Format			and		#S_CellTypeTextForm			bne		doFormuladoValue			lda		Format+2			and		#S_CellCircular			beq		notCirc2circularCell			MoveWord	#DarkRed,Color			MoveLong	#CircStr,StringPtr			PushWord	#40			bra		drawNumbernotCirc2			SpaceWord							; string length			SpaceLong							; string ptr			SpaceWord							; color			Call		S_CellWidth,in=(Cell+2:w),out=(:w)			PushLong	Format			AddLong	CellPtr,#S_CellValue,s			Call		X_FormatValue				;in=(:w,:l,:l),out=(:w,:l,:w)			bcc		OKvalue			lda		9,s			and		#$FFFE					; turn any bold off.			Tool		_SetTextFace,in=(a:w)OKvalue			PullWord	Color			PullLong	StringPtrdrawNumber			lda		Color			pha			xba			ora		1,s			sta		1,s			asl		a			asl		a			asl		a			asl		a			ora		1,s			sta		1,s			Tool		_SetForeColor,in=(:w)			Call		S_CellWidth,in=(Cell+2:w),out=(a:w)			SubWord	a,s,Offset			jsr		DrawString			Tool		_SetForeColor,in=(#0:w)			brl		ExitdoOverlap			cmp		#S_CellTypeLeftPad			beq		fromRight			in		Cell:l			out		ContCell:l,Offset:w			XCall	S_FindLeftContent			stz		ClipLeft			jsr		ClrRight			bra		overContfromRight			in		Cell:l			out		ContCell:l,Offset:w			XCall	S_FindRightContent			stz		ClipRight			jsr		ClrLeftoverCont			in		ContCell:l			out		CellPtr:l			XCall	S_GetCellPtr			MoveLong	[CellPtr]:#S_CellFormat,Format			lda		Format			and		#S_CellBold			beq		textFaceSet2			lda		1,s			ora		#$01						; set bold bit on			Tool		_SetTextFace,in=(a:w)textFaceSet2			jsr		SetText			jsr		DrawStringExit			jsr		DrawUnder			Tool		_SetTextFace,in=(:w)Quit			RETURN;----------------------CircStr			str		'Circ.';----------------------SetText			H_GetBlockPtr	[CellPtr]:#S_CellValue,StringPtr			lda		Format			and		#S_CellJustify			sta		Justify			beq		LeftJust	;	Get String width for right and center justified text	;			Tool		_StringWidth,in=(StringPtr:l),out=(:w)	;	Calculate relative position to start text from front of cell	;			Call		S_CellWidth,in=(ContCell+2:w),out=(a:w)			SubWord	a,s,a	;	If Right justified, this is all	;			ldx		Justify			cpx		#S_CellCenterJustify			bne		justified	;	If Center justified, there's more to do	;CenterJust			tay			bmi		setC	;	If current value is positive, zero must be in top bit after	;	divide.			clc			bra		divide	;	If current value is negative, one must be in top bit after	;	divide.setC			secdivide	;	Since we are centering around 1/2 of cell width, and the present	;	value is (cell width - string width), dividing by 2 gives us	;	(cell width)/2 - (string width)/2, which is what we want.			ror		a			bra		justifiedLeftJust			lda		#4justified			AddWord	a,Offset,Offset			rts;----------------------ClrRight			lda		Cell+2			inc		a			tax			cmp		#$02BF			bge		srDone			in		x:w,Cell:w			out		ChkPtr:l			XCall	S_GetCellPtr			ora		ChkPtr			beq		srDone			MoveWord	[ChkPtr]:#S_CellFormat,a			bpl		srDone			and		#S_CellType			cmp		#S_CellTypeRightPad			bne		srDoneclrClipR			stz		ClipRightsrDone			rts;----------------------ClrLeft			lda		Cell+2			inc		a			tax			cmp		#10000			blt		slDone			in		x:w,Cell:w			out		ChkPtr:l			XCall	S_GetCellPtr			ora		ChkPtr			beq		slDone			MoveWord	[ChkPtr]:#S_CellFormat,a			bpl		slDone			and		#S_CellType			cmp		#S_CellTypeLeftPad			bne		slDoneclrClipL			stz		ClipLeftslDone			rts;----------------------DrawString			lda		Ypt			inc		a			sta		Rect			AddWord	a,#S_TextOffset,Rect+4			Moveword	Xpt,Rect+2			pha			Call		S_CellWidth,in=(Cell+2:w),out=(a:w)			AddWord	a,s,a			inc		a			inc		a			sta		Rect+6			lda		ClipRight			beq		chkClipLeft			dec		Rect+6			dec		Rect+6chkClipLeft			lda		ClipLeft			beq		contDraw			inc		Rect+2			inc		Rect+2contDraw			Tool		_ClipRect,in=(!Rect:l)			Tool		_GetClipHandle,out=(:l)			PushLong	S_ClipHandle			PushLong	5:s			Tool		_SectRgn,in=(:l,:l,:l)	;	LaserWriter hack-around --- GS/OS laserwriter driver doesn't do	;	EraseRect correctly.;			Tool		_EraseRect,in=(!Rect:l)			Call		D_Set4Pat,in=(#White:w)			Tool		_PaintRect,in=(!Rect:l)			Call		D_Set4Pat,in=(#Black:w)			AddWord	Xpt,Offset,s			lda		Rect+4			dec		a			pha			Tool		_MoveTo,in=(:w,:w)			call		D_DrawString,in=(StringPtr:l)			rts;----------------------DrawUnder			lda		Format			and		#S_CellULine			beq		DidUnder			Tool		_SetClip,in=(S_ClipHandle:l);			AddWord	Xpt,#2,s			PushWord	Xpt					; this hangs off both ends			AddWord	Ypt,#S_RowHeight,s			_MoveTo			Call		S_CellWidth,in=(Cell+2:w),out=(:w);			SubWord	1:s,#2,1:s			; pen is 2 pixels wide			Tool		_Line,in=(:w,#0:w)DidUnder			rts			ENDP				;-----------------------------------------------------------------------------;	S_DrawColLabels(Xpt:w,FCol:w,LCol:w);;	This routine draws the column labels in the given range starting at the;	given x coordinate (y = constant).S_DrawColLabels	PROC		EXPORT				;Using	S_CurrentData			input	Xpt:w,FCol:w,LCol:w			local	Wcnt:w,Length:w,TextWd:w			local	Rect:r			BEGIN	;	Calculate the total length of the New labels	;			MoveWord	Xpt,Length			MoveWord	FCol,Wcnt			bra		AddWidthloop4			inc		a			sta		WcntAddWidth			Call		S_CellWidth,in=(a:w),out=(a:w)			AddWord	a,Length,Length			CmpWord	Wcnt,LCol			bne		loop4	;	Paint the background light yellow	;lengthKnown			Call		D_Set4Pat,in=(#LightYellow:w)			MoveWord	S_ColLabRect,Rect			MoveWord	Xpt,Rect+2			MoveWord	S_ColLabRect+4,Rect+4			MoveWord	Length,Rect+6				Tool		_PaintRect,in=(!Rect:l)			Call		D_Set4Pat,in=(#Black:w)	;	Frame the New area	;			Tool		_MoveTo,in=(Xpt:w,#S_EditHeight+S_ColLabelHeight:w)			Tool		_LineTo,in=(Length:w,#S_EditHeight+S_ColLabelHeight:w)			Tool		_MoveTo,in=(Length:w,#S_EditHeight:w)			Tool		_LineTo,in=(Length:w,#S_EditHeight+S_ColLabelHeight:w)	;	Draw the labels centered in the columns, with dividers	;			MoveWord	FCol,Wcnt			lda		LCol			Call		S_ColLab2Text			sta		LCol			lda		FCol			Call		S_ColLab2Text			sta		Bufferloop			Tool		_MoveTo,in=(Xpt:w,#S_EditHeight:w)			Tool		_LineTo,in=(Xpt:w,#S_EditHeight+S_ColLabelHeight:w)	;	Draw label	;			Tool		_TextWidth,in=(#Buffer:l,#2:w),out=(TextWd:w)			Call		S_CellWidth,in=(Wcnt:w),out=(x:w)			SubWord	x,TextWd,a			lsr		a			AddWord	a,Xpt,s			AddWord	x,Xpt,Xpt			Tool		_MoveTo,in=(:w,#S_EditHeight+S_TextOffset+1:w)			Call		D_DrawText,in=(#Buffer:l,#2:w)	;	Increment label by one	;skip			CmpWord	Buffer,LCol			beq		done			inc		Wcnt			AddWord	#$0100,Buffer,Buffer			and		#$FF00			cmp		#$5B00				; hex for 'Z' + 1			jlt		loop			lda		Buffer			and		#$001F			ora		#$4140				; keep most sig letter			inc		a			sta		Buffer			brl		loop			done			RETURNBuffer		DS.B 	2			ENDP;-----------------------------------------------------------------------------;	S_DrawGrid(X2:w,Y2:w,X1:w,Y1:w,LCol:w);;	This routine will draw the grid in the content area of the spreadsheet;	starting at the x1,y1 cordinates and drawing to the x2,y2;	coordinates.S_DrawGrid	PROC		EXPORT			;Using	S_CurrentData			;Using	S_ConstantData			input	X2:w,Y2:w,X1:w,Y1:w,LCol:w			local	Count:w,Wcnt:w			BEGIN			lda		S_CurEditFlag			and		#S_GridOff			jne		Exit			lda		S_CurPrinting			bne		maskSet			Tool		_SetPenMask,in=(#S_DashMask:l)maskSet	;	Draw the horizontal lines	;			MoveWord	Y1,Countloop3			Tool		_MoveTo,in=(X1:w,Count:w)			Tool		_LineTo,in=(X2:w,Count:w)step3			AddWord	#S_RowHeight,Count,Count			CmpWord	Y2,Count			bge		loop3	;	Draw the vertical lines	;			MoveWord	LCol,Wcnt			MoveWord	X1,Countloop4			Tool		_MoveTo,in=(Count:w,Y1:w)			Tool		_LineTo,in=(Count:w,Y2:w)step4			Call		S_CellWidth,in=(Wcnt:w),out=(a:w)			AddWord	a,Count,Count			inc		Wcnt			CmpWord	X2,Count			bge		loop4			Tool		_SetPenMask,in=(#S_NormalMask:l)Exit			RETURN			ENDP;-----------------------------------------------------------------------------;	S_DrawRowLabels(Ypt:w,FRow:w,LRow:w);;	This routine draws the row labels in the given range starting at the given;	y coordinate.	(x = constant).S_DrawRowLabels	PROC		EXPORT				;Using	S_CurrentData			input	Ypt:w,FRow:w,LRow:w			local	Rect:r			BEGIN	;	Calculate the total length of the New labels	;			SubWord	LRow,FRow,a			inc		a			tax			ldy		#S_RowHeight			Call		D_FastMult			AddWord	a,Ypt,Rect+4	;	Paint the background light yellow	;			Call		D_Set4Pat,in=(#LightYellow:w)			MoveWord	Ypt,Rect			MoveWord	S_RowLabRect+2,Rect+2			MoveWord	S_RowLabRect+6,Rect+6			Tool		_PaintRect,in=(!Rect:l)			Call		D_Set4Pat,in=(#Black:w)	;	Frame the New area	;			Tool		_MoveTo,in=(#S_NumLabelWidth:w,Ypt:w)			Tool		_LineTo,in=(#S_NumLabelWidth:w,Rect+4:w)			Tool		_MoveTo,in=(#0:w,Rect+4:w)			Tool		_LineTo,in=(#S_NumLabelWidth:w,Rect+4:w)	;	Draw the labels with dividers	;loop			Tool		_MoveTo,in=(#0:w,Ypt:w)			Tool		_LineTo,in=(#S_NumLabelWidth:w,Ypt:w)			Tool		_Int2Dec,in=(FRow:w,#Buffer:l,#4:w,#0:w)			in		#S_NumLabOffSet-S_NumLabelWidth:w,#S_TextOffset:w			XTool	_Move			Call		D_DrawText,in=(#Buffer:l,#4:w)			inc		FRow			AddWord	Ypt,#S_RowHeight,Ypt			CmpWord	LRow,FRow			bge		loop			RETURNBuffer		DS.B 	4			ENDP;---------------------------------------------------------------------------;	S_HiliteCells;S_HiliteCells	PROC		EXPORT			;Using	S_CurrentData			local	Rect:r			BEGIN			in		S_CurTLSelect:l			out		a:w,a:w,Rect:l			XCall	S_WhereCell			in		S_CurBRSelect:l			out		Rect+4:l,a:w,a:w			XCall	S_WhereCell			lda		Rect			bne		cont1			MoveWord	S_CurContYpt,Rect			bra		chk2cont1			cmp		S_CurContHt			bge		Exitchk2			lda		Rect+2			bne		cont2			MoveWord	S_CurContXpt,Rect+2			bra		chk3cont2			cmp		S_CurContWd			bge		Exitchk3			inc		Rect			inc		Rect+2			inc		Rect+2			lda		Rect+4			beq		Exit			inc		a			cmp		S_CurContHt			blt		cont3			lda		S_CurContHtcont3			sta		Rect+4chk4			lda		Rect+6			beq		Exit			inc		a			inc		a			cmp		S_CurContWd			blt		cont4			lda		S_CurContWdcont4			sta		Rect+6			CmpWord	Rect,Rect+4			bge		Exit			CmpWord	Rect+2,Rect+6			bge		Exit			Tool		_InvertRect,in=(!Rect:l)Exit			RETURN			ENDP;---------------------------------------------------------------------------;	S_FindLeftContent( CurCell:l ): ContCell:l,Offset:w;;S_FindLeftContent	PROC		EXPORT				;Using	S_CurrentData			input	CurCell:l			output	ContCell:l,Offset:w			local	CellPtr:l			BEGIN			stz		OffsetoverlapLoop			dec		CurCell+2			Call		S_CellWidth,in=(CurCell+2:w),out=(:w)			SubWord	Offset,s,Offset			in		CurCell:l			out		CellPtr:l			XCall	S_GetCellPtr			MoveWord	[CellPtr]:#S_CellFormat,a			bmi		overlapLoop			MoveLong	CurCell,ContCell			RETURN			ENDP;---------------------------------------------------------------------------;	S_FindRightContent( CurCell:l ): ContCell:l,Offset:w;;	It may be the first cell.S_FindRightContent	PROC		EXPORT				;Using	S_CurrentData			input	CurCell:l			output	ContCell:l,Offset:w			local	CellPtr:l			BEGIN			stz		OffsetoverlapLoop			Call		S_CellWidth,in=(CurCell+2:w),out=(a:w)			AddWord	a,Offset,Offset			inc		CurCell+2			in		CurCell:l			out		CellPtr:l			XCall	S_GetCellPtr			MoveWord	[CellPtr]:#S_CellFormat,a			bmi		overlapLoop			MoveLong	CurCell,ContCell			RETURN			ENDP;--------------------------------------------------------------------------;;S_DrawLocation	PROC		EXPORT			;Using	S_CurrentData			local	StrPtr:l,TextWd:w			BEGIN			Tool		_EraseRect,in=(#LocRect:l)			CmpLong	S_CurTLSelect,S_CurBRSelect			bne		doRangeStr			MoveLong	#Buffer,StrPtr			Call		S_Cell2Str,in=(#Buffer:l,S_CurTLSelect:l)			bra		doDrawdoRangeStr			MoveLong	#RangeStr,StrPtrdoDraw			Tool		_StringWidth,in=(StrPtr:l),out=(TextWd:w)			SubWord	#S_NumLabelWidth,TextWd,a			lsr		a			Tool		_MoveTo,in=(a:w,#S_EditHeight+S_TextOffset+1:w)			Call		D_DrawString,in=(StrPtr:l)			RETURNLocRect		DC.W		S_EditHeight+2,0			DC.W		S_EditHeight+S_ColLabelHeight,S_NumLabelWidthRangeStr		str		'Range'Buffer		DS.B 	7			ENDP;--------------------------------------------------------------------------;;S_DrawBothTitles	PROC		EXPORT				;Using	S_CurrentData			local	DoDrawRegion:w			BEGIN			stz		DoDrawRegion			Call		S_DrawLocation			CmpWord	S_CurContXpt,#S_NumLabelWidth			beq		chkRowLabels			inc		DoDrawRegion			in		#S_NumLabelWidth:w			in		S_CurTLTitle+2:w,S_CurBRTitle+2:w		; only cols			XCall	S_DrawColLabelschkRowLabels			CmpWord	S_CurContYpt,#S_EditHeight+S_ColLabelHeight			beq		Exit			in		#S_EditHeight+S_ColLabelHeight:w			in		S_CurTLTitle:w,S_CurBRTitle:w	; only rows			XCall	S_DrawRowLabels			lda		DoDrawRegion			beq		Exit			in		S_CurContXpt:w,S_CurContYpt:w			in		#S_NumLabelWidth:w,#S_EditHeight+S_ColLabelHeight:w			in		S_CurTLTitle:l,S_CurBRTitle:l,#0:w			in		#S_NumLabelWidth:w			XCall	S_DrawRegion			in		S_CurContXpt:w,#S_EditHeight+S_ColLabelHeight:w			XTool	_MoveTo			Tool		_LineTo,in=(S_CurContXpt:w,S_CurContYpt:w)			Tool		_MoveTo,in=(#S_NumLabelWidth:w,S_CurContYpt:w)			Tool		_LineTo,in=(S_CurContXpt:w,S_CurContYpt:w)Exit			RETURN			ENDP;--------------------------------------------------------------------------;;S_DrawColTitles	PROC		EXPORT				;Using	S_CurrentData			input	Xpt:w,FCol:w,LCol:w			local	Xpt2:w			BEGIN			CmpWord	S_CurContYpt,#S_EditHeight+S_ColLabelHeight			beq		Exit			in		LCol:w,S_CurTLCell:w			out		Xpt2:w,a:w,a:w,a:w			XCall	S_WhereCell			in		Xpt2:w,S_CurContYpt:w			in		Xpt:w,#S_EditHeight+S_ColLabelHeight:w			in		FCol:w,S_CurTLTitle:w,LCol:w,S_CurBRTitle:w,#0:w			in		S_CurContXpt:w			XCall	S_DrawRegion			Tool		_MoveTo,in=(S_CurContXpt:w,S_CurContYpt:w)			Tool		_LineTo,in=(S_CurContWd:w,S_CurContYpt:w)Exit			RETURN			ENDP;--------------------------------------------------------------------------;;S_DrawRowTitles	PROC		EXPORT				;Using	S_CurrentData			input	Ypt:w,FRow:w,LRow:w			local	Ypt2:w			BEGIN			CmpWord	S_CurContXpt,#S_NumLabelWidth			beq		Exit			in		S_CurTLCell+2:w,LRow:w			out		a:w,Ypt2:w,a:w,a:w			XCall	S_WhereCell			in		S_CurContXpt:w,Ypt2:w			in		#S_NumLabelWidth:w,Ypt:w			in		S_CurTLTitle+2:w,FRow:w,S_CurBRTitle+2:w,LRow:w,#0:w			in		#S_NumLabelWidth:w			XCall	S_DrawRegion			Tool		_MoveTo,in=(S_CurContXpt:w,S_CurContYpt:w)			Tool		_LineTo,in=(S_CurContXpt:w,S_CurContHt:w)Exit			RETURN			ENDP;-----------------------------------------------------------------------------;;S_DrawRegion	PROC		EXPORT			;Using	S_CurrentData			input	Xpt2:w,Ypt2:w,Xpt:w,Ypt:w			input	TLCell:l,BRCell:l,DoHilite:w			input	LeftEdge:w			local	Rect:r,RectPtr:l,OldClip:l			local	Ycnt:w,Xcnt:w,CurCol:w			BEGIN			inc		Ypt2			inc		Xpt2			inc		Xpt2	;	Set the clip area	;			lda		Ypt			inc		a			sta		Rect			AddWord	LeftEdge,#2,Rect+2			MoveWord	S_CurContHt,Rect+4			MoveWord	S_CurContWd,Rect+6			MoveLong	!Rect,RectPtr			Tool		_SectRect,in=(RectPtr:l,!Ypt:l,RectPtr:l),out=(a:w)			Tool		_NewRgn,out=(OldClip:l)			Tool		_GetClip,in=(OldClip:l)			Tool		_NewRgn,out=(S_ClipHandle:l)			Tool		_RectRgn,in=(S_ClipHandle:l,RectPtr:l)			Tool		_SectRgn,in=(OldClip:l,S_ClipHandle:l,S_ClipHandle:l)			Tool		_SetClip,in=(S_ClipHandle:l)	;	Erase, but don't get any border lines.	;			CmpWord	BRCell,#9999			blt		ChkCol			dec		Ypt2			Tool		_MoveTo,in=(#0:w,Ypt2:w)			Tool		_LineTo,in=(Xpt2:w,Ypt2:w)chkCol			CmpWord	BRCell+2,#$02BE			blt		doErase			dec		Xpt2			dec		Xpt2			Tool		_MoveTo,in=(Xpt2:w,#S_EditHeight+2:w)			Tool		_LineTo,in=(Xpt2:w,Ypt2:w)doErase			Tool		_EraseRect,in=(!Ypt:l)	;	Draw grid, the moved endpts are okay.	;			in		Xpt2:w,Ypt2:w,Xpt:w,Ypt:w,TLCell+2:w			XCall	S_DrawGrid			MoveWord	Ypt,Ycnt			bra		skip5	;	Outer loop, for each row in the range, ....	;loop2			AddWord	#S_RowHeight,Ycnt,Ycnt			inc		TLCellskip5			MoveWord	TLCell+2,CurCol			MoveWord	Xpt,Xcnt			bra		skip6	;	Inner loop, for each cell in the current row, ....	;loop1			Call		S_CellWidth,in=(CurCol:w),out=(a:w)			AddWord	a,Xcnt,Xcnt			inc		CurColskip6			in		CurCol:w,TLCell:w,Xcnt:w,Ycnt:w			XCall	S_DrawCell			CmpWord	CurCol,BRCell+2			blt		loop1			CmpWord	TLCell,BRCell			blt		loop2			lda		DoHilite			beq		resetClip			Tool		_SetClip,in=(S_ClipHandle:l)			Call		S_HiliteCellsresetClip			Tool		_SetClip,in=(OldClip:l)			Tool		_DisposeRgn,in=(OldClip:l)			Tool		_DisposeRgn,in=(S_ClipHandle:l)Exit			RETURN			ENDP;-----------------------------------------------------------------------------;	S_PrintPage (TLCell:l,BRCell:l,Rect:r) BRCellPrinted:l;;S_PrintPage	PROC		EXPORT			;Using	S_CurrentData			input	TLCell:l,BRCell:l			input	BRPoint:l,TLPoint:l			output	NextCol:w,NextRow:w			local	BRPointPrinted:l,GetBRLoc:w			BEGIN			stz		GetBRLoc	;	Determine the range to Update, and their coordinates	;			in		BRPoint:l			out		NextRow:l,BRPointPrinted:l			XCall	S_WhichCell			CmpWord	NextRow,TLCell				; rows only			bne		BRowOk			sta		BRCell			inc		a			sta		NextRow			AddWord	BRPointPrinted,#S_RowHeight+1,BRPoint			bra		chkRColBRowOk			cmp		BRCell			beq		doAllVert			blt		doAllVert			inc		GetBRLoc			bra		chkRColdoAllVert			lda		BRPointPrinted			inc		a			sta		BRPoint			lda		NextRow			dec		a			sta		BRCellchkRCol			CmpWord	NextCol,TLCell+2			; cols only			bne		RColOk			sta		BRCell+2			inc		a			sta		NextCol			dec		a			Call		S_CellWidth,in=(a:w),out=(a:w)			inc		a			inc		a			AddWord	a,BRPointPrinted+2,BRPoint+2			bra		gotBRCellRColOk			cmp		BRCell+2			beq		doAllHorz			blt		doAllHorz			inc		GetBRLoc			bra		gotBRCelldoAllHorz			lda		BRPointPrinted+2			inc		a			inc		a			sta		BRPoint+2			lda		NextCol			dec		a			sta		BRCell+2gotBRCell			lda		GetBRLoc			beq		gotBRLoc			in		BRCell:l			out		:w,:w,a:w,a:w			XCall	S_WhereCell			pla			inc		a			sta		BRPoint			pla			inc		a			inc		a			sta		BRPoint+2gotBRLoc			Tool		_ClipRect,in=(!TLPoint:l)			dec		BRPoint			dec		BRPoint+2			dec		BRPoint+2			lda		S_CurEditFlag			and		#S_GridOff			bne		skipTLlines			Tool		_MoveTo,in=(#0:w,#0:w)			Tool		_LineTo,in=(S_CurContWd:w,#0:w)			Tool		_MoveTo,in=(#0:w,#0:w)			Tool		_LineTo,in=(#0:w,S_CurContHt:w)skipTLlines			lda		S_CurContYpt			beq		doneTopTitle			lda		S_CurContXpt			beq		doneBothTitle			in		S_CurContXpt:w,S_CurContYpt:w			in		#0:w,#0:w			in		S_CurTLTitle:l,S_CurBRTitle:l,#0:w			in		#0:w			XCall	S_DrawRegiondoneBothTitle			in		BRPoint+2:w,S_CurContYpt:w			in		S_CurContXpt:w,#0:w			in		TLCell+2:w,S_CurTLTitle:w			in		BRCell+2:w,S_CurBRTitle:w,#0:w			in		S_CurContXpt:w			XCall	S_DrawRegion			Tool		_MoveTo,in=(#0:w,S_CurContYpt:w)			Tool		_LineTo,in=(S_CurContWd:w,S_CurContYpt:w)doneTopTitle			lda		S_CurContXpt			beq		doneLeftTitle			in		S_CurContXpt:w,BRPoint:w			in		#0:w,S_CurContYpt:w			in		S_CurTLTitle+2:w,TLCell:w			in		S_CurBRTitle+2:w,BRCell:w,#0:w			in		#0:w			XCall	S_DrawRegion			Tool		_MoveTo,in=(S_CurContXpt:w,#0:w)			Tool		_LineTo,in=(S_CurContXpt:w,S_CurContHt:w)doneLeftTitle			in		BRPoint:l,S_CurContXpt:w,S_CurContYpt:w			in		TLCell:l,BRCell:l,#0:w			in		S_CurContXpt:w			XCall	S_DrawRegion			RETURN			ENDP			END