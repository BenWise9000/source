	LOAD	'Macros.dump'		INCLUDE	'M16.Profile'		INCLUDE	'SS.equ'		INCLUDE	'Driver.equ'	INCLUDE	'Heap.aii.i'	INCLUDE	'Eval.aii.i';-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	D_AddStrings	IMPORT	D_CheckPurge	IMPORT	D_DisposePtr	IMPORT	D_GetNewUntitled	IMPORT	D_GetPrintHandle	IMPORT	D_GetRefCon	IMPORT	D_KillFont	IMPORT	D_LoadSegment	IMPORT	D_MakeNewWin	IMPORT	D_NeedHand	IMPORT	D_PrOpenDoc	IMPORT	D_SelectFont	IMPORT	D_SetCursor	IMPORT	D_SetRefCon	IMPORT	D_UnloadSegment	IMPORT	S_ActivateScrlBars	IMPORT	S_ActiveWindow	IMPORT	S_BSRect	IMPORT	S_BSValue	IMPORT	S_BreakLink	IMPORT	S_CalcAutoStr	IMPORT	S_CalcManStr	IMPORT	S_ColLab2Text	IMPORT	S_ColLabRect	IMPORT	S_CurBRMost	IMPORT	S_CurBRSelect	IMPORT	S_CurBScrl	IMPORT	S_CurContHt	IMPORT	S_CurContRect	IMPORT	S_CurContWd	IMPORT	S_CurContXpt	IMPORT	S_CurContYpt	IMPORT	S_CurEditFlag	IMPORT	S_CurEditRect	IMPORT	S_CurGrow	IMPORT	S_CurLEHandle	IMPORT	S_CurMaxTLCell	IMPORT	S_CurPrinting	IMPORT	S_CurRScrl	IMPORT	S_CurRowBlock	IMPORT	S_CurSheet	IMPORT	S_CurTLCell	IMPORT	S_CurTLSelect	IMPORT	S_CurTwiceVertLines	IMPORT	S_CurVertLineHandSize	IMPORT	S_CurVertLines	IMPORT	S_CurWindow	IMPORT	S_DefWinRect	IMPORT	S_DisposeRowBlock	IMPORT	S_DoChecks	IMPORT	S_ExTitle	IMPORT	S_GetCellPtr	IMPORT	S_GrowRect	IMPORT	S_HideGridStr	IMPORT	S_InitState	IMPORT	S_InsertControls	IMPORT	S_KillLinks	IMPORT	S_LEHandle	IMPORT	S_LoadAWorksInfo	IMPORT	S_NewSheet	IMPORT	S_PrintPage	IMPORT	S_RSRect	IMPORT	S_RSValue	IMPORT	S_SetBRMostCell	IMPORT	S_SetMaxTLCell	IMPORT	S_SetUndoOff	IMPORT	S_SetUndoOff2	IMPORT	S_SetVertLines	IMPORT	S_ShowGridStr	IMPORT	S_SwapIn	IMPORT	S_SwapOut	IMPORT	S_TBarColor	IMPORT	S_TitleColor	IMPORT	S_ViewDataStr	IMPORT	S_ViewFormStr	IMPORT	S_WinColors	IMPORT	S_WinPlane	IMPORT	S_WinRect	IMPORT	S_WinTitlePtr	IMPORT	S_WindowParms;-------------------------------------------------------------------------;; S_ActivateDoc ( Window:l );;   S_ActivateDoc is called to make the given window the active window.; The driver will make sure that the menu is as it was when the document was; deactivated. (ie menu items are enabled, disabled, inserted and deleted; just as they last were.)  Any checks or menu item style changes, however,; will have been lost and must be refreshed.S_ActivateDoc	PROC	EXPORT	input	Window:l	local	Sheet:l	BEGIN	+b	Call	S_SwapIn,in=(Window:l)	CmpLong	Window,S_ActiveWindow	jeq	setMenuChecks	MoveLong	Window,S_ActiveWindow	Call	S_SetVertLines; Set the Calculate Menu string appropriately	lda	S_CurEditFlag	and	#S_ManCalcBit	bne	setAutoStr	Tool	_SetMItemName,in=(#S_CalcManStr:l,#S_CalculateItem:w)	bra	chkViewModesetAutoStr	Tool	_SetMItemName,in=(#S_CalcAutoStr:l,#S_CalculateItem:w); Set the View Menu string appropriatelychkViewMode	lda	S_CurEditFlag	and	#S_ViewFormulaBit	bne	setDataStr	Tool	_SetMItemName,in=(#S_ViewFormStr:l,#S_ViewItem:w)	bra	chkGridsetDataStr	Tool	_SetMItemName,in=(#S_ViewDataStr:l,#S_ViewItem:w)chkGrid	lda	S_CurEditFlag	and	#S_GridOff	beq	resetGrid	Tool	_SetMItemName,in=(#S_ShowGridStr:l,#S_GridItem:w)	bra	chkLEresetGrid	Tool	_SetMItemName,in=(#S_HideGridStr:l,#S_GridItem:w); Set LE appropriately ;chkLE	lda	S_CurEditFlag	and	#S_EditingBit	beq	setMenuChecks	Tool	_LEActivate,in=(S_CurLEHandle:l)setMenuChecks	Call	S_DoChecks	RETURN	ENDP;-------------------------------------------------------------------------;; S_DeactivateDoc ( Window:l );;   S_DeactivateDoc is called to deactivate the given document window.; Active data is copied at this time to the windows information store.S_DeactivateDoc	PROC	EXPORT	input	Window:l	local	Sheet:l	BEGIN	+b; Only deactivate if the window is still active ;	CmpLong	Window,S_ActiveWindow	bne	broughtOut	Call	S_SetUndoOff2	CmpLong	Window,S_CurWindow	bne	notIn	Tool	_LEDeActivate,in=(S_CurLEHandle:l)	Call	S_SwapOut	bra	broughtOutnotIn	Call	D_GetRefCon,in=(Window:l),out=(Window:l)	MoveLong	[Window],Sheet	Tool	_LEDeActivate,in=([Sheet]:#S_LEHandle:l)broughtOut	stz	S_ActiveWindow	stz	S_ActiveWindow+2Exit	RETURN	ENDP;-------------------------------------------------------------------------;; S_DisposeDoc ( Window:l );;   S_DisposeDoc is called to Close down a given window. Any data structures; associated with the window should be removed.	Note: The window will be; closed by the driver so don't do that here.S_DisposeDoc	PROC	EXPORT	input	Window:l	local	Sheet:l	BEGIN	+b	Call	S_SwapIn,in=(Window:l); Dispose of sub-structures ;	Call	S_KillLinks	Tool	_LEDispose,in=(S_CurLEHandle:l)	Call	H_DisposeHeap	Call	S_DisposeRowBlock,in=(S_CurRowBlock:l); Dispose of the sheet itself ;	Tool	_DisposeHandle,in=(S_CurSheet:l); Deactivate the window, if necessary ;	CmpLong	Window,S_ActiveWindow	bne	clrCurData	Call	S_SetUndoOff	MoveWord	#0,S_ActiveWindow	sta	S_ActiveWindow+2; Clear Current Data ;clrCurData	lda	#0	Call	S_SwapIn,in=(a:w,a:w)Exit	RETURN	ENDP;-------------------------------------------------------------------------;; S_GrowDoc ( Window:l );;   S_GrowDoc adjusts and updates the given window after it has been; resized in the driver.S_GrowDoc	PROC	EXPORT	input	Window:l	local	CtlHdl:l,CtlPtr:l	local	Rect:r,RectPtr:l,ChangedFlag:w	BEGIN	+b	Call	S_SwapIn,in=(Window:l)	stz	ChangedFlag; Save the old control values ;	Tool	_GetCtlValue,in=(S_CurRScrl:l),out=(S_RSValue:w)	Tool	_GetCtlValue,in=(S_CurBScrl:l),out=(S_BSValue:w); Dispose of the old controls ;	MoveLong	!Rect,RectPtr	MoveLong	S_CurRScrl,CtlHdl	MoveLong	[CtlHdl],CtlPtr	MoveLong	[CtlPtr]:#8,Rect	MoveLong	[CtlPtr]:#12,Rect+4	Tool	_EraseRect,in=(RectPtr:l)	Tool	_InvalRect,in=(RectPtr:l)	Tool	_DisposeControl,in=(CtlHdl:l)	MoveLong	S_CurBScrl,CtlHdl	MoveLong	[CtlHdl],CtlPtr	MoveLong	[CtlPtr]:#8,Rect	MoveLong	[CtlPtr]:#12,Rect+4	Tool	_EraseRect,in=(RectPtr:l)	Tool	_InvalRect,in=(RectPtr:l)									 	Tool	_DisposeControl,in=(CtlHdl:l)	MoveLong	S_CurGrow,CtlHdl	MoveLong	[CtlHdl],CtlPtr	MoveLong	[CtlPtr]:#8,Rect	MoveLong	[CtlPtr]:#12,Rect+4	Tool	_EraseRect,in=(RectPtr:l)	Tool	_InvalRect,in=(RectPtr:l)									 	Tool	_DisposeControl,in=(CtlHdl:l); Insert New controls ;	Call	S_InsertControls	Call	S_SetMaxTLCell; Check if S_CurTLCell is less than S_CurMaxTLCell ;	CmpWord	S_CurMaxTLCell,S_CurTLCell	bge	checkCol	sta	S_CurTLCell	inc	ChangedFlagcheckCol	CmpWord	S_CurMaxTLCell+2,S_CurTLCell+2	bge	doOK	sta	S_CurTLCell+2	inc	ChangedFlagdoOK	lda	ChangedFlag	beq	Exit; If adjusted, set globals and control values; and inval the content Region.	lda	S_CurTLCell+2	dec	a	Tool	_SetCtlValue,in=(a:w,S_CurBScrl:l)	lda	S_CurTLCell	dec	a	Tool	_SetCtlValue,in=(a:w,S_CurRScrl:l)	Tool	_EraseRect,in=(#S_CurContRect:l)	Tool	_InvalRect,in=(#S_CurContRect:l)Exit	Call	S_SetVertLines	; ?!?!?! can this be a				; non-active window	Tool	_InvalRect,in=(#S_RSRect:l)	Tool	_InvalRect,in=(#S_BSRect:l)	Tool	_InvalRect,in=(#S_GrowRect:l)	Call	S_ActivateScrlBars	RETURN	ENDP;-------------------------------------------------------------------------;; S_IdleProc ( InWindow:w, PortRectPtr:l, PointPtr:l, TickCount:l );;   S_IdleProc is called every time through the driver's MainLoop for the; active document.  It should handle blinking carets and changing cursors.; The Point is in local coordinates.  InWindow is true if the mouse is; currently over the active window.S_IdleProc	PROC	EXPORT	input	InMyWin:w,RectPtr:l,PtPtr:l,Time:l	local	Sheet:l,Cursor:w,VertLines:l,VertLineHandle:l	BEGIN	+b; If no current window, exit ;	lda	S_ActiveWindow	ora	S_ActiveWindow+2	jeq	Exit; Idle LE field ;	Call	S_SwapIn,in=(S_ActiveWindow:l)	Tool	_SetPort,in=(S_ActiveWindow:l)	MoveWord	S_CurEditFlag,a	and	#S_EditingBit	beq	chkCursor	Tool	_LEIdle,in=(S_CurLEHandle:l); If in window, set the appropriate Cursor ;chkCursor	MoveWord	#ArrowCursor,Cursor	lda	InMyWin	jeq	GotCurs;	MoveWord	S_CurContWd,S_ColLabRect+6	Tool	_PtInRect,in=(PtPtr:l,#S_ColLabRect:l),out=(a:w)	beq	ChkContArea	ldx	S_CurTwiceVertLines	beq	SetPlusCurs	MoveLong	S_CurVertLines,VertLineHandle	MoveLong	[VertLineHandle],VertLines	ldy	#2	lda	[PtPtr],y	and	#$FFFC	txyloop	dey	dey	bmi	SetPlusCurs	cmp	[VertLines],y	blt	loop	beq	SetLRCurs	bra	SetPlusCursSetLRCurs	MoveWord	#LeftRightCursor,Cursor	bra	GotCursChkContArea	Tool	_PtInRect,in=(PtPtr:l,#S_CurContRect:l),out=(a:w)	beq	ChkEditFieldSetPlusCurs	MoveWord	#PlusCursor,Cursor	bra	GotCursChkEditField	Tool	_PtInRect,in=(PtPtr:l,#S_CurEditRect:l),out=(a:w)	beq	GotCurs	MoveWord	#BeamCursor,CursorGotCurs	Call	D_SetCursor,in=(Cursor:w)Exit	RETURN	ENDP;------------------------------------------------------------------------; S_LoadMod ();;   Called whenever the SS module is dynamically loadedS_LoadMod	PROC	EXPORT	error	ErrFlag	BEGIN	+b	ProfileInit	Call	D_LoadSegment,in=(#segSS2:w,#2:w),out=(ax:l),err=ErrFlag	bcs	Exit	Call	D_LoadSegment,in=(#segHeap:w,#2:w),out=(ax:l),err=ErrFlag	bcs	Exit	Call	D_LoadSegment,in=(#segEVAL:w,#2:w),out=(ax:l),err=ErrFlag	bcs	Exit;	Call	D_LoadSegment,in=(#segEvalSS:w,#2:w),out=(ax:l),err=ErrFlag;	bcs	Exit	Call	D_NeedHand,in=(#100:l),out=(S_CurVertLines:l),err=ErrFlag	bcc	doOK	stz	S_CurVertLines	stz	S_CurVertLines+2	bra	ExitdoOK	MoveLong	#100,S_CurVertLineHandSize;	Call	H_SegLoaded	Call	H_InitExit	RETURN	ENDP;-------------------------------------------------------------------------;; S_MakeRoom ( );;   S_MakeRoom will free up any memory that it can.S_MakeRoom	PROC	EXPORT	input	Window:l	;SRP 7/5/89	BEGIN		; +b	RETURN	ENDP;-----------------------------------------------------------------------------; S_MakeWin (NamePtr:l,Plane:l,RectPtr:l): Window:l;; This routine should Create a blank window with name NamePtr; input - NamePtr a string, just like D_GetNewUntitled throw it away (D_DisposePtr);	on a Close.; output - window to use; When called by the driver, this call is always followed by an Open. It; should not make any calls to the driver that use window referencing; (like D_SetRefCon). It should Create a window with no data structure as yet.S_MakeWin	PROC	EXPORT	input	Plane:l,RectPtr:l	output	Window:l	error	ErrorFlag	BEGIN	+b	MoveLong	Plane,S_WinPlane	lda	RectPtr	ora	RectPtr+2	beq	setDefault	MoveRect	[RectPtr],S_WinRect	bra	makeWindowsetDefault	MoveRect	S_DefWinRect,S_WinRectmakeWindow; Request for a New window ;	Tool	_NewWindow,in=(#S_WindowParms:l),out=(Window:l),err=ErrorFlag	bcs	noWindow; Set the window up with invariant constants ;	Tool	_SetOriginMask,in=(#$FFFC:w,Window:l)	Tool	_GetFrameColor,in=(#S_WinColors:l,Window:l)	Moveword	#$020F,S_TBarColor	Moveword	#$0F00,S_TitleColor	Tool	_SetFrameColor,in=(#S_WinColors:l,Window:l)	Tool	_SetPort,in=(Window:l)	Tool	_SetPenSize,in=(#S_NormalPen:l)	Tool	_SetTextMode,in=(#4:w)	Tool	_SetFontFlags,in=(#4:w)	bra	ExitnoWindow	MoveLong	#-1,WindowExit	RETURN	ENDP;-------------------------------------------------------------------------;; S_Message ( Type:Word, Message:Long );;   S_Message is called by the driver to pass on a message.;S_Message	PROC	EXPORT	input	Type:w,Message:l	BEGIN	+b	lda	Type	cmp	#S_ColWidthMsg	bne	chkBreakLink	CmpLong	[Message],S_ActiveWindow	bne	disposeHandle	Tool	_SetPort,in=(S_ActiveWindow:l)	Call	S_SwapIn,in=(S_ActiveWindow:l)	Call	S_LoadAWorksInfo,in=([Message]:#4:l)disposeHandle	Tool	_DisposeHandle,in=([Message]:#4:l)	bra	ExitchkBreakLink	cmp	#S_BreakLinkMsg	bne	Exit	Call	S_SwapIn,in=([Message]:#4:l)	Call	S_BreakLink,in=(Message:l)	Call	S_SwapOutExit	RETURN	#0	ENDP;-------------------------------------------------------------------------;; S_NewDoc ( ModNum:w,Plane:l,RectPtr:l );;   S_NewDoc will Open a blank document on the desktop. Any memory errors; should be returned.  If a New document is successfully created, call; D_MakeNewWin so the driver can Create a window for it.S_NewDoc	PROC	EXPORT	input	Window:l	error	ErrorFlag	BEGIN	+b	lda	#0	sta	ErrorFlag	Call	S_SwapIn,in=(a:w,a:w)	; a = 0	MoveLong	Window,S_CurWindow; Get space for the New sheet ;	Call	S_NewSheet,err=ErrorFlag	jcs	Exit2	Call	S_InitState; Set up the controls ;	MoveWord	#0,S_RSValue	MoveWord	a,S_BSValue	Call	S_InsertControls,err=ErrorFlag	bcs	Exit3	Call	S_SetMaxTLCell	Call	S_ActivateScrlBars; Done, let driver know all has gone well ;	Call	D_SetRefCon,in=(S_CurSheet:l,S_CurWindow:l)	Call	S_SwapOut	bra	ExitExit3	Tool	_DisposeHandle,in=(S_CurSheet:l)Exit2Exit	RETURN	ENDP;-------------------------------------------------------------------------;; S_PrintChanged ( Window:l );;   S_PrintChanged will adjust all the given window's page size dependent; structures after the driver has changed the print record for the window.S_PrintChanged	PROC	EXPORT	input	Window:l	BEGIN	; +b	RETURN	ENDP;-------------------------------------------------------------------------;; S_PrintDoc ( Window:Long );;   S_PrintDoc is called by the driver to print the document belonging to; the specified window.S_PrintDoc	PROC	EXPORT	input	Window:l	local	PrintHandle:l,PrintPtr:l,PrintPort:l	local	PageRect:r,TLPrintCell:l,BRPrintCell:l	local	NextCol:w,NextRow:w,OrigTL:l,RowMajorFlag:w	error	ErrFlag	BEGIN	+biDev	equ	2iPageRect	equ	8wDev	equ	24bjDocLoop	equ	86	stz	ErrFlag	stz	RowMajorFlag	Call	S_SwapIn,in=(Window:l)	Call	D_GetPrintHandle,in=(Window:l),out=(PrintHandle:l)	MoveLong	[PrintHandle],PrintPtr	MoveLong	[PrintPtr]:#iPageRect,PageRect	MoveLong	[PrintPtr]:#iPageRect+4,PageRect+4	PushLong	S_CurTLCell	PushWord	S_CurContHt	PushWord	S_CurContWd	MoveWord	PageRect+4,S_CurContHt	MoveWord	PageRect+6,S_CurContWd	SubWord	S_CurContYpt,#S_EditHeight+S_ColLabelHeight,S_CurContYpt	SubWord	S_CurContXpt,#S_NumLabelWidth,S_CurContXpt; Open printer doc	in	PrintHandle:l,#0:l	out	PrintPort:l	XCall	D_PrOpenDoc	Tool	_PrError,out=(a:w)	jne	closeDoc	MoveLong	PrintPort,S_CurWindow	MoveWord	#-1,S_CurPrinting	CmpLong	S_CurTLSelect,S_CurBRSelect	beq	getAll	MoveLong	S_CurTLSelect,TLPrintCell	MoveLong	S_CurBRSelect,BRPrintCell	bra	DoPrintgetAll	Call	S_SetBRMostCell,in=(#1:w)	lda	#S_BRMostBit	tsb	S_CurEditFlag	MoveLong	#$00010001,TLPrintCell	MoveLong	S_CurBRMost,BRPrintCell; Print the pagesDoPrint	MoveLong	TLPrintCell,OrigTL	MoveWord	[PrintPtr]:#wDev,x	and	#2	beq	orientEq0	CmpWord	[PrintPtr]:#iDev,#3	beq	doRowMajor	bra	PageLooporientEq0	CmpWord	[PrintPtr]:#iDev,#3	beq	PageLoopdoRowMajor	inc	RowMajorFlagPageLoop	Call	D_CheckPurge,err=ErrFlag	bcc	openPage	Tool	_PrSetError,in=(#-128:w)closePage2	brl	closePageopenPage	in	PrintPort:l,#0:l	XTool	_PrOpenPage	Tool	_PrError,out=(ErrFlag:w)	bne	closePage2	Tool	_SetPort,in=(PrintPort:l)	Call	D_KillFont	RCall	D_SelectFont,in=(#$FFFE:a,#$0800:x,#0:y)	Tool	_SetPenSize,in=(#S_NormalPen:l)	Tool	_SetTextMode,in=(#4:w)	Tool	_SetFontFlags,in=(#4:w)	PushLong	#S_WhitePat	_SetBackPat; Draw a page here	MoveLong	TLPrintCell,S_CurTLCell	in	TLPrintCell:l,BRPrintCell:l	in	PageRect+4:l,PageRect:l	out	NextCol:w,NextRow:w	XCall	S_PrintPageclosePage	Tool	_PrClosePage,in=(PrintPort:l)	Tool	_PrError,out=(a:w)	jne	closeDoc	lda	ErrFlag	jne	closePrint	lda	RowMajorFlag	bne	doRowMajorCheck	MoveWord	NextRow,TLPrintCell	CmpWord	BRPrintCell,NextRow	jge	PageLoop	MoveWord	NextCol,TLPrintCell+2	MoveWord	OrigTL,TLPrintCell	CmpWord	BRPrintCell+2,NextCol	blt	closePrint	brl	PageLoopdoRowMajorCheck	MoveWord	NextCol,TLPrintCell+2	CmpWord	BRPrintCell+2,NextCol	jge	PageLoop	MoveWord	NextRow,TLPrintCell	MoveWord	OrigTL+2,TLPrintCell+2	CmpWord	BRPrintCell,NextRow	blt	closePrint	brl	PageLoop; Close printer doccloseDoc	sta	ErrFlagclosePrint	Tool	_PrCloseDoc,in=(PrintPort:l)	Tool	_PrError,out=(a:w)	bne	handleError	lda	ErrFlag	bne	handleError; Print spooled file if neccessary	MoveLong	[PrintHandle],PrintPtr	MoveWord	[PrintPtr]:#bjDocLoop,a	and	#$00FF	beq	Printed	in	PrintHandle:l,#0:l,#StatusRecord:l	XTool	_PrPicFile	Tool	_PrError,out=(a:w)	beq	PrintedhandleError	sta	ErrFlag; Just Close things up, the driver will handle the error ;Printed	PullWord	S_CurContWd	PullWord	S_CurContHt	PullLong	S_CurTLCell	AddWord	S_CurContYpt,#S_EditHeight+S_ColLabelHeight,S_CurContYpt	AddWord	S_CurContXpt,#S_NumLabelWidth,S_CurContXpt	stz	S_CurPrinting	MoveLong	Window,S_CurWindowExit	RETURNStatusRecord	DS.B	28S_WhitePat	DC.L	-1,-1,-1,-1,-1,-1,-1,-1	ENDP;-----------------------------------------------------------------------; S_RelockMem ();;   Should relock handles unlocked during UnLockMemS_RelockMem	PROC	EXPORT	input	Window:l	BEGIN	; +b	Call	H_ResetHeap	RETURN	ENDP;------------------------------------------------------------------------; S_UnloadMod ();;   Called whenever the SS module is dynamically unloadedS_UnloadMod	PROC	EXPORT	BEGIN	+b	lda	S_CurVertLines	ora	S_CurVertLines+2	beq	doOK	Tool	_DisposeHandle,in=(S_CurVertLines:l)doOK;	Call	H_SegUnloaded;	Call	D_UnloadSegment,in=(#segEvalSS:w,#2:w)	Call	D_UnloadSegment,in=(#segEVAL:w,#2:w)	Call	D_UnloadSegment,in=(#segHeap:w,#2:w)	Call	D_UnloadSegment,in=(#segSS2:w,#2:w)	RETURN	ENDP;-----------------------------------------------------------------------; S_UnlockMem ();;	Called when memory is in trouble. Should try to UnLock handles; that are Locked. It's guaranteed that RelockMem will be called; before control leaves the driver. (In other words, ReLockMem will be; called as soon as memory has had the chance to compact.)S_UnlockMem	PROC	EXPORT	input	Window:l	BEGIN		; +b	Call	H_UnsetHeap	RETURN	ENDP	END