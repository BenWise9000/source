		LOAD		'Macros.dump'		INCLUDE	'SS.equ'		INCLUDE	'Driver.equ'		INCLUDE	'Heap.aii.i';-----------------------------------------------;;	Imported addresses;;-----------------------------------------------		IMPORT	D_AlertBox		IMPORT	D_BeachBall		IMPORT	D_BitMapChanged		IMPORT	D_BitMapPtr		IMPORT	D_Close2		IMPORT	D_Create2		IMPORT	D_GetMark2		IMPORT	D_MemoryError		IMPORT	D_Open2		IMPORT	D_OpenId		IMPORT	D_Read2		IMPORT	D_ReadLong2		IMPORT	D_ReadWord2		IMPORT	D_SetRefCon		IMPORT	D_SetMark2	IMPORT	D_Str1	IMPORT	D_StrToStr1		IMPORT	D_Write2		IMPORT	D_WriteLong2		IMPORT	D_WriteWord2		IMPORT	X_FormatValue		IMPORT	E_ExpandFormula		IMPORT	S_AcceptCell		IMPORT	S_ActivateScrlBars		IMPORT	S_AddCellToChangedList		IMPORT	S_BSValue		IMPORT	S_CurBRMost		IMPORT	S_CurBRSelect		IMPORT	S_CurBScrl		IMPORT	S_CurChangedList		IMPORT	S_CurColumnWds		IMPORT	S_CurEditFlag		IMPORT	S_CurHeap		IMPORT	S_CurMaxTLCell		IMPORT	S_CurRScrl		IMPORT	S_CurRowBlock		IMPORT	S_CurSheet		IMPORT	S_CurState		IMPORT	S_CurTLCell		IMPORT	S_CurTLSelect		IMPORT	S_CurWindow		IMPORT	S_DisposeRowBlock		IMPORT	S_ErrorBadFile		IMPORT	S_ErrorBadVersion		IMPORT	S_FileBSValue		IMPORT	S_FileRSValue		IMPORT	S_GetCellIndex		IMPORT	S_GetCellPtr		IMPORT	S_InsertControls		IMPORT	S_LoadCharts		IMPORT	S_NewLineEdit		IMPORT	S_NewSheet		IMPORT	S_NormalizeRange		IMPORT	S_QTraverse		IMPORT	S_RSValue		IMPORT	S_RemoveCell		IMPORT	S_SaveCharts		IMPORT	S_SetBRMostCell		IMPORT	S_SetMaxTLCell		IMPORT	S_StateSize		IMPORT	S_SwapIn		IMPORT	S_SwapOut;-----------------------------------------------;;	Forward addresses and entries;;-----------------------------------------------		ENTRY	S_FileID		ENTRY	S_GetFileCell		ENTRY	S_LoadCellsIntoSheet		ENTRY	S_LoadColWds		ENTRY	S_LoadRecalculateList		ENTRY	S_ReadInMore		ENTRY	S_SaveAsciiCell		ENTRY	S_SaveCellAscii		ENTRY	S_SaveCellsFromSheet		ENTRY	S_SaveColWds		ENTRY	S_SaveRecalculateList		ENTRY	S_WriteOutMore;	Definition of File Sheet structure;	This is modeled after the scrap structure; S_FileRows		gequ		0; S_FileCols		gequ		2; S_FileSheetSize	gequ		4; S_FileSheet		gequ		8; S_FileCellLoc	gequ		0; S_FileCellSize	gequ		4; S_FileFormat		gequ		6; S_FileValueSize	gequ		10; S_FileValue		gequ		11;------------------------------------------------------------------------;;S_FileIOData	PROC		EXPORT		EXPORT	S_LoadingFile		EXPORT	S_FileBufferSize		EXPORT	S_UsedBufferSize		EXPORT	S_FilePtr		EXPORT	S_FileSize		EXPORT	S_SheetSizeAcc		ENTRY	S_FileIDS_LoadingFile		DC.W		0S_FileBufferSize	DS.W		1S_UsedBufferSize	DS.W		1S_FilePtr			DS.L		1S_FileSize		DS.L		1S_SheetSizeAcc		DS.L		1S_FileID			DS.W		1			ENDP;-------------------------------------------------------------------------;; S_OpenDoc ( Window:l );;	S_OpenDoc is called to read in SS data from a user specified file.; Window is the window returned by the previous MakeWin call.  ; The file Mark is set just after any driver header information in the file.; All tool or ProDOS errors should be returned.S_OpenDoc		PROC		EXPORT			;Using	D_IOData			;Using	D_GlobalData			;Using	S_CurrentData			;Using	S_WindowData			;Using	S_ErrorData			;Using	S_FileIOData			input	FileId:w,Window:l			local	CellIndex:l,ChartSize:l			local	HeapSize:l,Ptr:l			error	ErrorFlag			BEGIN	+b			stz		ErrorFlag			inc		S_LoadingFile			lda		#0			Call		S_SwapIn,in=(a:w,a:w)			MoveLong	Window,S_CurWindow	;	Make the fileid global so that all of the sub-routines can use it.			MoveWord	FileId,S_FileID	;	Get version number. If version number does not match current version	;	number then file format is not compatible so warn user.			Call		D_ReadWord2,in=(FileId:w),out=(a:w),err=ErrorFlag			bcs		doProdosError1			cmp		#S_FileVersion1v3			; release version 1.0v3			beq		versionOK					; minor changes (like not writeing, can read 1.0v2			cmp		#S_FileVersion1v2			; release version 1.0v2			beq		versionOK					; no change from 1.0v1, except for new functions			cmp		#S_FileVersion1v1			; release version 1.0v1			beq		versionOK			blt		doBadFileError	;	File format is of incompatible version. So pop up dialog warn user	;	and then exit with error.			Call		D_AlertBox,in=(#OkBox:w,#S_ErrorBadVersion:l),out=(a:w)			MoveWord	#-1,ErrorFlag			brl		ErrExitdoBadFileError			Call		D_AlertBox,in=(#OKBox:w,#S_ErrorBadFile:l),out=(a:w)			MoveWord	#-1,ErrorFlagdoProdosError1			brl		ErrExitversionOK			Call		D_ReadLong2,in=(FileId:w),out=(S_FileSize:l),err=ErrorFlag			bcs		doProdosError1			lda		S_FileSize			ora		S_FileSize+2			beq		doBadFileError			MoveWord	#1,>D_BitMapChanged			MoveLong	>D_BitMapPtr,S_FilePtr			stz		S_FileBufferSize			stz		S_UsedBufferSize			Call		S_ReadInMore,err=ErrorFlag			bcs		doProdosError1	;	Read State values into sheet.			in		S_FilePtr:l,#S_CurState:l,#S_StateSize:l			XTool	_BlockMove			lda		#S_StateSize			AddLong	a,S_FilePtr,S_FilePtr			AddWord	#S_StateSize,S_UsedBufferSize,S_UsedBufferSize	;	Clear the ChangedList, so that it will remain integral.  We will	;	load the list off of disk in S_LoadRecalculateList.			stz		S_CurChangedList			stz		S_CurChangedList+2	;	Read in the required Heap size.;			MoveLong	S_FilePtr,Ptr;			MoveLong	[Ptr],HeapSize			AddLong	#4,S_FilePtr,S_FilePtr			AddWord	#4,S_UsedBufferSize,S_UsedBufferSize			H_NewHeap	S_CurHeap,err=ErrorFlag			jcs		ErrExit			stz		S_CurRowBlock			stz		S_CurRowBlock+2	;	Read in the Heap Size and make sure it is available.	;	This should speed up the fail time on large spreadsheets.	;	No longer implemented. (6/8/89) MRH ;;			lda		HeapSize;			ora		HeapSize+2;			beq		ldColWds;;			H_NeedSpace	HeapSize,err=ErrorFlag;			bcc			ldColWds;;			brl		doProdosError	;	Read in the Column Widths.ldColWds			Call		S_LoadColWds,err=ErrorFlag			bcs		doProdosError	;	Read in the Dependency information.	;	Not implemented.	;			AddLong	#4,S_FilePtr,S_FilePtr			AddWord	#4,S_UsedBufferSize,S_UsedBufferSize	;	Read in the Cells.			Call		S_LoadCellsIntoSheet,err=ErrorFlag			bcs		doProdosError			Call		S_ReadInMore,err=ErrorFlag			bcs		doProdosError	;	Read in the Chart information.			in		S_FilePtr:l			out		ChartSize:l			XCall	S_LoadCharts,err=ErrorFlag			bcs		doProdosError			AddLong	S_FilePtr,ChartSize,S_FilePtr			AddWord	ChartSize,S_UsedBufferSize,S_UsedBufferSize	;	Read in the Recalculate List.			Call		S_LoadRecalculateList,err=ErrorFlag			bcc		createSheetdoProdosError			brl		ErrExit2	;	Create sheet.createSheet			Call		S_NewSheet,err=ErrorFlag			jcs		ErrExit2	;	Calculate all the dependent window values, Create the window	;	controls, fill the LineEdit record, set the window's refcon and	;	show the window before returning.	;	Set up the controls	;			MoveWord	S_FileRSValue,S_RSValue			MoveWord	S_FileBSValue,S_BSValue			Call		S_InsertControls,err=ErrorFlag			jcs		ErrExit3			Call		S_SetMaxTLCell			Call		S_NormalizeRange,in=(S_CurTLCell:l,S_CurMaxTLCell:l)			pla			pla			PullLong	S_CurTLCell	;	If adjusted, set globals and control values	;	;	and inval the content region.				;			lda		S_CurTLCell+2			dec		a			Tool		_SetCtlValue,in=(a:w,S_CurBScrl:l)			lda		S_CurTLCell			dec		a			Tool		_SetCtlValue,in=(a:w,S_CurRScrl:l)			Call		S_ActivateScrlBars	;	Were we editing, the current cell	;			CmpLong	S_CurTLSelect,S_CurBRSelect			bne		showWindow			lda		S_CurEditFlag			and		#-1-S_EditingBit			sta		S_CurEditFlag			in		S_CurTLSelect:l			out		CellIndex:l			XCall	S_GetCellIndex			ora		CellIndex			beq		showWindow			in		CellIndex:l			XCall	S_NewLineEditshowWindow			Call		D_SetRefCon,in=(S_CurSheet:l,Window:l)			Call		S_SwapOut			Tool		_ShowWindow,in=(Window:l)			bra		ExitErrExit3			Tool		_DisposeHandle,in=(S_CurSheet:l)ErrExit2			Call		H_DisposeHeap			Call		S_DisposeRowBlock,in=(S_CurRowBlock:l)ErrExit;			lda		ErrorFlag		; this is handled by the driver now.;			and		#$FF00;			cmp		#$0200;			bne		Exit;;			Call		D_MemoryErrorExit			stz		S_LoadingFile			RETURN			ENDP;-------------------------------------------------------------------------;; S_SaveDoc (FileId:w,Window:l,Type:w);;	S_SaveDoc is called to Save the given window's data to file.; If type is 0 (Sworks type), a header is already written out to disk.; Just add your information.;	If type is non-zero then it is Save As of a different file type, and you; just need to write out the information, as the file is already open.S_SaveDoc		PROC		EXPORT			;Using	D_IOData			;Using	D_GlobalData			;Using	S_ErrorData			;Using	S_CurrentData			;Using	S_FileIOData			input	FileId:w,Window:l,Type:w			local	FileSizeMark:l,SheetSizeMark:l,ChartSize:l			local	Ptr:l,HeapSize:l			error	ErrorFlag			BEGIN	+b			stz		ErrorFlag			MoveWord	FileId,S_FileID			Call		S_SwapIn,in=(Window:l)	;	Based on type of Save call either Save as ascii text or Save as SS.			lda		Type			jne		notSWORKS;>>>>>>>>>>>>>>>>>>>>>>>>	Save SWORKS format	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*; Regular Save goes here. Write out window frame variables and the heap contents.;	;	Write file format version.			Call		D_WriteWord2,in=(S_FileId:w,#S_FileVersion1v3:w),err=ErrorFlag			bcs		doProdosError1	;	Save room in file for the file size.			Call		D_GetMark2,in=(S_FileID:w),out=(FileSizeMark:l),err=ErrorFlag			bcc		setUpBufferdoProdosError1			brl		Exit	;	Set up the FileIOData.setUpBuffer			MoveWord	#1,>D_BitMapChanged			stz		S_UsedBufferSize			stz		S_FileSize			stz		S_FileSize+2			MoveLong	>D_BitMapPtr,Ptr			MoveLong	#0,[Ptr]			AddLong	#4,Ptr,S_FilePtr			MoveWord	#4,S_UsedBufferSize	;	Write out window frame information.			Call		S_SetBRMostCell,in=(#0:w)			lda		#S_BRMostBit			trb		S_CurEditFlag			Tool		_GetCtlValue,in=(S_CurRScrl:l),out=(S_FileRSValue:w)			Tool		_GetCtlValue,in=(S_CurBScrl:l),out=(S_FileBSValue:w)			in		#S_CurState:l,S_FilePtr:l,#S_StateSize:l			XTool	_BlockMove			lda		#S_StateSize			AddLong	a,S_FilePtr,S_FilePtr			AddWord	#S_StateSize,S_UsedBufferSize,S_UsedBufferSize	;	Write out the required heap size.	;	This has been removed for lack of anything better.  The heap is no	;	longer one large heap, so it is difficult to judge whether the heap size	;	has any significance.  We will continue to truncate the heap with the	;	intent to reduce memory space.  (6/8/89)  MRH;			stz		HeapSize;			stz		HeapSize+2;;			lda		S_CurHeap;			ora		S_CurHeap+2;			beq		storeSize			Call		H_TruncHeap;			Tool		_GetHandleSize,in=(S_CurHeap:l),out=(HeapSize:l)storeSize			MoveLong	S_FilePtr,Ptr;			MoveLong	HeapSize,[Ptr]			MoveLong	#0,[Ptr]				; do this instead!			AddLong	#4,Ptr,S_FilePtr			AddWord	#4,S_UsedBufferSize,S_UsedBufferSize	;	Write out the Column Widths.			Call		S_SaveColWds,err=ErrorFlag			bcc		writeDependdoProdosError2			brl		Exit	;	Write out Dependency informationwriteDepend		;	Not implemented yet.	;			MoveLong	S_FilePtr,Ptr			MoveLong	#0,[Ptr]			AddLong	#4,S_FilePtr,S_FilePtr			AddWord	#4,S_UsedBufferSize,S_UsedBufferSize	;	Write out the Cells.			out		SheetSizeMark:l			XCall	S_SaveCellsFromSheet,err=ErrorFlag			bcs		doProdosError2			AddLong	FileSizeMark,SheetSizeMark,SheetSizeMark			Call		S_WriteOutMore,err=ErrorFlag			bcs		doProdosError3	;	Write out the Chart information.			in		S_FilePtr:l			out		ChartSize:l			XCall	S_SaveCharts,err=ErrorFlag			bcs		doProdosError3			AddLong	S_FilePtr,ChartSize,S_FilePtr			AddWord	ChartSize,S_UsedBufferSize,S_UsedBufferSize	;	Write out the Recalculate List.			Call		S_SaveRecalculateList,err=ErrorFlag			bcc		doFlushdoProdosError3			brl		Exit	;	Flush everything out to disk.doFlush			in		S_FileID:w,>D_BitMapPtr:l,#0:w,S_UsedBufferSize:w			out		ax:l			XCall	D_Write2,err=ErrorFlag			bcs		doProdosError3			lda		S_UsedBufferSize			AddLong	a,S_FileSize,S_FileSize	;	Plug in the size values.StartOfFile	equ		0			Call		D_SetMark2,in=(S_FileId:w,#StartOfFile:w,FileSizeMark:l),err=ErrorFlag			bcs		doProdosError4			PushWord	S_FileId			SubLong	S_FileSize,#4,s			Call		D_WriteLong2,in=(:w,:l),err=ErrorFlag			bcs		doProdosError4			Call		D_SetMark2,in=(S_FileId:w,#StartOfFile:w,SheetSizeMark:l),err=ErrorFlag			bcs		doProdosError4			Call		D_WriteLong2,in=(S_FileId:w,S_SheetSizeAcc:l),err=ErrorFlagdoProdosError4			brl		ExitnotSWORKS;>>>>>>>>>>>>>>>>>>>>>>>>	Save ASCII format	<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*; Ascii Save goes here. Put tabs between each cell, and carriage returns; between each row.	;	Save something for each cell in the spreadsheet	;			lda		S_CurEditFlag			and		#S_BRMostBit			beq		BRset			Call		S_SetBRMostCell,in=(#0:w)			lda		#S_BRMostBit			trb		S_CurEditFlagBRset		;	Tool		_HLock,in=(S_CurHeap:l)			MoveWord	#1,S_SaveAsciiCell			sta		S_SaveAsciiCell+2			in		a:w,a:w,S_CurBRMost:l,#S_SaveCellAscii:l			XCall	S_QTraverse,err=ErrorFlag			bcs		asciiExit			Call		D_Write2,in=(S_FileID:w,#crChar:l,#1:l),out=(ax:l),err=ErrorFlagasciiExit		;	Tool		_HUnLock,in=(S_CurHeap:l)Exit			RETURNcrchar		DC.B		13			ENDP;---------------------------------------------------------------------------;;S_ReadInMore	PROC		EXPORT			;Using	D_IOData			;Using	D_GlobalData			;Using	S_FileIOData			local	ShiftSize:l,TempSize:l,ReadSize:l			error	ErrFlag			BEGINTempPtr		equ		TempSize			stz		ErrFlag			lda		S_FileSize			ora		S_FileSize+2			jeq		Exit			lda		S_FileBufferSize			bne		notNewRead			stz		ShiftSize			bra		skip1notNewRead			CmpWord	S_UsedBufferSize,#$6000			jlt		Exit			SubWord	S_FileBufferSize,S_UsedBufferSize,ShiftSizeskip1			stz		ShiftSize+2			AddLong	ShiftSize,S_FileSize,TempSize			CmpLong	TempSize,#$8000			blt		useFileSize			MoveWord	#$8000,S_FileBufferSize			bra		doShiftuseFileSize			MoveWord	TempSize,S_FileBufferSizedoShift			SubWord	S_FileBufferSize,ShiftSize,ReadSize			stz		ReadSize+2			SubLong	S_FileSize,ReadSize,S_FileSize			lda		ShiftSize			beq		doRead			in		S_FilePtr:l,>D_BitMapPtr:l,ShiftSize:l			XTool	_BlockMovedoRead			stz		S_UsedBufferSize			MoveLong	>D_BitMapPtr,S_FilePtr			AddLong	>D_BitMapPtr,ShiftSize,TempPtr			Call		D_Read2,in=(S_FileID:w,TempPtr:l,ReadSize:l),out=(ax:l),err=ErrFlagExit			RETURN			ENDP;---------------------------------------------------------------------------;;S_WriteOutMore	PROC		EXPORT			;Using	D_IOData			;Using	D_GlobalData			;Using	S_FileIOData			local	ShiftSize:l			error	ErrFlag			BEGIN			stz		ErrFlag			CmpWord	S_UsedBufferSize,#$6000			blt		Exit			in		S_FileID:w,>D_BitMapPtr:l,#0:w,S_UsedBufferSize:w			out		ax:l			XCall	D_Write2,err=ErrFlag			bcs		Exit			lda		S_UsedBufferSize			AddLong	a,S_FileSize,S_FileSize			stz		S_UsedBufferSize			MoveLong	>D_BitMapPtr,S_FilePtrExit			RETURN			ENDP;---------------------------------------------------------------------------;;S_LoadColWds	PROC		EXPORT			;Using	S_CurrentData			;Using	S_FileIOData			local	Size:w,Ptr:l,WdArray:l			error	ErrFlag			BEGIN			stz		ErrFlag			MoveLong	S_FilePtr,Ptr			lda		[Ptr]			sta		Size			beq		wrapUp			ldy			#0			H_NewBlock	ay,S_CurColumnWds,WdArray,err=ErrFlag			bcs			Exit			lda		#2			AddLong	a,Ptr,s			in		WdArray:l,#0:w,Size:w			XTool	_BlockMovewrapUp			inc		Size			inc		Size			lda		Size			AddLong	a,S_FilePtr,S_FilePtr			AddWord	Size,S_UsedBufferSize,S_UsedBufferSizeExit			RETURN			ENDP;---------------------------------------------------------------------------;;S_SaveColWds	PROC		EXPORT			;Using	S_CurrentData			;Using	S_FileIOData			local	Size:w,Ptr:l,WdArray:l			error	ErrFlag			BEGIN			stz		ErrFlag			MoveLong	S_FilePtr,Ptr			lda		S_CurColumnWds			ora		S_CurColumnWds+2			bne		customized			stz		Size			bra		wrapUpcustomized			MoveWord	#S_ColWdStructSize,Size			H_GetBlockPtr	S_CurColumnWds,WdArray			PushLong	WdArray			lda		#2			AddLong	a,Ptr,s			PushWord	#0			PushWord	Size			Tool		_BlockMove,in=(:l,:l,:l)wrapUp			MoveWord	Size,[Ptr]			inc		Size			inc		Size			lda		Size			AddLong	a,S_FilePtr,S_FilePtr			AddWord	Size,S_UsedBufferSize,S_UsedBufferSizeExit			RETURN			ENDP;---------------------------------------------------------------------------;;S_LoadRecalculateList	PROC		EXPORT					;Using	S_CurrentData					;Using	S_FileIOData			local	Ptr:l			error	ErrFlag			BEGIN			stz		ErrFlag			bra		chkEndloop			Call		S_ReadInMore,err=ErrFlag			bcs		ExitsetChanged			MoveLong	S_FilePtr,Ptr			Call		S_AddCellToChangedList,in=([Ptr]:l)			AddLong	#4,Ptr,S_FilePtr			AddWord	#4,S_UsedBufferSize,S_UsedBufferSizechkEnd			CmpWord	S_UsedBufferSize,S_FileBufferSize			bne		loopExit			RETURN			ENDP;---------------------------------------------------------------------------;;S_SaveRecalculateList	PROC		EXPORT			;Using	S_CurrentData			;Using	S_FileIOData			local	Ptr:l,Cell:l,CellPtr:l			error	ErrFlag			BEGIN			stz		ErrFlag			lda		S_CurChangedList			ora		S_CurChangedList+2			beq		Exit			MoveLong	S_CurChangedList,Cellloop			Call		S_WriteOutMore,err=ErrFlag			bcs		ExitsetChanged			MoveLong	S_FilePtr,Ptr			MoveLong	Cell,[Ptr]			AddLong	#4,Ptr,S_FilePtr			AddWord	#4,S_UsedBufferSize,S_UsedBufferSize			in		Cell:l			out		CellPtr:l			XCall	S_GetCellPtr			MoveLong	[CellPtr]:#S_CellNext,CellchkEnd			lda		Cell			and		Cell+2			cmp		#-1					; CmpLong Cell,#S_EndOfList			bne		loopExit			RETURN			ENDP;---------------------------------------------------------------------------;;S_LoadCellsIntoSheet	PROC		EXPORT					;Using	S_CurrentData					;Using	S_FileIOData					;Using	SANEequs			local	Ptr:l,CellSize:w,CellsLimit:l,CurCellOffset:l			local	ValueSize:l,ContentStart:l,ContentSize:l			local	Cell:l,Format:l,TypeCell:w,ContentIndex:l			local	ContentPtr:l,CellIndex:l,CellPtr:l			error	ErrFlag			BEGIN			stz		ErrFlag			MoveLong	S_FilePtr,Ptr;		MoveWord	[Ptr]:#S_FileRows,FileBottom;		MoveWord	[Ptr]:#S_FileCols,FileRight			MoveLong	[Ptr]:#S_FileSheetSize,CellsLimit			AddWord	#S_FileSheet,S_UsedBufferSize,S_UsedBufferSize			AddLong	#S_FileSheet,S_FilePtr,S_FilePtr			MoveWord	#S_FileSheet,CurCellOffset			stz		CurCellOffset+2			stz		ValueSize+2			stz		ContentStart+2			stz		ContentSize+2			CmpLong	CurCellOffset,CellsLimit			bge		exitBranch2pasteLoop			Call		D_BeachBall			Call		S_ReadInMore,err=ErrFlag			bcc		loadCellexitBranch2			brl		ExitloadCell			MoveLong	S_FilePtr,Ptr	;	Figure cell location	;			MoveLong	[Ptr]:#S_FileCellLoc,Cell	;	Get the content of the cell	;			MoveWord	[Ptr]:#S_FileValueSize,a			and		#$00FF			sta		ValueSize			AddWord	a,#S_FileValue,ContentStart			MoveWord	[Ptr]:#S_FileCellSize,CellSize			SubWord	a,ContentStart,ContentSize	;	Get the format and type of the cell	;			MoveLong	[Ptr]:#S_FileFormat,Format			MoveWord	Format,a			and		#S_CellType			sta		TypeCell	;	Get the content of the cell	;			cmp		#S_CellTypeValue			bne		getContent			stz		ContentIndex			stz		ContentIndex+2			bra		createCellgetContent			H_NewBlock	ContentSize,ContentIndex,ContentPtr,err=ErrFlag			bcs			exitBranch			AddLong	Ptr,ContentStart,s			PushLong	ContentPtr			PushLong	ContentSize			Tool		_BlockMove	;	Get a New cell	;createCell			in		Cell:l,Format:l,ContentIndex:l			out		ax:l,ax:l			XCall	S_AcceptCell,err=ErrFlag			bcc		storeLastValexitBranch			brl		Exit	;	Store the last calculated value	;storeLastVal			in		Cell:l			out		CellIndex:l			XCall	S_GetCellIndex			H_GetBlockPtr	CellIndex,CellPtr			lda		TypeCell			and		#S_CellTypeValue			beq		textInValue	;	Store last calculated numeric value	;			AddLong	Ptr,#S_FileValue,s			AddLong	CellPtr,#S_CellValue,s			Tool		FX2X,in=(:l,:l)			brl		wrapUp	;	Value is text.	;textInValue			lda		TypeCell			jeq		setValue				;type = Text			AddWord	ValueSize,#1,ValueSize			H_NewBlock	ValueSize,ContentIndex,ContentPtr,err=ErrFlag			bcc			gotSpace	;	Remove the created cell, first change it to type value formula			H_GetBlockPtr	CellIndex,CellPtr			MoveWord	[CellPtr]:#S_CellFormat,a			and		#$FFFF-S_CellType			ora		#S_CellTypeFormula			sta		[CellPtr],y			Call		S_RemoveCell,in=(Cell:l)			brl		ExitgotSpace			AddLong	Ptr,#S_FileValueSize,s			PushLong	ContentPtr			PushLong	ValueSize			Tool		_BlockMove			H_GetBlockPtr	CellIndex,CellPtrsetValue			MoveLong	ContentIndex,[CellPtr]:#S_CellValuewrapUp			AddWord	CellSize,S_UsedBufferSize,S_UsedBufferSize			lda		CellSize			AddLong	a,S_FilePtr,S_FilePtr			lda		CellSize			AddLong	a,CurCellOffset,CurCellOffset			CmpLong	CurCellOffset,CellsLimit			jlt		pasteLoopExit			RETURN			ENDP;---------------------------------------------------------------------------;;S_SaveCellsFromSheet	PROC		EXPORT					;Using	S_CurrentData					;Using	S_FileIOData			local	Ptr:l			output	SheetSizeMark:l			BEGIN			AddWord	#S_FileSheetSize,S_UsedBufferSize,a			AddLong	a,S_FileSize,SheetSizeMark			MoveLong	S_FilePtr,Ptr			MoveWord	S_CurBRMost,[Ptr]:#S_FileRows			MoveWord	S_CurBRMost+2,[Ptr]:#S_FileCols			stz		S_SheetSizeAcc+2			MoveWord	#S_FileSheet,S_SheetSizeAcc			MoveWord	a,[Ptr]:#S_FileSheetSize			MoveWord	#0,[Ptr]:#S_FileSheetSize+2			AddWord	#S_FileSheet,S_UsedBufferSize,S_UsedBufferSize			lda		#S_FileSheet			AddLong	a,S_FilePtr,S_FilePtr			in		#$10001:l,S_CurBRMost:l,#S_GetFileCell:l			XCall	S_QTraverse			RETURN	a			ENDP;---------------------------------------------------------------------------; S_GetFileCell;S_GetFileCell	PROC		EXPORT			;Using	S_CurrentData			;Using	S_FileIOData			;Using	SANEequs			input	Cell:l,CellIndex:l			local	Buffer:l,ContentSize:l,CellSize:w			local	CellPtr:l,ContentPtr:l,Format:l			error	ErrorFlag			BEGIN			stz		ErrorFlag			Call		S_WriteOutMore,err=ErrorFlag			jcs		ExitbufferOK			H_GetBlockPtr	CellIndex,CellPtr			MoveLong	[CellPtr]:#S_CellFormat,Format			lda		Format			jmi		Exit			MoveLong	S_FilePtr,Buffer	;	Store the location	;			MoveLong	Cell,[Buffer]:#S_FileCellLoc	;	Store the format information	;			MoveLong	Format,[Buffer]:#S_FileFormat			MoveWord	#S_FileValueSize,CellSize	;	Store the last calculated value	;			lda		Format			and		#S_CellTypeValue			jne		getSane			CmpLong	[CellPtr]:#S_CellValue,[CellPtr]:#S_CellContent			bne		getString			MoveWord	#0,[Buffer]:#S_FileValueSize			inc		CellSize			brl		getContentgetString			H_GetBlockPtr	[CellPtr]:#S_CellValue,ContentPtr			lda		[ContentPtr]			and		#$00FF			inc		a			sta		ContentSize			stz		ContentSize+2			PushLong	ContentPtr			AddLong	Buffer,#S_FileValueSize,s			PushLong	ContentSize			Tool		_BlockMove			AddWord	ContentSize,CellSize,CellSize			bra		getContentgetSane			MoveWord	#10,[Buffer]:#S_FileValueSize			AddLong	CellPtr,#S_CellValue,s			AddLong	Buffer,#S_FileValue,s			Tool		FX2X,in=(:l,:l)			AddWord	#11,CellSize,CellSize	;	Store the content of the cell	;getContent			H_GetBlockSize	[CellPtr]:#S_CellContent,ContentSize			lda		ContentSize+2			ora		ContentSize			beq		storeSize			H_GetBlockPtr	[CellPtr]:#S_CellContent,ContentPtr			PushLong	ContentPtr			lda		CellSize			AddLong	a,Buffer,s			PushLong	ContentSize			Tool		_BlockMove	;	Store the cell size	;storeSize			AddWord	CellSize,ContentSize,CellSize			MoveWord	a,[Buffer]:#S_FileCellSize			AddWord	a,S_UsedBufferSize,S_UsedBufferSize			lda		CellSize			AddLong	a,S_FilePtr,S_FilePtr			lda		CellSize			AddLong	a,S_SheetSizeAcc,S_SheetSizeAccExit			RETURN			ENDP;-----------------------------------------------------------------------------;;S_SaveCellAscii	PROC		EXPORT				;Using	S_CurrentData				;Using	D_IOData			input	Cell:l,CellIndex:l			local	CellPtr:l,Format:w,ContentPtr:l			error	ErrorFlag			BEGIN			stz		ErrorFlag			H_GetBlockPtr	CellIndex,CellPtr			MoveWord	[CellPtr]:#S_CellFormat,Format			jmi		Exit			H_GetBlockPtr	[CellPtr]:#S_CellContent,ContentPtr			lda		ContentPtr+2			ora		ContentPtr			bne		chkForm			SpaceWord							; pixel length			SpaceLong							; string ptr			SpaceWord							; color			PushWord	#$7FFF			PushLong	#$000F2000			AddLong	CellPtr,#S_CellValue,s			Call		X_FormatValue			pla			PullLong	ContentPtr			pla			beq		chkRowchkForm			lda		Format			and		#S_CellTypeTextForm			; test for all formulas			beq		chkRowdoFormula			in		Cell:l,ContentPtr:l			out		ContentPtr:l			XCall	E_ExpandFormulachkRow			CmpWord	S_SaveAsciiRow,Cell			beq		chkColcrLoop			Call		D_Write2,in=(S_FileID:w,#crChar:l,#1:l),out=(ax:l),err=ErrorFlag			bcs		Exit			inc		S_SaveAsciiRow			CmpWord	S_SaveAsciiRow,Cell			blt		crLoop			MoveWord	#1,S_SaveAsciiColchkCol			CmpWord	S_SaveAsciiCol,Cell+2			beq		writeStringtabLoop			Call		D_Write2,in=(S_FileID:w,#tabchar:l,#1:l),out=(ax:l),err=ErrorFlag			bcs		Exit			inc		S_SaveAsciiCol			CmpWord	S_SaveAsciiCol,Cell+2			blt		tabLoopwriteString			SpaceLong			PushWord	S_FileID			AddLong	ContentPtr,#1,s			PushWord	#0			lda		[ContentPtr]			and		#$00FF			pha			Call		D_Write2,err=ErrorFlag		; ,in=(:w,:l,:l),out=(:l)			pla			plaExit			RETURNtabchar		DC.W		9crchar		DC.W		13		EXPORT	S_SaveAsciiCellS_SaveAsciiCellS_SaveAsciiRow		DS.W		1S_SaveAsciiCol		DS.W		1			ENDP			END