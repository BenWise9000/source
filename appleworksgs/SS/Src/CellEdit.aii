		LOAD		'Macros.dump'		INCLUDE	'M16.Profile'		INCLUDE	'SS.equ'		INCLUDE	'Driver.equ'		INCLUDE	'Heap.aii.i'		INCLUDE	'Eval.aii.i';-----------------------------------------------;;	Imported addresses;;-----------------------------------------------		IMPORT	D_AlertBox		IMPORT	D_MemoryError		IMPORT	X_FormatValue		IMPORT	S_AddCellToChangedList		IMPORT	S_BuildSimpleUndo		IMPORT	S_CalculateCell		IMPORT	S_CalculateSheet		IMPORT	S_CellWidth		IMPORT	S_ChkCellProtect		IMPORT	S_CurBRSelect		IMPORT	S_CurBScrl		IMPORT	S_CurContHt		IMPORT	S_CurContRect		IMPORT	S_CurContWd		IMPORT	S_CurContXpt		IMPORT	S_CurContYpt		IMPORT	S_CurEditFlag		IMPORT	S_CurEditRect		IMPORT	S_CurFormat		IMPORT	S_CurHeap		IMPORT	S_CurLEHandle		IMPORT	S_CurRScrl		IMPORT	S_CurTLSelect		IMPORT	S_FindLeftContent		IMPORT	S_FindRightContent		IMPORT	S_GetCellIndex		IMPORT	S_GetCellPtr		IMPORT	S_HiliteCells		IMPORT	S_InsertDependency		IMPORT	S_InsertLeftPadCells		IMPORT	S_InsertRightPadCells		IMPORT	S_LoadingFile		IMPORT	S_NewCell		IMPORT	S_ProtectedCellMsg		IMPORT	S_RedrawCellRange		IMPORT	S_RemoveCell		IMPORT	S_RemovePadCells		IMPORT	S_SetCircularBits		IMPORT	S_SetUndoOn		IMPORT	S_Thumb		IMPORT	S_UpdatePriorities		IMPORT	S_WhereCell;-----------------------------------------------;;	Forward addresses and entries;;-----------------------------------------------		ENTRY	S_AcceptCell		ENTRY	S_DrawLEText		ENTRY	S_ParseText		ENTRY	S_RearrangePadCells;-------------------------------------------------------------------------;; S_NewLineEdit ( CellIndex:l );;	S_NewLineEdit is called to setup a New line edit entry in the entry bar.; CellIndex is an index to the cell which will appear in the line edit.S_NewLineEdit	PROC		EXPORT			;Using	S_CurrentData			input	CellIndex:l			local	CellType:w,ContentIndex:l,CellPtr:l,StringPtr:l			BEGIN	; If CellIndex is not NIL then get the content as the	; default value for line edit.			lda		CellIndex			ora		CellIndex+2			bne		getdefaultsetempty		ldx		#0			brl		setTextgetdefault			H_GetBlockPtr	CellIndex,CellPtr			MoveLong	[CellPtr]:#S_CellContent,ContentIndex			MoveWord	[CellPtr]:#S_CellFormat,a			and		#S_CellType			sta		CellType			bmi		setempty			and		#S_CellTypeTextForm			beq		notFormula			H_GetBlockPtr	ContentIndex,StringPtr			in		S_CurTLSelect:l,StringPtr:l			out		StringPtr:l			XCall	E_ExpandFormula			bra		adjustString2notText			SpaceWord							; string length			SpaceLong							; string ptr			SpaceWord							; color			PushWord	#$7FFF			PushLong	#$000F2000			AddLong	CellPtr,#S_CellValue,s			Call		X_FormatValue			pla			PullLong	StringPtr			pla			bra		adjustString2notFormula			lda		CellType			bne		notText			H_GetBlockPtr	ContentIndex,StringPtr			lda		[StringPtr]			and		#$FF00				; 'A'			cmp		#$4100			blt		adjustString1			cmp		#$5B00				; 'Z' + 1			blt		adjustString2			cmp		#$6100				; 'a'			blt		adjustString1			cmp		#$7B00				; 'z' + 1			bge		adjustString1adjustString2			lda		[StringPtr]			and		#$00FF			tax			incl		StringPtrsetText			Tool		_LESetText,in=(StringPtr:l,x:w,S_CurLEHandle:l)			bra		doDrawadjustString1			lda		[StringPtr]			and		#$00FF			inc		a			tax			lda		[StringPtr]			pha			and		#$FF00			ora		#$0027			sta		[StringPtr]			Tool		_LESetText,in=(StringPtr:l,x:w,S_CurLEHandle:l)			H_GetBlockPtr	ContentIndex,StringPtr			PullWord	[StringPtr]	; Display the line edit string in the entry bar, but first make	; sure that the line edit field has been deactivated ( ie get	; rid of any Cursor in the entry bar).doDraw			Tool		_LEDeactivate,in=(S_CurLEHandle:l)			Call		S_DrawLEText			RETURNQuotePtr		DC.B		$27				; hex for single quote			ENDP;----------------------------------------------------------------------------;;S_SetCaret	PROC		EXPORT			;Using	S_CurrentData			input	location:w			BEGIN			Tool		_LEActivate,in=(S_CurLEHandle:l);			Tool		_EraseRect,in=(#S_CurEditRect:l);			Tool		_LEUpdate,in=(S_CurLEHandle:l)			in		location:w,location:w,S_CurLEHandle:l			XTool	_LESetSelect			RETURN			ENDP;-------------------------------------------------------------------------;; S_EndEdit ( Accept:w );;	S_EndEdit is called whenever editing in the LineEdit is to stop. If; accept is TRUE (non-zero) then the contents of the LineEdit string will; be copied into a cell structure for the selected cell.	The line edit will be; deactivated and the EditingBit of S_EditFlag will be cleared.; Note: The line edit is still displayed and its text handle still; contains the text - it has simply been deactivated; to clear the line; edit and the entrybar S_ClearLineEdit must be called.S_EndEdit		PROC		EXPORT			;Using	S_CurrentData			;Using	S_ErrorData			;Using	SANEequs			input	Accept:w			local	Size:w,TextPtr:l,TextHandle:l			local	Cell:l,CellPtr:l,CellIndex:l,ValuePtr:l			local	LCell:l,RCell:l			local	TypeCell:w,ContentIndex:l			error	ErrorFlag			BEGIN			stz		ErrorFlag			MoveLong	S_CurTLSelect,Cell	; Deactivate LineEdit and check if accept flag is false			Tool		_LEDeactivate,in=(S_CurLEHandle:l)			lda		Accept			bne		doAccept			in		Cell:l			out		:l			XCall	S_GetCellIndex			Call		S_NewLineEdit,in=(:l)			brl		ExitdoAccept			Call		S_GetCellIndex,in=(Cell:l),out=(CellIndex:l)			ora		CellIndex			beq		buildUndo			in		Cell:l,CellIndex:l			XCall	S_ChkCellProtect			bcc		buildUndo			lda		S_CurFormat+2			and		#S_CellProtect			beq		buildUndo			Call		D_AlertBox,in=(#OkBox:w,#S_ProtectedCellMsg:l),out=(a:w)			brl		ExitbuildUndo			in		S_CurTLSelect:l,S_CurTLSelect:l			XCall	S_BuildSimpleUndo,err=ErrorFlag			jcs		doMemError			Tool		_LEGetTextLen,in=(S_CurLEHandle:l),out=(Size:w)			bne		hasContents			MoveWord	#S_CellTypeEmpty,TypeCell;			stz		ContentIndex;			stz		ContentIndex+2			bra		AcceptCellhasContents			Tool		_LEGetTextHand,in=(S_CurLEHandle:l),out=(TextHandle:l)			in		S_CurTLSelect:l,TextHandle:l,#0:l,Size:w,#DRec:l,#0:w			out		TypeCell:w,ContentIndex:l			XCall	S_ParseText,err=ErrorFlag			bcc		AcceptCell			lda		ErrorFlag			and		#$FF00			bne		doMemError			Call		S_SetCaret,in=(ErrorFlag:w)			bra		finishErrordoMemError			Call		D_MemoryErrorfinishError			brl		ExitAcceptCell			SpaceLong			SpaceLong			PushLong	Cell			lda		S_CurFormat+2			and		#-1-S_CellCircular			pha			lda		S_CurFormat			and		#$FFFF-S_CellType-S_CellInvalid-S_CellError			ora		TypeCell			pha			PushLong	ContentIndex			Call		S_AcceptCell,err=ErrorFlag			PullLong	RCell			PullLong	LCell			bcc		chkContent			Call		D_MemoryError			brl		redrawRangechkContent			lda		TypeCell			bmi		DrawCells			cmp		#S_CellTypeValue			beq		handleValue			cmp		#S_CellTypeFormula			bne		doJumphandleFormula			lda		S_CurEditFlag			and		#S_ManCalcBit			beq		doJump			Call		S_CalculateCell,in=(Cell:l),err=ErrorFlagdoJump			brl		DrawCellshandleValue			in		Cell:l			out		CellPtr:l			XCall	S_GetCellPtr			AddLong	CellPtr,#S_CellValue,ValuePtr			Tool		FDEC2X,in=(#DRec:l,ValuePtr:l)			Tool		FCLASSX,in=(ValuePtr:l)			cpx		#$80FF			bne		DrawCells			Tool		FNEGX,in=(ValuePtr:l)	;	Draw the affected cells	;DrawCells			in		Cell:l			out		:l			XCall	S_GetCellIndex			Call		S_NewLineEdit,in=(:l)redrawRange			Call		S_RedrawCellRange,in=(LCell:l,RCell:l)			Call		S_AddCellToChangedList,in=(Cell:l)			Call		S_SetUndoOn,in=(#S_UndoEntryType:w)			lda		S_CurEditFlag			and		#S_ManCalcBit			bne		Exit			Call		S_CalculateSheet,err=ErrorFlagExit			RETURNDRec			DS.B 	33SaneZero		DC.W		0,0,0,0,0			ENDP; ¥¥¥ Dead Code;;		;-------------------------------------------------------------------------;;		; S_ClearLineEdit ( );		;;		;;		;		S_ClearLineEdit	PROC		EXPORT;						;Using	S_CurrentData;		;					BEGIN;		;			; Clear the LineEdit text and redisplay.;		;					Tool		_LESetText,in=(#0:l,#0:w,S_CurLEHandle:l);					Call		S_DrawLEText;		;					RETURN;					ENDP	;-------------------------------------------------------------------------;; S_DrawLEText ( );;	S_DrawLEText will call S_DrawEntryBar with the clip set so that only; the text string itself is redrawn.S_DrawLEText	PROC		EXPORT			;Using	S_CurrentData			BEGIN			Tool		_NewRgn,out=(:l)			PushLong	1:s			Tool		_GetClip,in=(:l)			Tool		_ClipRect,in=(#S_CurEditRect:l)			Tool		_EraseRect,in=(#S_CurEditRect:l)			Tool		_LEUpdate,in=(S_CurLEHandle:l)			PushLong	1:s			Tool		_SetClip,in=(:l)			Tool		_DisposeRgn,in=(:l)			RETURN			ENDP;-----------------------------------------------------------------------------;	ParseText(Cell:l,TextHandle:l,Offset:l,TextSize:w,DecRecPtr:l):;									 CellType:w,ContentIndex:l;; ParseCode <> 0 means to make parse error cells as text type.S_ParseText	PROC		EXPORT			;Using	S_CurrentData			input	Cell:l,TextHandle:l,Offset:l,TextSize:w			input	DecRecPtr:l,ParseCode:w			output	CellType:w,ContentIndex:l			local	TextPtr:l,StringPtr:l,Size:l			error	ErrorFlag			BEGIN			stz		ErrorFlag			lda		TextSize			AddWord	a,#1,Size			stz		Size+2			AddLong	[TextHandle],Offset,TextPtr			lda		[TextPtr]			and		#$00FF			cmp		#'¹'			beq		doNum			cmp		#'°'			beq		doNum			cmp		#'¸'			beq		doNum			cmp		#'='			beq		doFormula			jge		doText			cmp		#$27				; '			jeq		doQuote			cmp		#$22				; "			jeq		doQuote			cmp		#'-'			beq		doNum			cmp		#'.'			beq		doNum			cmp		#'+'			beq		doNum			cmp		#'$'			beq		doNum			cmp		#'0'			blt		doText			cmp		#'9'+1			bge		doTextdoNum			Call		E_ParseNumber,in=(TextPtr:l,TextSize:w,DecRecPtr:l)			bcs		doText			MoveWord	#S_CellTypeValue,CellType			stz		ContentIndex			stz		ContentIndex+2			brl		ExitdoFormula			MoveWord	#S_CellTypeFormula,CellType			in		TextPtr:l,TextSize:w,Cell:l,ParseCode:w			out		ContentIndex:l			XCall	E_ParseFormula,err=ErrorFlag			jcc		Exit			lda		ErrorFlag				; if tool (memory) error			and		#$FF00				; exit anyway			jne		Exit			lda		ParseCode			jeq		Exit			stz		ErrorFlag			bra		doTextdoQuote			Moveword	#S_CellTypeText,CellType			IncL		Offset			dec		TextSize			dec		Size			bra		copyStringdoText			Moveword	#S_CellTypeText,CellTypecopyString			H_NewBlock	Size,ContentIndex,StringPtr,err=ErrorFlag			bcs			Exit	; Copy LineEdit text to Cell structure with length byte to form	; proper pascal string.	;	Copy String	;			MoveWord	TextSize,[StringPtr]			incl		StringPtr			AddLong	[TextHandle],Offset,s			PushLong	StringPtr			PushWord	#0			PushWord	TextSize			Tool		_BlockMove,in=(:l,:l,:l)Exit			RETURN			ENDP;-----------------------------------------------------------------------------; S_NewEditCell(Cell:l);S_NewEditCell	PROC		EXPORT			;Using	S_CurrentData			input	Cell:l			local	CellPtr:l,Value:w,Width:w			local	OldClipRgn:l,Col:w,ErrorFlag:w			BEGIN	;	The old Cell needs to be accepted, if edited.	;			lda		S_CurEditFlag			and		#S_EditingBit			beq		ChkBump			Call		S_EndEdit,in=(#-1:w),err=ErrorFlag			jcs		ExitclrEdit			lda		S_CurEditFlag			and		#-1-S_EditingBit			sta		S_CurEditFlag	;	Bump the window until the New cell is completely in view	;ChkBump			Call		S_WhereCell,in=(Cell:l),out=(:w,:w,:w,:w)			pla			jeq		bumpDown			cmp		S_CurContHt			jge		bumpUp			pla			jeq		bumpRight			cmp		S_CurContWd			jge		bumpLeft			pla			pla	;	The Cell is completely in view	;			Tool		_NewRgn,out=(:l)			MoveLong	1:s,OldClipRgn			Tool		_GetClip,in=(:l)			Tool		_ClipRect,in=(#S_CurContRect:l)			Call		S_HiliteCells			MoveWord	Cell,S_CurTLSelect			sta		S_CurBRSelect			MoveWord	Cell+2,S_CurTLSelect+2			sta		S_CurBRSelect+2			Call		S_HiliteCells			Tool		_SetClip,in=(OldClipRgn:l)			Tool		_DisposeRgn,in=(OldClipRgn:l)	;	The New cell needs to be displayed in the LE field.	;			in		Cell:l			out		:l			XCall	S_GetCellIndex			Call		S_NewLineEdit,in=(:l)Exit			RETURN;----------------------------bumpLeft			pla			pla			lda		Cell+2			sta		Col			dec		a			sta		Value			MoveWord	S_CurContXpt,WidthleftLoop			dec		Col			Call		S_CellWidth,in=(Col:w),out=(a:w)			AddWord	a,Width,Width			cmp		S_CurContWd			bge		BumpH			dec		Value			bra		leftLoopbumpRight			pla			pla			lda		Cell+2			dec		a			sta		ValueBumpH			Tool		_SetCtlValue,in=(Value:w,S_CurBScrl:l)			Call		S_Thumb,in=(S_CurBScrl:l)			brl		ChkBump;----------------------------bumpUp			pla			pla			pla			lda		Cell			dec		a			sta		Value			lda		S_CurContYptupLoop			AddWord	a,#S_RowHeight,a			cmp		S_CurContHt			bge		BumpV			dec		Value			bra		upLoopbumpDown			pla			pla			pla			lda		Cell			dec		a			sta		ValueBumpV			Tool		_SetCtlValue,in=(Value:w,S_CurRScrl:l)			Call		S_Thumb,in=(S_CurRScrl:l)			brl		ChkBump			ENDP;-------------------------------------------------------------------------;; S_AcceptCell ( Cell:l,Format:l,ContentIndex:l ): TLCell:l,BRCell:l;;	S_AcceptCell is called whenever a 'user' cell is to be stuck into the; current sheet.	If the cell is to appear empty, then the Cell Type should; be negative.S_AcceptCell	PROC		EXPORT			;Using	S_CurrentData			;Using	S_FileIOData			;Using	SANEequs			input	Cell:l,Format:l,ContentIndex:l			output	LCell:l,RCell:l			local	CellPtr:l,ContCell:l			local	CellIndex:l,TypeCell:w			error	ErrorFlag			BEGIN			stz		ErrorFlag			MoveWord	Cell,LCell			sta		RCell			MoveWord	Cell+2,LCell+2			sta		RCell+2			Call		S_RemoveCell,in=(Cell:l);			lda		ContentIndex			; changed 12/13/88;			ora		ContentIndex+2			; removing numeric text;			jne		hasContents			lda		Format			bpl		hasContents			in		Cell:l			out		LCell:l,RCell:l			XCall	S_RearrangePadCells,err=ErrorFlag			brl		Exit		; Get New Cell StructurehasContents;			lda		Format			and		#S_CellType			sta		TypeCell			in		Cell:l,TypeCell:w,Format:l,ContentIndex:l			out		CellIndex:l,CellPtr:l			XCall	S_NewCell,err=ErrorFlag			jcs		Exit			in		Cell:l			out		LCell:l,RCell:l			XCall	S_RemovePadCells,err=ErrorFlag			jcs		Exit			lda		TypeCell			and		#S_CellTypeTextForm			bne		handleFormula			lda		TypeCell			cmp		#S_CellTypeText			jne		Exit	;	Set up pad cells if needed	;handleText			in		Cell:l			out		CellPtr:l			XCall	S_GetCellPtr			MoveLong	ContentIndex,[CellPtr]:#S_CellValue			in		Cell:l			out		ax:l			XCall	S_InsertRightPadCells,err=ErrorFlag			bcs		memError			cpx		RCell+2			blt		chkRight2			stx		RCell+2chkRight2			in		Cell:l			out		ax:l			XCall	S_InsertLeftPadCells,err=ErrorFlag			bcs		memError			cpx		LCell+2			bge		Exit			stx		LCell+2			bra		ExithandleFormula			in		Cell:l,ContentIndex:l			XCall	S_InsertDependency,err=ErrorFlag			bcs		memError			lda		S_LoadingFile			bne		doPriorities			Call		S_SetCircularBits,in=(Cell:l)doPriorities			Call		S_UpdatePriorities,in=(Cell:l)			bra		ExitmemError			Call		S_RemoveCell,in=(Cell:l)Exit			RETURN			ENDP;----------------------------------------------------------------------------;;S_RearrangePadCells	PROC		EXPORT			input	Cell:l			output	LCell:l,RCell:l			local	CellPtr:l,ContCell:l			error	ErrFlag			BEGIN	ProfileIn		10			stz		ErrFlag			in		Cell:l			out		LCell:l,RCell:l			XCall	S_RemovePadCells,err=ErrFlag			jcs		ExitchkLeftSide			lda		LCell+2			dec		a			tax			beq		chkRightSide			in		x:w,LCell:w			out		CellPtr:l			XCall	S_GetCellPtr			ora		CellPtr			jeq		chkRightSide			MoveWord	[CellPtr]:#S_CellFormat,a			and		#S_CellType			bpl		goRight			cmp		#S_CellTypeRightPad			bne		chkRightSidegoRight			in		LCell:l			out		ContCell:l,a:w			XCall	S_FindLeftContent			in		ContCell:l			out		ax:l			XCall	S_InsertRightPadCells,err=ErrFlag			cpx		RCell+2			blt		chkRightSide			stx		RCell+2			brl		ExitchkRightSide			lda		ErrFlag			bne		Exit			lda		RCell+2			inc		a			tax			cmp		#$02BF			jge		Exit			in		x:w,RCell:w			out		CellPtr:l			XCall	S_GetCellPtr			ora		CellPtr			jeq		Exit			MoveWord	[CellPtr]:#S_CellFormat,a			and		#S_CellType			bpl		goLeft			cmp		#S_CellTypeRightPad			jne		ExitgoLeft			in		RCell:l			out		ContCell:l,a:w			XCall	S_FindRightContent			in		ContCell:l			out		ax:l			XCall	S_InsertLeftPadCells,err=ErrFlag			cpx		LCell+2			bge		Exit			stx		LCell+2Exit	ProfileOut	10			RETURN			ENDP			END