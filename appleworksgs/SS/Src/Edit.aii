		LOAD		'Macros.dump'		INCLUDE	'SS.equ'		INCLUDE	'Driver.equ'		INCLUDE	':::Scrap:Scrap.equ'		INCLUDE	'Heap.aii.i'		INCLUDE	'Eval.aii.i';-----------------------------------------------;;	Imported addresses;;-----------------------------------------------		IMPORT	D_AlertBox		IMPORT	D_BeachBall		IMPORT	D_BitMapChanged		IMPORT	D_BitMapPtr		IMPORT	D_GrowHandle		IMPORT	D_MemoryError		IMPORT	D_NeedHand		IMPORT	D_SetFileChanged		IMPORT	D_SetUndoStr		IMPORT	X_DialogFromScrap		IMPORT	X_DisposeScrap		IMPORT	X_PostScrap		IMPORT	S_AcceptCell		IMPORT	S_ActiveWindow		IMPORT	S_AddCellToChangedList		IMPORT	S_BadPasteMsg		IMPORT	S_BuildSimpleUndo		IMPORT	S_CalculateSheet		IMPORT	S_CellWidth		IMPORT	S_ChkCellProtect		IMPORT	S_CurBRSelect		IMPORT	S_CurContHt		IMPORT	S_CurContWd		IMPORT	S_CurContXpt		IMPORT	S_CurContYpt		IMPORT	S_CurDefFormat		IMPORT	S_CurEditFlag		IMPORT	S_CurEditRect		IMPORT	S_CurHeap		IMPORT	S_CurLEHandle		IMPORT	S_CurTLSelect		IMPORT	S_CurWindow		IMPORT	S_ErrorFormula		IMPORT	S_ErrorFormulaLength		IMPORT	S_ExtraData		IMPORT	S_ExtraDataMsg		IMPORT	S_FixLE		IMPORT	S_GetCellIndex		IMPORT	S_GetRealCell		IMPORT	S_INFFormula		IMPORT	S_INFFormulaLength		IMPORT	S_NAFormula		IMPORT	S_NAFormulaLength		IMPORT	S_NegINFFormula		IMPORT	S_NegINFFormulaLength		IMPORT	S_NewLineEdit		IMPORT	S_ParseText		IMPORT	S_ProtectedCell		IMPORT	S_ProtectedCellMsg		IMPORT	S_QTraverse		IMPORT	S_RedrawCellRange		IMPORT	S_RemoveCell		IMPORT	S_SetUndoOn		IMPORT	S_SwapIn		IMPORT	S_SwapOut		IMPORT	S_UndoHandle		IMPORT	S_UndoNames		IMPORT	S_UndoType		IMPORT	S_WhichCell;-----------------------------------------------;;	Forward addresses and entries;;-----------------------------------------------		ENTRY	S_AddBufferToScrap		ENTRY	S_CheckFormula		ENTRY	S_ClearCell		ENTRY	S_CopyFrame		ENTRY	S_CopyRect		ENTRY	S_GetSSScrap		ENTRY	S_Image		ENTRY	S_PutSSScrap		ENTRY	S_ScrapBR		ENTRY	S_ScrapLeft		ENTRY	S_ScrapRight		ENTRY	S_ScrapTL		ENTRY	S_SetImage;-------------------------------------------------------------------------;; S_Clear;;	S_Clear will clear the currently selected item(s) from the active; document.S_Clear		PROC		EXPORT			;Using	S_ScrapData			;Using	S_CurrentData			;Using	S_ProtectData			;Using	S_ErrorData			error	ErrFlag			BEGIN	+b			stz		ErrFlag			Call		S_SwapIn,in=(S_ActiveWindow:l)			lda		S_CurEditFlag			and		#S_EditingBit			beq		notLE			Tool		_LEDelete,in=(S_CurLEHandle:l)			brl		ExitnotLE			in		S_CurTLSelect:l,S_CurBRSelect:l,#S_ChkCellProtect:l			XCall	S_QTraverse			bcc		contClear			Call		D_AlertBox,in=(#OkBox:w,#S_ProtectedCellMsg:l),out=(a:w)			brl		ExitcontClear			MoveLong	S_CurTLSelect,S_ScrapTL			MoveLong	S_CurBRSelect,S_ScrapBR			in		S_CurTLSelect:l,S_CurBRSelect:l			XCall	S_BuildSimpleUndo,err=ErrFlag			bcs		memError			Call		S_QTraverse,in=(S_ScrapTL:l,S_ScrapBR:l,#S_ClearCell:l)			bcc		redrawmemError			Call		D_MemoryErrorredraw			ldx		#0			Call		S_NewLineEdit,in=(x:w,x:w)			in		S_ScrapTL:l,S_ScrapBR:l			XCall	S_RedrawCellRange			Call		S_SetUndoOn,in=(#S_UndoClearType:w)			lda		S_CurEditFlag			and		#S_ManCalcBit			bne		Exit			Call		S_CalculateSheetExit			RETURN			ENDP;-------------------------------------------------------------------------;;S_ClearCell	PROC		EXPORT			;Using	S_ScrapData			input	Cell:l,CellIndex:l			error	ErrorFlag			BEGIN	;	Note: cells will be added to ChangedList in S_RemoveCell	;	Another Note:	There is no need to execute this code on pad or empty	;				cells.  Put in branch around in that case.			ldx		#S_CellTypeEmpty			in		Cell:l,x:w,x:w,x:w,x:w			out		:l,:l			XCall	S_AcceptCell,err=ErrorFlagfixLRCells			pla			pla			cmp		S_ScrapRight			blt		OKright			sta		S_ScrapRightOKright			pla			pla			cmp		S_ScrapLeft			bge		Exit			sta		S_ScrapLeftExit			RETURN			ENDP;-------------------------------------------------------------------------;; S_Copy (Window:l): ImageRoutine:l, Type:w, Scrap:l;;	S_Copy will perform a copy of the currently selected item(s) in the given; document.  The output routine draws an image of the scrap for dragging and; is defined:;;	ImageRoutine(where:L) - draws the shape at where;; The routine should use the current port and penmode (don't change either).; Pass back a 0 type for no scrap.S_Copy		PROC		EXPORT			;Using	S_CurrentData			;Using	X_ClipData			input	Window:l			output	ImageRoutine:l,SType:w,ScrapHandle:l			local	ScrapLen:l,LEScrapHandle:l			error	ErrorFlag			BEGIN	+b			stz		ErrorFlag			Call		S_SwapIn,in=(Window:l)			MoveWord	#0,SType			Call		S_SetImage,in=(S_CurTLSelect:l,S_CurBRSelect:l)			MoveLong	#S_Image,ImageRoutine			lda		S_CurEditFlag			and		#S_EditingBit			beq		notLE			Tool		_LECopy,in=(S_CurLEHandle:l),err=ErrorFlag			jcs		Exit			Tool		_LEGetScrapLen,out=(a:w)			beq		Exit			sta		ScrapLen			stz		ScrapLen+2			in		ScrapLen:l			out		ScrapHandle:l			XCall	D_NeedHand,err=ErrorFlag			bcs		Exit			Tool		_LEScrapHandle,out=(LEScrapHandle:l),err=ErrorFlag			in		[LEScrapHandle]:l,[ScrapHandle]:l,ScrapLen:l			XTool	_BlockMove			MoveWord	#AsciiText,SType			bra		ExitnotLE			in		S_CurTLSelect:l,S_CurBRSelect:l			out		ScrapHandle:l			XCall	S_GetSSScrap,err=ErrorFlag			bcs		Exit			MoveWord	#SSScrap,STypeExit			RETURN			ENDP;---------------------------------------------------------------------S_ScrapData	PROC		EXPORT		EXPORT	S_ScrapOrgCell		EXPORT	S_ScrapTL		EXPORT	S_ScrapTop		EXPORT	S_ScrapLeft		EXPORT	S_ScrapBR		EXPORT	S_ScrapBottom		EXPORT	S_ScrapRight		EXPORT	S_ScrapBufferSize		EXPORT	S_ScrapHandleSize		EXPORT	S_ScrapHandle		EXPORT	S_ScrapBuffer		EXPORT	S_ScrapParse		EXPORT	S_ScrapPasteTypeS_ScrapOrgCell		DS.B		4S_ScrapTLS_ScrapTop		DS.B 	2S_ScrapLeft		DS.B 	2S_ScrapBRS_ScrapBottom		DS.B 	2S_ScrapRight		DS.B 	2S_ScrapBufferSize	DS.B 	4S_ScrapHandleSize	DS.B 	4S_ScrapHandle		DS.B 	4S_ScrapBuffer		DS.B 	4S_ScrapParse		DS.B 	2S_ScrapPasteType	DS.B 	2			ENDP;-------------------------------------------------------------------------;; S_Cut (Window:l): ImageRoutine:l;;	S_Cut will perform a cut of the currently selected item(s) in the given; document.	The output routine draws an image of the scrap for dragging and; is defined:;;	ImageRoutine(where:L) - draws the shape at where;; The routine should use the current port and penmode (don't change either).; Pass back a 0 for no scrap.S_Cut		PROC		EXPORT			;Using	S_CurrentData			;Using	S_UndoData			input	Window:l			output	ImageRoutine:l			local	SType:w,ScrapHandle:l			error	ErrFlag			BEGIN	+b			stz		ErrFlag			in		Window:l			out		ImageRoutine:l,SType:w,ScrapHandle:l			XCall	S_Copy,err=ErrFlag			bcs		Exit			lda		SType			beq		Exit			Call		X_PostScrap,in=(SType:w,ScrapHandle:l)			Call		S_Clear,err=ErrFlag	;	some manipulation is needed here to get right undo string			lda		S_UndoHandle			ora		S_UndoHandle+2			beq		Exit			MoveWord	#S_UndoCutType,S_UndoType			asl		a			asl		a			tax			PushLong	S_UndoNames:x			Call		D_SetUndoStr,in=(:l,S_CurWindow:l)Exit			RETURN			ENDP;-------------------------------------------------------------------------;; S_Paste ( Window:l, Scrap:l, Type:w, Paste:w, Where:l);; The input are:;	- Window, which window to paste in, usually the active one;	- Scrap, a handle to the data, dispose of it when you're done;	- Type, the type of scrap that is being passed.;	- Paste, What type	0 - from menu	1-directional (look at where);			2 - from import;	- Where, where paste was if Paste was type 1; Return any memory errors.S_Paste		PROC		EXPORT			;Using	S_ScrapData			;Using	S_CurrentData			;Using	S_ProtectData			;Using	S_ErrorData			;Using	X_ClipData			input	Window:l,Scrap:l,Type:w,Paste:w,Where:l			local	Buffer:l,Rect:r,PasteType:w			local	ContentIndex:l,CellPtr:l			error	ErrorFlag			BEGIN	+b			stz		ErrorFlag			stz		ContentIndex			stz		ContentIndex+2			stz		PasteType			Cmpword	Type,#SSScrap			beq		doSSScrap			inc		ErrorFlag			brl		ExitdoSSScrap			Call		S_SwapIn,in=(Window:l)			MoveLong	Scrap,S_ScrapBuffer			MoveWord	Paste,S_ScrapPasteType			CmpWord	Paste,#1			jne		normal			; menu paste same as import	;	Put directional paste code here	;			MoveWord	S_CurEditFlag,a			and		#S_EditingBit			beq		notLE			Tool		_PtInRect,in=(!Where:l,#S_CurEditRect:l),out=(a:w)			beq		endBranch			Call		X_DialogFromScrap			Tool		_LEPaste,in=(S_CurLEHandle:l)endBranch			brl		ExitnotLE			MoveWord	S_CurContYpt,Rect			MoveWord	S_CurContXpt,Rect+2			MoveWord	S_CurContHt,Rect+4			MoveWord	S_CurContWd,Rect+6			Tool		_PtInRect,in=(!Where:l,!Rect:l),out=(a:w)			beq		endBranch			in		Where:l			out		S_ScrapTL:l,Where:l			XCall	S_WhichCell			bra		fixScrapRange;			CmpWord	S_ScrapTop,#10000;			jge		Exit;;			CmpWord	S_ScrapLeft,#$02BF;			blt		fixScrapRange;			brl		Exit	;	Set up for normal SS scrap	;normal			MoveWord	S_CurEditFlag,a			and		#S_EditingBit			beq		notLE2			Call		X_DialogFromScrap			Tool		_LEPaste,in=(S_CurLEHandle:l)			brl		ExitnotLE2			MoveLong	S_CurTLSelect,S_ScrapTLfixScrapRange			MoveLong	[Scrap],Buffer			AddWord	S_ScrapLeft,[Buffer]:#S_ScrapCols,a			dec		a			sta		S_ScrapRight			cmp		#703			bge		badPaste			AddWord	S_ScrapTop,[Buffer]:#S_ScrapRows,a			dec		a			sta		S_ScrapBottom			cmp		#10000			blt		chkProtectbadPaste			Call		D_AlertBox,in=(#OkBox:w,#S_BadPasteMsg:l),out=(a:w)			brl		ExitchkProtect;			Call		D_SetCursor,in=(#WatchCursor:w)			stz		S_ProtectedCell			stz		S_ExtraData;			PushLong	S_ScrapTL;;			AddWord	S_ScrapLeft,[Buffer]:#S_ScrapCols,a;;			dec		a;			pha;;			AddWord	S_ScrapTop,[Buffer]:#S_ScrapRows,a;			dec		a;			pha			in		S_ScrapTL:l,S_ScrapBR:l			in		#S_ChkCellProtect:l				;two longs on stack			XCall	S_QTraverse			bcc		chkOtherData			Call		D_AlertBox,in=(#OkBox:w,#S_ProtectedCellMsg:l),out=(a:w)			brl		ExitchkOtherData			lda		S_ExtraData			beq		doPaste			Call		D_AlertBox,in=(#OkCancelBox:w,#S_ExtraDataMsg:l),out=(a:w)			cmp		#OK			beq		doPaste			brl		ExitdoPaste;			Call		D_SetCursor,in=(#WatchCursor:w)			lda		Paste			bne		setImport			MoveWord	#S_UndoPasteType,PasteType			bra		contSetUndosetImport			cmp		#1			beq		doHotPaste			MoveWord	#S_UndoImportType,PasteType			bra		contSetUndodoHotPaste			Call		D_SetFileChanged,in=(Window:l)			CmpLong	Window,S_ActiveWindow			bne		doPaste2			MoveWord	#S_UndoPasteType,PasteTypecontSetUndo;	MoveLong	[Scrap],Buffer;;	PushLong	S_CurTLSelect;	AddWord	S_ScrapLeft,[Buffer]:#S_ScrapCols,a;	dec	a;	pha;	AddWord	S_ScrapTop,[Buffer]:#S_ScrapRows,a;	dec	a;	pha			PushLong	S_ScrapTL			in		S_ScrapTL:l,S_ScrapBR:l			XCall	S_BuildSimpleUndo,err=ErrorFlag			PullLong	S_ScrapTL			bcs		memErrordoPaste2			MoveLong	Scrap,S_ScrapBuffer			MoveWord	Paste,S_ScrapPasteType			Call		S_PutSSScrap,err=ErrorFlagmemError			Call		S_FixLE			in		S_ScrapTL:l,S_ScrapBR:l			XCall	S_RedrawCellRange			lda		PasteType			beq		chkCalc			Call		S_SetUndoOn,in=(PasteType:w)chkCalc	;	Stick code here to see if Appleworks Open should calculate	;			lda		S_CurEditFlag			and		#S_ManCalcBit			bne		savePaste			Call		S_CalculateSheetsavePaste			CmpLong	S_ActiveWindow,S_CurWindow			beq		Exit			Call		S_SwapOutExit			Call		X_DisposeScrap,in=(Type:w,Scrap:l)			RETURN			ENDP;-----------------------------------------------------------------------------; S_Image(where) draws an image of the copied cells.S_Image		PROC		EXPORT			;Using	S_ImageData			input	Where:l			BEGIN	+b			MoveLong Where,S_CopyRect			AddLong	Where,S_CopyFrame,S_CopyRect+4			Tool		_FrameRect,in=(#S_CopyRect:l)			RETURN			ENDP;-----------------------------------S_ImageData	PROC		EXPORT		EXPORT	S_CopyRect		EXPORT	S_CopyFrameS_CopyRect	DS.B 	8S_CopyFrame	DS.B 	4			ENDP;-----------------------------------S_SetImage	PROC		EXPORT			;Using	S_ImageData			;Using	S_CurrentData			input	TLCell:l,BRCell:l			local	MaxHeight:w,MaxWidth:w			BEGIN			SubWord	S_CurContHt,S_CurContYpt,MaxHeight			SubWord	S_CurContWd,S_CurContXpt,MaxWidth			SubWord	BRCell,TLCell,a			inc		a			cmp		#35			bge		setCurHt			asl		a			sta		S_CopyFrame			asl		a			asl		a			AddWord	a,S_CopyFrame,S_CopyFrame			cmp		MaxHeight			blt		setWidthsetCurHt			MoveWord MaxHeight,S_CopyFramesetWidth			SubWord	BRCell+2,TLCell+2,a			inc		a			cmp		#35			bge		setCurWd			stz		S_CopyFrame+2wdLoop			Call	S_CellWidth,in=(BRCell+2:w),out=(a:w)			AddWord	a,S_CopyFrame+2,S_CopyFrame+2			cmp		MaxWidth			bge		setCurWd			dec		BRCell+2			CmpWord	BRCell+2,TLCell+2			bge		wdLoop			bra		ExitsetCurWd			MoveWord MaxWidth,S_CopyFrame+2Exit			RETURN			ENDP;---------------------------------------------------------------------------; S_GetScrapCell;S_GetScrapCell	PROC		EXPORT			;Using	S_ScrapData			;Using	S_CurrentData			;Using	SANEequs			input	Cell:l,CellIndex:l			local	Buffer:l,ContentSize:l,CellSize:w			local	CellPtr:l,ContentPtr:l,Format:w			error	ErrorFlag			BEGIN			stz		ErrorFlag			CmpWord	S_ScrapBufferSize,#$7800			blt		bufferOK			Call		S_AddBufferToScrap,err=ErrorFlag			jcs		ExitbufferOK			H_GetBlockPtr	CellIndex,CellPtr			MoveWord	[CellPtr]:#S_CellFormat,Format			jmi		Exit			AddLong	S_ScrapBuffer,S_ScrapBufferSize,Buffer	;	Store the location	;			SubWord	Cell,S_ScrapOrgCell,a			inc		a			MoveWord	a,[Buffer]:#S_ScrapCellLoc			iny			iny			SubWord	Cell+2,S_ScrapOrgCell+2,a			inc		a			sta		[Buffer],y	;	Store the format information	;			MoveWord	Format,[Buffer]:#S_ScrapFormat			MoveWord	[CellPtr]:#S_CellFormat+2,a			and		#$FFFF-S_CellProtect-S_CellCircular			MoveWord	a,[Buffer]:#S_ScrapFormat+2			MoveWord	#S_ScrapValueSize,CellSize	;	Store the last calculated value	;			lda		Format			and		#S_CellTypeValue			jne		getSane			CmpLong	[CellPtr]:#S_CellValue,[CellPtr]:#S_CellContent			bne		getString			MoveWord	#0,[Buffer]:#S_ScrapValueSize			inc		CellSize			brl		getContentgetString			H_GetBlockPtr	[CellPtr]:#S_CellValue,ContentPtr			lda		[ContentPtr]			and		#$00FF			inc		a			sta		ContentSize			stz		ContentSize+2			PushLong	ContentPtr			AddLong	Buffer,#S_ScrapValueSize,s			PushLong	ContentSize			Tool		_BlockMove			AddWord	ContentSize,CellSize,CellSize			bra		getContentgetSane			MoveWord	#10,[Buffer]:#S_ScrapValueSize			AddLong	CellPtr,#S_CellValue,s			AddLong	Buffer,#S_ScrapValue,s			Tool		FX2X,in=(:l,:l)			AddWord	#11,CellSize,CellSize	;	Store the content of the cell	;getContent			H_GetBlockSize	[CellPtr]:#S_CellContent,ContentSize			lda		ContentSize+2			ora		ContentSize			beq		storeSize			H_GetBlockPtr	[CellPtr]:#S_CellContent,ContentPtr			PushLong	ContentPtr			lda		CellSize			AddLong	a,Buffer,s			PushLong	ContentSize			Tool		_BlockMove	;	Store the cell size	;storeSize			AddWord	CellSize,ContentSize,[Buffer]:#S_ScrapCellSize			AddLong	a,S_ScrapBufferSize,S_ScrapBufferSizeExit			RETURN			ENDP;---------------------------------------------------------------------------;;S_ScrapValue2String		PROC		EXPORT			;Using	S_CurrentData			;Using	S_FormulaData			;Using	SANEequs			input	Buffer:l			output	ContentIndex:l,CellType:w			local	ContentPtr:l,StringPtr:l,ContentSize:l			local	FormatPtr:l,ValuePtr:l			error	ErrFlag			BEGIN			stz		ErrFlag			MoveWord	#S_CellTypeValue,CellType			AddLong	Buffer,#S_ScrapFormat,FormatPtr			lda		[FormatPtr]			and		#S_CellInvalid			beq		chkInf			MoveWord	#S_CellTypeFormula,CellType			lda		[FormatPtr]			and		#S_CellError			beq		doNa			MoveLong	#S_ErrorFormula,StringPtr			MoveLong	#S_ErrorFormulaLength,ContentSize			brl		saveContentdoNa			MoveLong	#S_NAFormula,StringPtr			MoveLong	#S_NAFormulaLength,ContentSize			brl		saveContentchkInf			AddLong	Buffer,#S_ScrapValue,ValuePtr			Tool		FCLASSX,in=(ValuePtr:l)			txa			and		#$00FF			cmp		#$00FE			bne		doValue			MoveWord	#S_CellTypeFormula,CellType			txa			bmi		doNegInf			MoveLong	#S_INFFormula,StringPtr			MoveLong	#S_INFFormulaLength,ContentSize			bra		saveContentdoNegInf			MoveLong	#S_NegINFFormula,StringPtr			MoveLong	#S_NegINFFormulaLength,ContentSize			bra		saveContentdoValue			stz		ContentIndex			stz		ContentIndex+2			brl		ExitsaveContent			H_NewBlock	ContentSize,ContentIndex,ContentPtr,err=ErrFlag			bcs			Exit			Tool			_BlockMove,in=(StringPtr:l,ContentPtr:l,ContentSize:l)Exit			RETURN			ENDP;---------------------------------------------------------------------------; S_GetSSScrap;S_GetSSScrap	PROC		EXPORT			;Using	D_GlobalData			;Using	S_ScrapData			input	TLCell:l,BRCell:l			output	ScrapHandle:l			local	Buffer:l,ScrapPtr:l			error	ErrFlag			BEGIN			stz		ErrFlag			MoveWord	#1,>D_BitMapChanged			lda		>D_BitMapPtr+2			tax			lda		>D_BitMapPtr			MoveLong	ax,Buffer			MoveLong	ax,S_ScrapBuffer			SubWord	BRCell,TLCell,a			inc		a			MoveWord	a,[Buffer]:#S_ScrapRows			SubWord	BRCell+2,TLCell+2,a			inc		a			MoveWord	a,[Buffer]:#S_ScrapCols			MoveWord	#0,[Buffer]:#S_ScrapParseCode			MoveWord	#S_ScrapCells,S_ScrapBufferSize			stz		S_ScrapBufferSize+2			stz		S_ScrapHandle			stz		S_ScrapHandle+2			stz		S_ScrapHandleSize			stz		S_ScrapHandleSize+2			MoveLong	TLCell,S_ScrapOrgCell			in		TLCell:l,BRCell:l,#S_GetScrapCell:l			XCall	S_QTraverse,err=ErrFlag			bcs		Exit			Call		S_AddBufferToScrap,err=ErrFlag			bcs		Exit			MoveLong	S_ScrapHandle,ScrapHandleExit			RETURN			ENDP;------------------------------------------------------------------------------;;S_AddBufferToScrap 	PROC		EXPORT				;Using	S_ScrapData			local	ScrapHandle:l,NewSize:l,ScrapPtr:l			error	ErrFlag			BEGIN			stz		ErrFlag			MoveLong	S_ScrapHandle,ScrapHandle			lda		ScrapHandle			ora		ScrapHandle+2			bne		resizeHandle			MoveLong	S_ScrapBufferSize,ax			MoveLong	ax,NewSize			Call		D_NeedHand,in=(ax:l),out=(ax:l),err=ErrFlag			jcs		Exit			MoveLong	ax,S_ScrapHandle			MoveLong	ax,ScrapHandle			bra		moveDataresizeHandle			AddLong	S_ScrapHandleSize,S_ScrapBufferSize,NewSize			Call		D_GrowHandle,in=(NewSize:l,ScrapHandle:l),err=ErrFlag			bcc		moveData			Tool		_DisposeHandle,in=(ScrapHandle:l)			bra		ExitmoveData			MoveLong	[ScrapHandle],ScrapPtr			PushLong	S_ScrapBuffer			AddLong	ScrapPtr,S_ScrapHandleSize,s			PushLong	S_ScrapBufferSize			XTool	_BlockMove			MoveWord	NewSize,[ScrapPtr]:#S_ScrapSize			sta		S_ScrapHandleSize			MoveWord	NewSize+2,[ScrapPtr]:#S_ScrapSize+2			sta		S_ScrapHandleSize+2			stz		S_ScrapBufferSize			stz		S_ScrapBufferSize+2Exit			RETURN			ENDP;---------------------------------------------------------------------------;;S_PutSSScrap	PROC		EXPORT			;Using	S_ScrapData			;Using	S_CurrentData			;Using	SANEEqus			local	TLCell:l,BRCell:l,ScrapLimit:l			local	Cell:l,CellIndex:l,CellPtr:l			local	ContentIndex:l,ContentPtr:l			local	Buffer:l,TypeCell:w,Format:l			local	LCell:l,RCell:l,StringPtr:l,ScrapHandle:l			local	ParseCode:w			local	ContentStart:l,ContentSize:l,CellSize:w			local	ScrapSize:l,ValueSize:l			error	ErrorFlag			BEGIN			stz		ErrorFlag			MoveLong	S_ScrapBuffer,ScrapHandle			MoveLong	[ScrapHandle],Buffer			AddWord	S_ScrapTop,[Buffer]:#S_ScrapRows,a			dec		a			sta		S_ScrapBottom			AddWord	S_ScrapLeft,[Buffer]:#S_ScrapCols,a			dec		a			sta		S_ScrapRight			SubLong	S_ScrapTL,#$10001,S_ScrapOrgCell	;	Determine Parse Code	;			MoveWord	[Buffer]:#S_ScrapParseCode,ParseCode	;	do Paste	;			MoveLong	[Buffer]:#S_ScrapSize,ScrapLimit			MoveWord	#S_ScrapCells,ScrapSize			stz		ScrapSize+2			MoveLong	S_ScrapTL,TLCell			MoveLong	S_ScrapBR,BRCell			in		TLCell:l,BRCell:l,#S_ClearCell:l			XCall	S_QTraverse,err=ErrorFlag			jcs		Exit			stz		ValueSize+2			stz		ContentStart+2			stz		ContentSize+2			CmpLong	ScrapSize,ScrapLimit			jge		ExitpasteLoop			Call		D_BeachBall			stz		ContentIndex			stz		ContentIndex+2			AddLong	[ScrapHandle],ScrapSize,Buffer	;	Figure cell location	;			AddLong	[Buffer]:#S_ScrapCellLoc,S_ScrapOrgCell,Cell	;	Get the content of the cell	;			MoveWord	[Buffer]:#S_ScrapValueSize,a			and		#$00FF			sta		ValueSize			AddWord	a,#S_ScrapValue,ContentStart			MoveWord	[Buffer]:#S_ScrapCellSize,CellSize			SubWord	a,ContentStart,ContentSize			CmpWord	ParseCode,#2			jlt		semiParsed			SpaceWord			SpaceLong	;	This cludge makes A1 references refer to top,left of Paste	;	;	when it is an import of ascii file.			;			CmpWord	S_ScrapPasteType,#2			bne		notImport			SubLong	Cell,S_ScrapOrgCell,s			bra		contNotParsednotImport			PushLong	CellcontNotParsed			PushLong	ScrapHandle			lda		ContentStart			inc		a			AddLong	a,ScrapSize,s			SubWord	ContentSize,#1,s			PushLong	#DRec			PushWord	#1			Call		S_ParseText,err=ErrorFlag			PullLong	ContentIndex			PullWord	TypeCell			jcs		Exit			lda		S_CurDefFormat			and		#$FFFF-S_CellType			ora		TypeCell			sta		Format			MoveWord	S_CurDefFormat+2,Format+2			CmpWord	TypeCell,#S_CellTypeValue			jne		createCell			Tool		FDEC2X,in=(#DRec:l,#Number:l)			brl		createCell	;	Scrap is either semi-parsed or fully - parsed	;semiParsed			MoveLong	[Buffer]:#S_ScrapFormat,Format			MoveWord	Format,a			and		#S_CellType			sta		TypeCell			beq		jmpCopyContent					; cell type text			and		#S_CellTypeTextForm				; any formula			jeq		createCell					; must be a value			lda		ParseCode			bne		parseFormulajmpCopyContent			brl		copyContentparseFormula	;	Scrap is semi - parsed	;	;	These come from AppleWorks and may never have calculated	;	;	text fields.			;			SpaceLong			lda		ContentStart			inc		a			AddLong	a,Buffer,s			lda		ContentSize			dec		a			pha			PushLong	Cell			PushWord	#1			Call		E_ParseFormula,err=ErrorFlag			PullLong	ContentIndex			jcc		createCell			lda		Format			and		#$FFFF-S_CellType-S_CellInvalid-S_CellError;			ora		#S_CellTypeText			; = 0			sta		Format			stz		TypeCell	;	The Content field has the correct content	;copyContent			H_NewBlock	ContentSize,ContentIndex,ContentPtr,err=ErrorFlag			jcs			Exit			AddLong	[ScrapHandle],ScrapSize,Buffer			AddLong	Buffer,ContentStart,s			PushLong	ContentPtr			PushLong	ContentSize			Tool		_BlockMove			lda		Format			and		#S_CellTypeTextForm			beq		createCell	;	If this is an SS formula, make sure that all cell references	;	;	are within the spreadsheet.			;			Call		S_CheckFormula,in=(Cell:l,ContentPtr:l)	;	Get a New cell	;createCell			in		Cell:l,Format:l,ContentIndex:l			out		LCell:l,RCell:l			XCall	S_AcceptCell,err=ErrorFlag			jcs		Exit	;	Store the last calculated value	;			AddLong	[ScrapHandle],ScrapSize,Buffer			in		Cell:l			out		CellIndex:l			XCall	S_GetCellIndex			H_GetBlockPtr	CellIndex,CellPtr			lda		TypeCell			and		#S_CellTypeValue			beq		textInValue			CmpWord	ParseCode,#2			bne		valueInScrap			lda		TypeCell			and		#S_CellTypeTextForm			; any formula			jne		wrapUp			PushLong	#Number			bra		moveNumbervalueInScrap			AddLong	Buffer,#S_ScrapValue,smoveNumber			AddLong	CellPtr,#S_CellValue,s			Tool		FX2X,in=(:l,:l)			brl		wrapUptextInValue			lda		TypeCell			jeq		setValue					; type = Text			AddWord	ValueSize,#1,ValueSize			H_NewBlock	ValueSize,ContentIndex,ContentPtr,err=ErrorFlag			bcc			okTextValue	;	No Space for text value	;			H_GetBlockPtr	CellIndex,CellPtr			lda		Format			and		#$FFFF-S_CellType			ora		#S_CellTypeFormula			MoveWord	a,[CellPtr]:#S_CellFormat			Call		S_RemoveCell,in=(Cell:l)			brl		ExitokTextValue			AddLong	[ScrapHandle],ScrapSize,Buffer			AddLong	Buffer,#S_ScrapValueSize,s			PushLong	ContentPtr			PushLong	ValueSize			Tool		_BlockMove			H_GetBlockPtr	CellIndex,CellPtrsetValue			MoveLong	ContentIndex,[CellPtr]:#S_CellValuewrapUp			Call		S_AddCellToChangedList,in=(Cell:l)			lda		RCell+2			cmp		S_ScrapRight			blt		OKright			sta		S_ScrapRightOKright			lda		LCell+2			cmp		S_ScrapLeft			bge		fixSize			sta		S_ScrapLeftfixSize			lda		CellSize			AddLong	a,ScrapSize,ScrapSize			CmpLong	ScrapSize,ScrapLimit			jlt		pasteLoopExit			RETURNDRec			DS.B 	33Number		DS.B 	10			ENDP;-----------------------------------------------------------------------------;;S_CheckFormula	PROC		EXPORT			input	Cell:l,FormulaPtr:l			local	Start:w,Stop:w,RealCell:l			BEGIN			MoveWord	[FormulaPtr]:#E_FormulaCells,Stop			MoveWord	#E_FormulaData,Start			CmpWord	Start,Stop			jge		ExitdependLoop			SpaceLong			AddWord	Start,#3,y			PushWord	[FormulaPtr]:y			dey			dey			PushWord	[FormulaPtr]:y			dey			lda		[FormulaPtr],y			and		#$00FF			pha			PushLong	Cell			Call		S_GetRealCell			PullLong	RealCell			lda		RealCell			beq		trashIt			cmp		#10000			bge		trashIt			lda		RealCell+2			beq		trashIt			cmp		#703			blt		nextDependtrashIt			ldy		Start			iny			MoveLong	#S_NotACell,[FormulaPtr]:ynextDepend			AddWord	Start,#5,Start			cmp		Stop			jlt		dependLoopExit			RETURN			ENDP			END