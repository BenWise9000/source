		LOAD		'Macros.dump'		INCLUDE	'SS.equ'		INCLUDE	'Driver.equ'		INCLUDE	'Heap.aii.i';-----------------------------------------------;;	Imported addresses;;-----------------------------------------------		IMPORT	D_AlertBox		IMPORT	D_MemoryError		IMPORT	X_DialogFromScrap		IMPORT	X_GetScrap		IMPORT	X_SSScTypes		IMPORT	S_AcceptCell		IMPORT	S_ActiveWindow		IMPORT	S_AddCellToChangedList		IMPORT	S_BadPasteMsg		IMPORT	S_BuildSimpleUndo		IMPORT	S_CalculateSheet		IMPORT	S_ChkCellProtect		IMPORT	S_ClearCell		IMPORT	S_CurBRMost		IMPORT	S_CurBRSelect		IMPORT	S_CurEditFlag		IMPORT	S_CurLEHandle		IMPORT	S_CurTLSelect		IMPORT	S_DoChecks		IMPORT	S_DrawLocation		IMPORT	S_ExtraData		IMPORT	S_ExtraDataMsg		IMPORT	S_FixLE		IMPORT	S_GetCellPtr		IMPORT	S_GetDirDlog		IMPORT	S_GetSSScrap		IMPORT	S_HiliteCells		IMPORT	S_PasteValueMsg		IMPORT	S_ProtectedCell		IMPORT	S_ProtectedCellMsg		IMPORT	S_PutSSScrap		IMPORT	S_QTraverse		IMPORT	S_RedrawCellRange		IMPORT	S_ScrapBR		IMPORT	S_ScrapBottom		IMPORT	S_ScrapBuffer		IMPORT	S_ScrapLeft		IMPORT	S_ScrapOrgCell		IMPORT	S_ScrapRight		IMPORT	S_ScrapTL		IMPORT	S_ScrapTop		IMPORT	S_ScrapValue2String		IMPORT	S_SetBRMostCell		IMPORT	S_SetUndoOn		IMPORT	S_SwapIn;----------------------------------------------------------------------------;	S_PasteValues;S_PasteValues	PROC		EXPORT			;Using	S_ScrapData			;Using	S_CurrentData			;Using	X_ClipData			;Using	SANEequs			;Using	S_ErrorData			;Using	S_ProtectData			local	ContentIndex:l,Cell:l,CellPtr:l			local	ScrapHandle:l,Buffer:l,SFlag:w			local	TLCell:l,BRCell:l,ScrapLimit:l			local	ContentPtr:l			local	TypeCell:w,Format:l			local	LCell:l,RCell:l,StringPtr:l			local	ContentStart:l,ContentSize:l,CellSize:w			local	ScrapSize:l,ValueSize:l			error	ErrorFlag			BEGIN	+b			stz		ErrorFlag			stz		ContentIndex			stz		ContentIndex+2			Call		X_GetScrap,in=(#X_SSScTypes:l),out=(SFlag:w,ScrapHandle:l)			beq		needScrap			MoveLong	[ScrapHandle],Buffer			MoveWord	[Buffer]:#S_ScrapParseCode,a			beq		goodScrapneedScrap			Call		D_AlertBox,in=(#OkBox:w,#S_PasteValueMsg:l),out=(a:w)			lda		SFlag			jeq		Quit			brl		ExitgoodScrap			Call		S_SwapIn,in=(S_ActiveWindow:l)			MoveWord	S_CurEditFlag,a			and		#S_EditingBit			beq		notLE			Call		X_DialogFromScrap			Tool		_LEPaste,in=(S_CurLEHandle:l)			brl		ExitnotLE			MoveWord	S_CurTLSelect,S_ScrapTop			AddWord	a,[Buffer]:#S_ScrapRows,a			dec		a			sta		S_ScrapBottom			MoveWord	S_CurTLSelect+2,S_ScrapLeft			AddWord	a,[Buffer]:#S_ScrapCols,a			dec		a			sta		S_ScrapRight	;	Is it on the spread sheet	;			cmp		#703			bge		badPaste			CmpWord	S_ScrapBottom,#10000			blt		chkProtectbadPaste			Call		D_AlertBox,in=(#OkBox:w,#S_BadPasteMsg:l),out=(a:w)			brl		ExitchkProtect;			Call		D_SetCursor,in=(#WatchCursor:w)			stz		S_ProtectedCell			stz		S_ExtraData			in		S_ScrapTL:l,S_ScrapBR:l,#S_ChkCellProtect:l			XCall	S_QTraverse			bcc		chkOtherData			Call		D_AlertBox,in=(#OkBox:w,#S_ProtectedCellMsg:l),out=(a:w)			brl		ExitchkOtherData			lda		S_ExtraData			beq		DoPaste			Call		D_AlertBox,in=(#OkCancelBox:w,#S_ExtraDataMsg:l),out=(a:w)			cmp		#OK			beq		DoPaste			brl		ExitDoPaste			PushLong	S_ScrapTL			PushLong	S_ScrapBR			in		S_ScrapTL:l,S_ScrapBR:l			XCall	S_BuildSimpleUndo,err=ErrorFlag			PullLong	S_ScrapBR			PullLong	S_ScrapTL			jcs		pasteError			MoveLong	ScrapHandle,S_ScrapBuffer			MoveLong	[ScrapHandle],Buffer	;	do Paste	;			SubLong	S_ScrapTL,#$10001,S_ScrapOrgCell			MoveLong	[Buffer]:#S_ScrapSize,ScrapLimit			MoveWord	#S_ScrapCells,ScrapSize			stz		ScrapSize+2			MoveLong	S_ScrapTL,TLCell			MoveLong	S_ScrapBR,BRCell			in		TLCell:l,BRCell:l,#S_ClearCell:l			XCall	S_QTraverse,err=ErrorFlag			jcs		Exit			stz		ValueSize+2			stz		ContentStart+2			stz		ContentSize+2			CmpLong	ScrapSize,ScrapLimit			jge		chkRedrawpasteLoop			AddLong	[ScrapHandle],ScrapSize,Buffer	;	Figure cell location	;			AddLong	[Buffer]:#S_ScrapCellLoc,S_ScrapOrgCell,Cell	;	Get the content of the cell	;			MoveWord	[Buffer]:#S_ScrapValueSize,a			and		#$00FF			sta		ValueSize			AddWord	a,#S_ScrapValue,ContentStart			MoveWord	[Buffer]:#S_ScrapCellSize,CellSize			SubWord	a,ContentStart,ContentSize	;	Check the format for the cell type	;			MoveLong	[Buffer]:#S_ScrapFormat,Format			MoveWord	Format,a			and		#S_CellType			sta		TypeCell			jeq		copyContent			; cell type text			cmp		#S_CellTypeValue			beq		noContent			cmp		#S_CellTypeTextForm			beq		copyValueText	;	Must be a value formula	;			in		Buffer:l			out		ContentIndex:l,TypeCell:w			XCall	S_ScrapValue2String,err=ErrorFlag			jcs		pasteError			lda		Format			and		#$FFFF-S_CellType			ora		TypeCell				; this might be formula			sta		Format				; if NA, ERROR, INF, etc.			brl		createCellnoContent			stz		ContentIndex			stz		ContentIndex+2			brl		createCellcopyValueText			AddLong	Buffer,#S_ScrapValueSize,StringPtr			MoveWord	[StringPtr],a			and		#$00FF			inc		a			sta		ContentSize			stz		ContentSize+2			H_NewBlock	ContentSize,ContentIndex,ContentPtr,err=ErrorFlag			jcs			pasteError			AddLong	Buffer,#S_ScrapValueSize,s			Tool		_BlockMove,in=(:l,ContentPtr:l,ContentSize:l)			lda		Format			and		#$FFFF-S_CellType;			ora		#S_CellTypeText			;= 0			sta		Format			bra		createCellcopyContent			H_NewBlock	ContentSize,ContentIndex,ContentPtr,err=ErrorFlag			jcs			pasteError			AddLong	[ScrapHandle],ScrapSize,Buffer			AddLong	ContentStart,Buffer,s			PushLong	ContentPtr			PushLong	ContentSize			Tool		_BlockMove	;	Get a New cell	;createCell			in		Cell:l,Format:l,ContentIndex:l			out		LCell:l,RCell:l			XCall	S_AcceptCell,err=ErrorFlag			jcs		pasteError	;	Store the last calculated value	;			in		Cell:l			out		CellPtr:l			XCall	S_GetCellPtr			AddLong	[ScrapHandle],ScrapSize,Buffer			lda		Format			and		#S_CellType			beq		setTextValue			AddLong	Buffer,#S_ScrapValue,s			AddLong	CellPtr,#S_CellValue,s			Tool		FX2X,in=(:l,:l)			bra		wrapupsetTextValue			MoveLong	ContentIndex,[CellPtr]:#S_CellValuewrapUp			Call		S_AddCellToChangedList,in=(Cell:l)			lda		RCell+2			cmp		S_ScrapRight			blt		OKright			sta		S_ScrapRightOKright			lda		LCell+2			cmp		S_ScrapLeft			bge		fixSize			sta		S_ScrapLeftfixSize			lda		CellSize			AddLong	a,ScrapSize,ScrapSize			CmpLong	ScrapSize,ScrapLimit			bge		chkRedraw			brl		pasteLooppasteError			Call		D_MemoryError	;	Redraw the necessary cells	;chkRedraw			Call		S_FixLEredraw			in		S_ScrapTL:l,S_ScrapBR:l			XCall	S_RedrawCellRange			Call		S_SetUndoOn,in=(#S_UndoPasteValuesType:w)			lda		S_CurEditFlag			and		#S_ManCalcBit			bne		Exit			Call		S_CalculateSheetExit			Tool		_DisposeHandle,in=(ScrapHandle:l)Quit			RETURN			ENDP;---------------------------------------------------------------------------; S_SelectAll;S_SelectAll	PROC		EXPORT			;Using	S_CurrentData			BEGIN	+b			Call		S_SwapIn,in=(S_ActiveWindow:l)			MoveWord	S_CurEditFlag,a			and		#S_EditingBit			beq		findRange			Tool		_LEGetTextLen,in=(S_CurLEHandle:l),out=(x:w)			Tool		_LESetSelect,in=(#0:w,x:w,S_CurLEHandle:l)			bra		ExitfindRange			lda		S_CurEditFlag			and		#S_BRMostBit			beq		BRset			Call		S_SetBRMostCell,in=(#0:w)			lda		#S_BRMostBit			trb		S_CurEditFlagBRset			Call		S_HiliteCells			MoveWord	#1,S_CurTLSelect			sta		S_CurTLSelect+2			MoveLong	S_CurBRMost,S_CurBRSelect			Call		S_HiliteCells			Call		S_DoChecks			Call		S_FixLE			Call		S_DrawLocationExit			RETURN			ENDP;-----------------------------------------------------------------------------;	S_Fill;S_Fill		PROC		EXPORT			;Using	S_ScrapData			;Using	S_CurrentData			;Using	S_ErrorData			local	TLCell:l,LMost:w,RMost:w			error	ErrFlag			BEGIN	+b			stz		ErrFlag			Call		S_SwapIn,in=(S_ActiveWindow:l)			lda		S_CurEditFlag			and		#S_EditingBit			jne		Exit			stzl		S_ScrapBuffer			MoveLong	S_CurTLSelect,TLCell			MoveWord	S_CurTLSelect+2,LMost			MoveWord	S_CurBRSelect+2,RMost			CmpWord	S_CurTLSelect,S_CurBRSelect			jeq		chkFillCols			CmpWord	S_CurTLSelect+2,S_CurBRSelect+2			beq		fillRows	;	Put dialog for choosing row or column fill here	;	;	direction: 0==Cancel,1==Left,2==Right,3==Up,4==Down			Call		S_GetDirDlog,in=(#0:w),out=(a:w)			jeq		Exit				; = cancel			cmp		#2				; = right			jeq		chkFillCols			cmp		#4				; = down			jne		ExitfillRows			CmpWord	S_CurTLSelect,S_CurBRSelect			jeq		Exit;			Call		D_SetCursor,in=(#WatchCursor:w)			PushWord	TLCell+2			lda		TLCell			inc		a			pha			in		S_CurBRSelect:l,#S_ChkCellProtect:l			XCall	S_QTraverse			bcc		contRFill			Call		D_AlertBox,in=(#OkBox:w,#S_ProtectedCellMsg:l),out=(a:w)			brl		ExitcontRFill			PushWord	TLCell+2			lda		TLCell			inc		a			pha			Call		S_BuildSimpleUndo,in=(:l,S_CurBRSelect:l),err=ErrFlag			bcs		cantFill			in		S_CurTLSelect:l,S_CurBRSelect+2:w,S_CurTLSelect:w			out		S_ScrapBuffer:l			XCall	S_GetSSScrap,err=ErrFlag			bcs		cantFillpasteRowLoop			inc		TLCell			MoveLong	TLCell,S_ScrapTL			Call		S_PutSSScrap,err=ErrFlag			bcs		cantFill			CmpWord	S_ScrapLeft,LMost			bge		chkRight1			sta		LMostchkRight1			CmpWord	S_ScrapRight,RMost			blt		cont1			sta		RMostcont1			CmpWord	TLCell,S_CurBRSelect			blt		pasteRowLoop			brl		redrawcantFill			Call		D_MemoryError			brl		redrawchkFillCols			CmpWord	S_CurTLSelect+2,S_CurBRSelect+2			jeq		Exit;			Call		D_SetCursor,in=(#WatchCursor:w)			lda		TLCell+2			inc		a			pha			PushWord	TLCell			in		S_CurBRSelect:l,#S_ChkCellProtect:l			XCall	S_QTraverse			bcc		contCFill			Call		D_AlertBox,in=(#OkBox:w,#S_ProtectedCellMsg:l),out=(a:w)			brl		ExitcontCFill			lda		TLCell+2			inc		a			pha			PushWord	TLCell			Call		S_BuildSimpleUndo,in=(:l,S_CurBRSelect:l),err=ErrFlag			bcs		cantFill2fillCols			in		S_CurTLSelect:l,S_CurTLSelect+2:w,S_CurBRSelect:w			out		S_ScrapBuffer:l			XCall	S_GetSSScrap,err=ErrFlag			bcc		pasteColLoopcantFill2			brl		cantFillpasteColLoop			inc		TLCell+2			MoveLong	TLCell,S_ScrapTL			Call		S_PutSSScrap,err=ErrFlag			bcs		cantFill2			CmpWord	S_ScrapLeft,LMost			bge		chkRight2			sta		LMostchkRight2			CmpWord	S_ScrapRight,RMost			blt		cont2			sta		RMostcont2			CmpWord	TLCell+2,S_CurBRSelect+2			blt		pasteColLoopredraw			in		LMost:w,S_CurTLSelect:w,RMost:w,S_CurBRSelect:w			XCall	S_RedrawCellRange			Call		S_SetUndoOn,in=(#S_UndoFillType:w)			lda		S_CurEditFlag			and		#S_ManCalcBit			bne		killHandle			Call		S_CalculateSheetkillHandle			lda		S_ScrapBuffer			ora		S_ScrapBuffer+2			beq		Exit			Tool		_DisposeHandle,in=(S_ScrapBuffer:l)Exit			RETURN			ENDP			END