	LOAD	'macros.dump'	include	'pl.equ'	include	'driver.equ'	include	'scrap.equ';-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	D_MakeNewWin	IMPORT	D_AddStrings	IMPORT	D_BitMapPtr	IMPORT	D_Deref	IMPORT	D_DisposePtr	IMPORT	D_FastMult	IMPORT	D_GetNewUntitled	IMPORT	X_GetPLSCRAPAddr	IMPORT	D_GetPrintHandle	IMPORT	D_GetRefCon	IMPORT	D_LoadSegment	IMPORT	D_NeedHand	IMPORT	D_NeedHandle	IMPORT	D_NewCtl	IMPORT	P_AllHGCount	IMPORT	P_AllHGuides	IMPORT	P_AllVGCount	IMPORT	P_AllVGuides	IMPORT	P_ArrowRect	IMPORT	P_AttrTable	IMPORT	P_BuildUndo	IMPORT	P_CheckHand	IMPORT	P_Clear	IMPORT	P_ContentRect	IMPORT	P_ConvErr	IMPORT	P_Copy	IMPORT	P_CurDate	IMPORT	P_CurrentWin	IMPORT	P_Cursor	IMPORT	P_Cut	IMPORT	P_DblPage	IMPORT	P_DefColor	IMPORT	P_DefFont	IMPORT	P_DefJust	IMPORT	P_DefSize	IMPORT	P_DefSpacing	IMPORT	P_DefStyle	IMPORT	P_DelObjects	IMPORT	P_DoScritch	IMPORT	P_DrawContent	IMPORT	P_Entry	IMPORT	P_FillMode	IMPORT	P_FirstPOff	IMPORT	P_FixMenus	IMPORT	P_FixSpecMenu	IMPORT	P_ForceUpdate	IMPORT	P_FullPageRect	IMPORT	P_FullPaperRect	IMPORT	P_GrowRect	IMPORT	P_H	IMPORT	P_HDataSize	IMPORT	P_HRulRect	IMPORT	P_HScrTempl	IMPORT	P_HScroll	IMPORT	P_HValue	IMPORT	P_HViewSize	IMPORT	P_HorizGCount	IMPORT	P_HorizGuides	IMPORT	P_ImportHdl	IMPORT	P_ImportType	IMPORT	P_KillImport	IMPORT	P_KillPage	IMPORT	P_KillUndo	IMPORT	P_LastObj	IMPORT	P_LineSize	IMPORT	P_LoadWindowStuff	IMPORT	P_LockGuides	IMPORT	P_MagGuides	IMPORT	P_MakePict	IMPORT	P_MouseDown	IMPORT	P_MouseUp	IMPORT	P_ObjList	IMPORT	P_OldIdlePt	IMPORT	P_OpenDoc	IMPORT	P_OrgOffset	IMPORT	P_PIconRect	IMPORT	P_PInfoSize	IMPORT	P_Page	IMPORT	P_PageArray	IMPORT	P_PageCount	IMPORT	P_PageMode	IMPORT	P_PageRect	IMPORT	P_PageStart	IMPORT	P_Palette	IMPORT	P_PaperRect	IMPORT	P_Placing	IMPORT	P_Plane	IMPORT	P_PortRect	IMPORT	P_PrintDoc	IMPORT	P_PrintHand	IMPORT	P_QDPict	IMPORT	P_SWinParams	IMPORT	P_SampTitle	IMPORT	P_SaveDoc	IMPORT	P_SavePage	IMPORT	P_SaveWindowStuff	IMPORT	P_TBarColor	IMPORT	P_TitleColor	IMPORT	P_ToolType	IMPORT	P_TrackCursor	IMPORT	P_TrackOn	IMPORT	P_Undo	IMPORT	P_UpDateDoc	IMPORT	P_UseTemplate	IMPORT	P_V	IMPORT	P_VDataSize	IMPORT	P_VRulRect	IMPORT	P_VScrTempl	IMPORT	P_VScroll	IMPORT	P_VValue	IMPORT	P_VViewSize	IMPORT	P_VertGCount	IMPORT	P_VertGuides	IMPORT	P_VisGuides	IMPORT	P_VisPalette	IMPORT	P_VisRuler	IMPORT	P_WinStuffSize	IMPORT	P_WindColors	IMPORT	P_paste	IMPORT	X_ScrapRefCon	IMPORT	X_ScrapType	IMPORT	D_SetRefCon	IMPORT	T_ClipThread	IMPORT	T_Deactivate	IMPORT	T_DotObj	IMPORT	T_Editing	IMPORT	T_Idle	IMPORT	T_Key	IMPORT	T_ScaleLocInfo	IMPORT	T_ScalePort	IMPORT	D_TodaysDate	IMPORT	D_UnloadSegment	IMPORT	D_UnLock;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	P_ActivateDoc	ENTRY	P_DeActivateDoc	ENTRY	P_DisposeDoc	ENTRY	P_GrewDoc	ENTRY	P_IdleProc	ENTRY	P_Ignore	ENTRY	P_InitDoc	ENTRY	P_KeyDown	ENTRY	P_LoadMod	ENTRY	P_MakeRoom	ENTRY	P_MakeWin	ENTRY	P_Message	ENTRY	P_NewDoc	ENTRY	P_PrintChanged	ENTRY	P_RelockMem	ENTRY	P_ShowDoc	ENTRY	P_UnloadMod	ENTRY	P_UnlockMemP_Procs	PROC	EXPORT	;Using	P_AttrData	DC.L	P_AttrTable	;attribute table for module	jml	P_OpenDoc	;D_Open a file	jml	P_NewDoc	;D_Create a D_New file	jml	P_DisposeDoc	;dispose of a window	jml	P_SaveDoc	;D_Save a document	jml	P_Undo	;undo in active window	jml	P_Cut	;cut in active window	jml	P_Copy	;do a copy in a window active or not	jml	P_paste	;Do a Paste in a window active or not	jml	P_Clear	;Do a clear in the active window	jml	P_ActivateDoc	;make a window active	jml	P_DeActivateDoc	jml	P_UpDateDoc	;D_Update a window	jml	P_MouseDown	;mouse down in active window	jml	P_KeyDown	;key down in active window	jml	P_Ignore	;mouse down in active window bar	jml	P_GrewDoc	;document changed size (zoomed)	jml	P_IdleProc	;called in D_MainLoop	jml	P_MakeRoom	;release unneeded memory	jml	P_PrintChanged	;print record changed	jml	P_PrintDoc	jml	P_MouseUp	jml	P_Message	jml	P_LoadMod	jml	P_UnloadMod	jml	P_UnlockMem	jml	P_RelockMem	jml	P_MakeWinP_Vers	DC.W	101	; official module version number.	ENDPP_Ignore	PROC	EXPORT	begin	return	ENDP;---------------------------------------------------------------------------;; P_MakeWin   ;P_MakeWin	PROC	EXPORT	;Using	P_Data	;Using	P_AttrData	input	plane:l,RectPtr:l	output	window:l	error	err	begin	+b	MoveLong	#-1,Window	movelong	Plane,P_Plane	tool	_NewWindow,in=(#P_SWinParams:l),out=(window:l),err=(err)	jcs	whoops	tool	_SetOriginMask,in=(#$fffc:w,window:l)	tool	_GetFrameColor,in=(#P_WindColors:l,window:l)	moveword	#$20f,P_TBarColor	moveword	#$f00,P_TitleColor	tool	_SetFrameColor,in=(#P_WindColors:l,window:l)	tool	_SetPort,in=(window:l)	tool	_SetFontFlags,in=(#4:w)	tool	_SetTextMode,in=(#modeForeCopy:w)whoops	return	ENDP;---------------------------------------------------------------------------; NewDoc - opens a blank document on the desktop; input - ModuleNum use as reference for D_MakeNewWin; Return memory error. If successful call D_MakeNewWin so the driver; can init the window.P_NewDoc	PROC	EXPORT	;Using	P_data	;Using	P_iconData	;Using	P_RulerData	;Using	T_TextEqu	INPUT	MWinPtr:l	ERROR	err	LOCAL	tmp:l,ptr:l,OldWindow:l,refcon:l	BEGIN	+B	movelong	P_CurrentWin,OldWindow	call	P_CheckHand,in=(#$8000:l),err=(err)	jcs	Whoops	call	P_SaveWindowStuff,in=(P_CurrentWin:l)	call	P_InitDoc,in=(MWinPtr:l),out=(RefCon:l),err=(err)	bcs	ToWhoops	moveword	#ArrowCursor,P_Cursor	moverect	P_ArrowRect,P_Palette	moveword	#Black,P_DefColor	call	D_NeedHand,in=(#P_PInfoSize*3:l),out=(tmp:l),err=(err)	bcc	NoErrs	tool	_DisposeHandle,in=(RefCon:l)ToWhoops	brl	WhoopsNoErrs	movelong	[tmp],ptr	ldy	#P_PInfoSize*3-3	lda	#0Zilchloop	sta	[ptr],y	dey	bpl	Zilchloop	movelong	tmp,P_PageArray;	Zeroes	stz	P_FillMode	stz	P_PageMode	stz	P_LockGuides	stz	P_MagGuides	stz	P_ToolType	stz	P_VertGCount	stz	P_HorizGCount	stzl	P_ObjList	stzl	P_LastObj	stzl	P_OrgOffset	stzl	P_PIconRect	stzl	P_PIconRect+4	stz	P_ImportType	stz	P_DblPage	stz	P_UseTemplate	stzl	P_VertGuides	stzl	P_HorizGuides;	Ones	lda	#1	sta	P_LineSize	sta	P_PageCount	sta	P_VisRuler	sta	P_VisPalette	sta	P_VisGuides	sta	P_PageStart	moveword	a,[ptr]:#P_PInfoSize*3-2	moveword	#-1,P_FirstPOff	moveword	#3,P_DefFont	; Geneva	moveword	#0,P_DefStyle	; Plain	moveword	#12,P_DefSize	; 12 Point	moveword	#T_Left,P_DefJust	moveword	#T_Single,P_DefSpacing	call	P_SavePage,in=(#0:w)	call	P_SavePage,in=(#1:w)	moveword	#1,P_UseTemplate	call	P_SavePage,in=(#2:w)	moveword	#2,P_Page	call	P_ShowDoc,in=(MWinPtr:l),err=(err)Whoops	call	P_LoadWindowStuff,in=(OldWindow:l)	RETURN	ENDP*****************************************************************************************************; P_InitDoc ( WindowPtr:long ): RefCon:long;;   This routine will create a window refcon for the given window and call the driver to put our; our refcon in the window structure. Memory errors can be returned. The allocated refcon is ; returned to the caller. The guide counts for the document are also cleared. Current window will be; set to the given window.P_InitDoc	PROC	EXPORT	;Using	P_data	input	window:l	output	refcon:l	error	err	begin; Clear guide counts for the document.	stz	P_AllHGCount	stz	P_AllVGCount; Get refcon handle if successful then call driver to put it in the window structure.	movelong	window,P_CurrentWin	call	D_NeedHand,in=(#P_WinStuffSize:l),out=(refcon:l),err=(err)	bcs	whoops	call	D_SetRefCon,in=(refcon:l,window:l)whoops	return	ENDP;---------------------------------------------------------------------------;; P_ShowDoc   ;P_ShowDoc	PROC	EXPORT	;Using	P_Data	;Using	P_RulerData	INPUT	window:l	ERROR	err	LOCAL	tmp:l,ptr:l	BEGIN	call	D_NeedHand,in=(#4:l),out=(tmp:l),err=(err)	jcs	whoops	movelong	[tmp],ptr	movelong	#0,[ptr]	movelong	tmp,P_AllHGuides	call	D_NeedHand,in=(#4:l),out=(tmp:l),err=(err)	jcs	whoops	movelong	[tmp],ptr	movelong	#0,[ptr]	movelong	tmp,P_AllVGuides	moveword	#P_HRulTop,P_HRulRect	moveword	#P_HRulLeft,P_HRulRect+2	lda	#P_HRulTop+P_HRulWdth	moveword	#P_HRulTop+P_HRulWdth,P_HRulRect+4	moveword	#P_VRulTop,P_VRulRect	moveword	#P_VRulLeft,P_VRulRect+2	moveword	#P_VRulLeft+P_VRulWdth,P_VRulRect+6	stz	P_TrackOn	stzl	P_HScroll	stzl	P_VScroll	stzl	P_ImportHdl	stz	P_Placing	call	D_TodaysDate,out=(P_CurDate:l)	call	P_PrintChanged,in=(window:l)	tool	_SetPort,in=(window:l)whoops	return	ENDP;----------------------------------------------------------------;; P_ActivateDoc (Window:l);; The Frame assures that the menu is as you left it except for; checks, any menu item style change etc. Items are enabled,; disabled, inserted and deleted just as you last saw this document.P_ActivateDoc	PROC	EXPORT	;Using	P_Data	;Using	P_RulerData	;Using	P_AttrData	input	window:l	local	ctl:l,tmprect:r,ptr:l	begin	+b	cmpl	Window,P_CurrentWin	jeq	Exit	call	P_LoadWindowStuff,in=(window:l)	jsl	P_Entry	tool	_GetPortRect,in=(!tmprect:l)	tool	_ClipRect,in=(!tmprect:l)	movelong P_HScroll,ctl	movelong [ctl],ptr	moveword [ptr]:#oCtlHilite,a	and #$FF	bne @hilite			; Draw the controls the first time through.	tool _DrawOneCtl,in=(P_HScroll:l)	; since the controls will be hilighted correctly	tool _DrawOneCtl,in=(P_VScroll:l)	; on the very first activate.	bra @valid@hilite	tool	_HiliteControl,in=(#noHilite:w,P_HScroll:l)	tool	_HiliteControl,in=(#noHilite:w,P_VScroll:l);         ¥ Do this so we don't redraw the controls in a subsequent update.@valid	movelong	[ctl],ptr	moverect	[ptr]:#oCtlRect,tmprect	tool	_ValidRect,in=(!tmprect:l)		movelong	P_VScroll,ctl	movelong	[ctl],ptr	moverect	[ptr]:#oCtlRect,tmprect	tool	_ValidRect,in=(!tmprect:l)	tool	_ClipRect,in=(#P_ContentRect:l)	call	P_FixSpecMenu	call	P_FixMenusExit	return	ENDP;------------------------------------------------------------------------------;; P_DeactivateDoc (Window:l);P_DeactivateDoc	PROC	EXPORT	;Using	P_Data	;Using	T_Data	input	window:l	local	ctl:l,tmprect:r,ptr:l	begin	+b	cmpl	window,P_CurrentWin	bne	ToExit	cpzl	Window	bne	ContToExit	brl	ExitCont	jsl	P_Entry	call	T_Deactivate,in=(#1:w,#0:w)	jsl	P_KillImport	jsl	P_KillUndo	tool	_ClipRect,in=(#P_PortRect:l)	lda	P_TrackOn	beq	Off	call	P_DoScritch,in=(P_OldIdlePt:l)	; Erase scritchesOff	tool	_HiliteControl,in=(#inactiveHilite:w,P_HScroll:l)	tool	_HiliteControl,in=(#inactiveHilite:w,P_VScroll:l)	tool	_ClipRect,in=(#P_ContentRect:l)	stz	P_TrackOn	call	P_SavePage,in=(P_Page:w)	call	P_SaveWindowStuff,in=(window:l)	stzl	P_CurrentWinExit	RETURN	ENDP;------------------------------------------------------------------------------;; P_DisposeDoc (Window:l);; Don't call D_CloseWindow, driver will do it for you.P_DisposeDoc	PROC	EXPORT	;Using	P_Data	INPUT	Window:l	LOCAL	NotActive:w,ActiveWin:l,CurPage:w,StopPage:w	BEGIN	+b	stz	NotActive	cmpl	Window,P_CurrentWin	beq	Okay	inc	NotActive	movelong	P_CurrentWin,ActiveWin	call	P_LoadWindowStuff,in=(Window:l)Okay	call	P_DeactivateDoc,in=(Window:l)	tool	_DisposeControl,in=(P_HScroll:l)	tool	_DisposeControl,in=(P_VScroll:l)	addword	P_PageCount,#1,CurPagePageLoop	call	P_KillPage,in=(CurPage:w,#1:w)	dec	CurPage	bpl	PageLoop	tool	_DisposeHandle,in=(P_PageArray:l)	call	D_GetRefCon,in=(window:l),out=(:l)	_DisposeHandle	tool	_DisposeHandle,in=(P_AllVGuides:l)	tool	_DisposeHandle,in=(P_AllHGuides:l)	lda	NotActive	beq	Exit	call	P_LoadWindowStuff,in=(ActiveWin:l)Exit	RETURN	ENDP;------------------------------------------------------------------------------;; P_KeyDown (TaskRec:l);P_KeyDown	PROC	EXPORT	;Using	P_Data	;Using	P_ObjData	;Using	T_Data	input	TaskRec:l	local	objhdl:l,objptr:l	begin	+b	jsl	P_Entry	lda	T_Editing	beq	DoneText	call	T_Key,in=(TaskRec:l)	bra	ExitDoneText	moveword	[TaskRec]:#oMessage,a	and	#$FF	cmp	#$7F	bne	Exit	call	P_BuildUndo,in=(#P_ClearObjUndo:w)	call	P_DelObjects,in=(#0:w)	jsl	P_FixMenusExit	RETURN	ENDP;-----------------------------------------------------------------------------; The Window was grown. You should use this make any scroll bar; adjustments, updates etc. (Should ;*only** be called if active window); input - window, the one that changed size.;; Notes: ;always* (erase/D_New)'s the horizontal scrollbar.;   only (erase/D_New)'s the vert scrollbar if the window size has changed;   otherwise;; Caveat: this is a hideous piece of code.  The kitchen sink was taken out,;   but everything else is still there.  It is called by anybody;   a general recalc of rulers/scrollbars, etc.;P_GrewDoc	PROC	EXPORT	;Using	P_Data	;Using	P_ICONData	;Using	P_RulerData	;Using	T_Data	input	Window:l	local	tmprect:r,changed:w,tmp:l,vert:w,horz:w	begin	+b	jsl	P_Entry	tool	_GetPortRect,in=(#P_PortRect:l)	tool	_ClipRect,in=(#P_PortRect:l); Use old vert. scrollbar, iff the window size hasn't changed.	subword	P_PortRect+6,#P_ScrollWidth,tmprect+6	subword	P_PortRect+4,#P_ScrollHeight-1,tmprect+4	cmpl	tmprect+4,P_ContentRect+4	bne	Cont	stz	changed	bra	DoHoriz; Erase V ScrollBarCont	moveword	#1,changed	IsNil	P_VScroll	jeq	NewVert	movelong	P_VScroll,tmprect	movelong	[tmprect],tmp	moverect	[tmp]:#oCtlRect,tmprect	moveword	P_GrowRect+4,tmprect+4	tool	_EraseRect,in=(!tmprect:l)	tool	_InvalRect,in=(!tmprect:l)DoHoriz; Erase H scrollbar	IsNil	P_HScroll	beq	NewVert	movelong	P_HScroll,tmp	pushlong	[tmp]	addlong	1:s,#oCtlRect,1:s	pushlong	1:s	_EraseRect	_InvalRect; Old page icons	tool	_EraseRect,in=(#P_PIconRect:l)	tool	_InvalRect,in=(#P_PIconRect:l)NewVertDoInit	moveword	#P_VScrollT,P_VScrTempl	subword	P_PortRect+6,#P_ScrollWidth,P_VScrTempl+2	addword	P_PortRect+6,#2,P_VScrTempl+6	moveword	P_PortRect+4,P_HScrTempl+4	inc	P_HScrTempl+4	subword	P_HScrTempl+4,#P_ScrollHeight,P_HScrTempl	moveword	P_HScrTempl,P_VScrTempl+4	inc	P_VScrTempl+4	addword	P_VScrTempl+2,#2,P_HScrTempl+6; 1 templ page + 2 spaces.	moveword	#P_PageWidth+(2*P_SpaceWidth)-1,P_HScrTempl+2	lda	P_DblPage	beq	DidTempl; 2nd templ page	addword	#P_PageWidth-2,P_HScrTempl+2,P_HScrTempl+2DidTempl	cmpw	P_PageCount,#6	blt	LessThan6; 2 controls	addword	#2*(P_ControlWidth-2),P_HScrTempl+2,P_HScrTempl+2	lda	#5Lessthan6	rcall	D_FastMult,in=(a:x,#P_PageWidth-2:y); 1-5 pages.	ina		; add in 2 Q_Pixels for righthand edge.	ina	addword	a,P_HScrTempl+2,P_HScrTempl+2	tool	_InvalRect,in=(#P_HScrTempl:l)	tool	_InvalRect,in=(#P_VScrTempl:l)	subword	P_PaperRect+4,P_PaperRect,P_VDataSize	subword	P_PaperRect+6,P_PaperRect+2,a	and	#$FFFE	sta	P_HDataSize	moveword	P_H,P_HValue	moveword	P_V,P_VValue	lda	P_PageMode	beq	NormMode	moveword	P_VDataSize,P_VViewSize	; Make scrollbars empty	moveword	P_HDataSize,P_HViewSize	;	bra	DoRulersNormMode	lda	P_VisRuler	bne	VisRulers	moveword	P_HScrTempl,P_VViewSize	subword	P_VScrTempl+2,#P_TabWLeft,a	bra	FixViewVisRulers	subword	P_HScrTempl,#P_TabWBottom,P_VViewSize	subword	P_VScrTempl+2,#P_TabWRight,aFixView	ldy	P_VisPalette	bne	DidPal	addword	a,#P_TabWLeft,aDidPal	and	#$FFFE	sta	P_HViewSizeDoRulers	IsNil	P_HScroll	jeq	NilHScroll; first, check controls for out-of-boundedness.	tool	_GetCtlValue,in=(P_HScroll:l),out=(a:w)	addword	a,P_HViewSize,a	cmp	P_HDataSize	blt	ResizeVert	subword	P_HDataSize,P_HViewSize,P_HValue	bpl	@sta	lda	#0	; origin shouldn't ever go negative@sta	sta	P_H	call	T_ClipThread,in=(T_DotObj:l)	lda	P_PageMode	bne	ResizeVert	tool	_InvalRect,in=(#P_HRulRect:l)	tool	_ClipRect,in=(#P_ContentRect:l)	tool	_EraseRect,in=(#P_ContentRect:l)	call	P_DrawContent,in=(#P_ContentRect:l,#0:w)ResizeVert	tool	_GetCtlValue,in=(P_VScroll:l),out=(a:w)	addword	a,P_VViewSize,a	cmp	P_VDataSize	blt	DidResize	subword	P_VDataSize,P_VViewSize,P_VValue	bpl	@sta	lda	#0	; origin shouldn't ever go negative@sta	sta	P_V	call	T_ClipThread,in=(T_DotObj:l)	lda	P_PageMode	bne	DidResize	tool	_ClipRect,in=(#P_ContentRect:l)	tool	_EraseRect,in=(#P_ContentRect:l)	tool	_InvalRect,in=(#P_VRulRect:l)	call	P_DrawContent,in=(#P_ContentRect:l,#0:w)DidResize	tool	_ClipRect,in=(#P_PortRect:l)	tool	_DisposeControl,in=(P_HScroll:l)NilHScroll	IsNil	P_VScroll	beq	NoVert	lda	changed	beq	NoVert	tool	_DisposeControl,in=(P_VScroll:l)NoVert;	 rulers need to be resized also?	moveword	P_HScrTempl,P_PIconRect	stz	P_PIconRect+2	moveword	P_HScrTempl+4,P_PIconRect+4	moveword	P_HScrTempl+2,P_PIconRect+6	tool	_EraseRect,in=(#P_PIconRect:l)	tool	_InvalRect,in=(#P_PIconRect:l)	tool _ClipRect,in=(#P_PortRect:l)	call D_NewCtl,in=(#P_HScrTempl:l,P_CurrentWin:l),out=(P_HScroll:l)	lda	changed	jeq	exit	call D_NewCtl,in=(#P_VScrTempl:l,P_CurrentWin:l),out=(P_VScroll:l)	addword	P_HScrTempl,#1,P_GrowRect	addword	P_VScrTempl+2,#2,P_GrowRect+2	movelong	P_PortRect+4,P_GrowRect+4	subword	P_GrowRect,#1,P_ContentRect+4	; bottom	subword	P_GrowRect+2,#2,P_ContentRect+6	; right	stz	P_ContentRect+2;	P_ContentRect[2] = visP?TabWL:0 + visR?TabWR-TabWL-1:0;	P_ContentRect[0] =	visR?TabWB:0	lda	P_VisPalette	beq	CkRuler	moveword	#P_TabWLeft-1,P_ContentRect+2	; left (palette vis)CkRuler	lda	P_VisRuler	beq	NoRulers	moveword	#P_TabWBottom,P_ContentRect	addword	P_ContentRect+2,#P_TabWRight-P_TabWLeft,P_ContentRect+2	bra	contRectsNoRulers	stz	P_ContentRectcontRects	moveword	P_ContentRect+4,P_VRulRect+4	moveword	P_ContentRect+6,P_HRulRect+6	moveword	P_ContentRect+2,P_VRulRect+6	sta	P_HRulRect+2	subword	P_ContentRect+2,#P_VRulWdth,P_VRulRect+2	addword	P_ContentRect,#10,P_FullPaperRect	subword	P_ContentRect+4,#10,P_FullPaperRect+4	rcall	D_Deref,in=(P_PrintHand:ax),out=(tmp:ax)	moveword	[tmp]:#$C,vert	moveword	[tmp]:#$E,horz	rcall	D_UnLock,in=(P_PrintHand:ax)	subword	P_FullPaperRect+4,P_FullPaperRect,tmp	tool	_Multiply,in=(horz:w,tmp:w),out=(tmp:l)	in	tmp:l,#0:w,vert:w	out	a:w,a:w,a:w,tmp:w	xtool	_LongDivide;			   tmp is the width of the fullpaperrect	subword	P_ContentRect+6,P_ContentRect+2,a	subword	a,tmp,a	bmi	TooSmall	bra	JustRightTooSmall	addword	P_ContentRect+2,#20,P_FullPaperRect+2	subword	P_ContentRect+6,#20,P_FullPaperRect+6	subword	P_FullPaperRect+6,P_FullPaperRect+2,tmp	tool	_Multiply,in=(vert:w,tmp:w),out=(tmp:l)	in	tmp:l,#0:w,horz:w	out	a:w,a:w,a:w,tmp:w	xtool	_LongDivide	subword	P_ContentRect+4,P_ContentRect,a	subword	a,tmp,a	lsr	a	addword	a,P_ContentRect,P_FullPaperRect	addword	tmp,P_FullPaperRect,P_FullPaperRect+4	bra	GotFullJustRight	lsr	a	addword	a,P_ContentRect+2,P_FullPaperRect+2	addword	tmp,P_FullPaperRect+2,P_FullPaperRect+6;	PageRect : FullPageRect :: PaperRect : FullPaperRectGotFull	moverect	P_PageRect,P_FullPageRect	in	#P_FullPageRect:l,#P_PaperRect:l,#P_FullPaperRect:l	xtool	_MapRect	tool	_InvalRect,in=(#P_GrowRect:l)	lda	P_PageMode	beq	exit	movelong	P_ContentRect,tmprect	moveword	#200,tmprect+4	moveword	#640,tmprect+6	tool	_EraseRect,in=(!tmprect:l)	stz	tmprect	moveword	#P_VRulLeft,tmprect+2	tool	_InvalRect,in=(!tmprect:l)exit	tool	_ClipRect,in=(#P_ContentRect:l)	call	T_ClipThread,in=(T_DotObj:l)	call	P_ForceUpdate,in=(Window:l)	return	ENDP;-------------------------------------------------------------------------------;; P_IdleProc (InMyWin:w,RectPtr:l,PtPtr:l,Time:l);; input	- InMyWin	boolean, is the D_Cursor over my active window;	- RectPtr	pointer to your the Port Q_Rect of the active window;	- PtPtr	pointer to the current (local) Q_Point that the D_Cursor is over;	- Time	The current TickCountP_IdleProc	PROC	EXPORT	;Using	P_RulerData	;Using	P_Data	;Using	T_Data	input	InMyWin:w,RectPtr:l,PtPtr:l,Time:l	begin	+b;	Don't check InMyWin, because we want to erase scritch marks;	when the D_Cursor goes outside the window.	IsNil	P_CurrentWin	beq	Exit	; He hasn't activated the window yet.	jsl	P_Entry	lda	T_Editing	beq	DoTrack	call	T_Idle,in=(Time:l)DoTrack	call	P_TrackCursor,in=(PtPtr:l)Exit	RETURN	ENDP;------------------------------------------------------------------------------;; P_PrintChanged (Window:l);P_PrintChanged	PROC	EXPORT	;Using	P_DATA	;Using	P_RulerData	input	window:l	local	tmp:l,tmprect:l,oldwin:l	begin	+b	movelong	P_CurrentWin,oldwin	call	P_LoadWindowStuff,in=(Window:l)	jsl	P_Entry	call	D_GetPrintHandle,in=(window:l),out=(P_PrintHand:l)	rcall	D_Deref,in=(P_PrintHand:ax),out=(tmp:ax)	moverect	[tmp]:#oPrInfo+oRPage,P_PageRect	moverect	[tmp]:#oRPaper,P_PaperRect	rcall	D_UnLock,in=(P_PrintHand:ax)	pushlong	#P_PageRect	subword	#0,P_PaperRect+2,s	subword	#0,P_PaperRect,s	pushlong	#P_PaperRect	pushlong	5:s	_OffsetRect	_OffsetRect	IsNil	P_ContentRect	beq	NotThere	tool	_EraseRect,in=(#P_ContentRect:l)NotThere	stzl	P_contentRect	stzl	P_Contentrect+4	tool	_GetPortRect,in=(#P_PortRect:l)	moverect	P_PortRect,tmprect	moveword	P_VRulRect+2,tmprect+2	tool	_InvalRect,in=(!tmprect:l)	call	P_GrewDoc,in=(window:l)	call	P_LoadWindowStuff,in=(OldWin:l)Exit	RETURN	ENDP;---------------------------------------------------------------------------;; P_Message (Type:w,Message:l) : Answer:l;P_Message	PROC	EXPORT	input	Type:w,Message:l	output	answer:l	error	Err	begin	stz	Err	return	ENDP;---------------------------------------------------------------------------;; P_LoadMod ()  ;P_LoadMod	PROC	EXPORT	;Using	T_Data	;Using	D_GlobalData	error	Err	local	Hdl:l	begin +b	call	X_GetPLSCRAPAddr,out=(a:l),err=(Err)	jcs	Exit	call	D_LoadSegment,in=(#segPL2:w,#4:w),out=(a:l),err=(Err)	jcs	Exit	call	D_LoadSegment,in=(#segWPIO:w,#4:w),out=(ax:l),err=err	bcc	@loadAscii@unloadPL2	call	D_UnloadSegment,in=(#segPL2:w,#4:w)	brl	exit@loadAscii	call	D_LoadSegment,in=(#segTOStatText:w,#4:w),out=(ax:l),err=err	bcc	gotsegs	call	D_UnloadSegment,in=(#segWPIO:w,#4:w)	bra	@unloadPL2gotsegs; Allocate the port used for scaling text	call	D_NeedHandle,in=(#$AA:l,#$4010:w),out=(Hdl:l),err=(Err)	bcs	Exit	movelong	[Hdl],T_ScalePort	tool	_OpenPort,in=(T_ScalePort:l),err=(Err)	bcs	DoErr	movelong	>D_BitMapPtr,T_ScaleLocInfo+2	tool	_SetPortLoc,in=(#T_ScaleLocInfo:l)	tool	_SetTextMode,in=(#ModeForeCopy:w)	tool	_SetFontFlags,in=(#4:w)Exit	returnDoErr	tool	_DisposeHandle,in=(Hdl:l)	bra	Exit	ENDP;---------------------------------------------------------------------------;; P_UnloadMod ();P_UnloadMod	PROC	EXPORT	;Using	T_Data	;Using	X_ClipData	;Using	P_ScrapData	begin +b	cpzl	T_ScalePort	beq	DoUnload	tool	_ClosePort,in=(T_ScalePort:l)	call	D_DisposePtr,in=(T_ScalePort:l)	cmpw	>X_ScrapType,#PLPICT	bne	DoUnload	in	>X_ScrapRefCon:l	out	>P_QDPict:l	xerr	>P_ConvErr	xcall	P_MakePictDoUnload	call	D_UnloadSegment,in=(#segPL2:w,#4:w)	call	D_UnloadSegment,in=(#segWPIO:w,#4:w)	call	D_UnloadSegment,in=(#segTOStatText:w,#4:w)Exit	return	ENDP;---------------------------------------------------------------------------; This will be called when memory is needed. You should make purgeable; any handle not needed.; This call WILL change as this project progresses.P_MakeRoom	PROC	EXPORT	input	Window:l	begin	return	ENDP;---------------------------------------------------------------------------;; P_UnlockMem ();P_UnlockMem	PROC	EXPORT	input	Window:l	begin	return	ENDP;---------------------------------------------------------------------------;; P_RelockMem  ();P_RelockMem	PROC	EXPORT	input	Window:l	begin	return	ENDP	END