	load 'macros.dump'	include 'driver.equ'	include 'pl.equ';-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	D_AlertBox	IMPORT	D_CloseDialog	IMPORT	D_CurCursor	IMPORT	D_Deref	IMPORT	D_DigitsOnly	IMPORT	D_DrawIcon	IMPORT	D_FastMult	IMPORT	D_GetNewModalDialog	IMPORT	D_GrowHandle	IMPORT	D_NeedHand	IMPORT	D_NeedHandle	IMPORT	D_Newhandle	IMPORT	D_SetCursor	IMPORT	D_StrPos	IMPORT	D_UnLock	IMPORT	D_UseStdColors;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	DrawCurs1	ENTRY	DrawCursors	ENTRY	OldHeight	ENTRY	P_DTabPc	ENTRY	P_InsertData	ENTRY	P_NothingPc	ENTRY	P_TabTable;--------------------------------------------------------------------------------;; P_ErrorAlert (Kind:w);P_ErrorAlert	PROC		EXPORT		INPUT Kind:w		LOCAL Ptr:l		BEGIN +B		lda Kind		asl a		asl a		addlong a,#StrTable,Ptr				jsl	D_UseStdColors		call D_AlertBox,in=(#OKBOX:w,[Ptr]:l),out=(a:w)		RETURNNoPaste	str  'Cannot import/paste more than 2500 paragraphs.'_NoEdit	str  'There is not enough memory to edit text.'BadData	str  'This file has been damaged and is unusable.'BadVersion	str  'Cannot open. The file format has changed.'StrTable	DC.L	NoPaste	DC.L	_NoEdit	DC.L	BadData	DC.L	BadVersion		ENDP;-------------------------------------------------------------------------------;; P_CheckHand (HowMuch:l);; Check to see if a handle this size can be allocated.P_CheckHand	PROC		EXPORT				INPUT HowMuch:l			ERROR Err				BEGIN			spacelong			pushlong HowMuch			jsl D_NeedHand			sta Err			bcc	killit			pla			pla			bra	exit		killit		_DisposeHandleexit		RETURN			ENDP;-------------------------------------------------------------------------------;; P_MustHandle (HowMuch:l,Attr:w) : Hdl:l;; Allocate a handle any way possible.;P_MustHandle	PROC		EXPORT;;		INPUT  HowMuch:l,Attr:w;		OUTPUT Hdl:l;;		BEGIN;;		call D_NeedHandle,in=(HowMuch:l,Attr:w),out=(Hdl:l);		bcc Exit;;		call D_Newhandle,in=(HowMuch:l,Attr:w),out=(Hdl:l);;Exit	RETURN;		ENDP;---------------------------------------------------------------------------;; P_Traverse  (Hdl:l,value:w,size:w,count:w),out=(offset:w);;		   linear search (wordsized) for an insertion point in arrayP_Traverse	PROC		EXPORT		local Ptr:l		input Hdl:l,value:w,size:w,count:w		output offset:w		begin		rcall D_FastMult,in=(size:x,count:y),out=(count:a)		movelong [Hdl],Ptr		ldy #0Loop	cpy count		bge done		scmpw [Ptr]:y,value		bge done		addword y,size,y		bra Loopdone	sty offset		return		ENDP; еее Dead Code;---------------------------------------------------------------------------;; P_LTraverse  (Hdl:l,value:l,size:w,count:w),out=(offset:w);;		   linear search for a long in array, returns -1 if not found.;;		   NOTE that this is slightly different from P_Traverse.;;P_LTraverse	PROC		EXPORT;		local Ptr:l;		input Hdl:l,value:l,size:w,count:w;		output offset:w;		begin;;		rcall D_FastMult,in=(size:x,count:y),out=(count:a);;		movelong [Hdl],Ptr;;		stz offset;Loop	cmpw offset,count;		bge notthere;		cmpl [Ptr]:offset,value;		beq done;		addword offset,size,offset;		bra Loop;;notthere	moveword #-1,offset;done	return;		ENDP;---------------------------------------------------------------------------;; P_FindGuide  (Hdl:l,Count:w,Value:w,Diff:w,ftype:w)  Offset:w,NewVal:w,Type:w;;		   diff is the # of Q_Pixels away you can be;		   ftype is the type of guide you want to find.  use -1 for any.P_FindGuide	PROC		EXPORT		input Hdl:l,Count:w,Value:w,Diff:w,ftype:w		output Offset:w,Newval:w,Type:w		local Ptr:l,min:w,max:w		begin		IsNil Hdl		beq notthere		addword value,diff,a		inc a		sta max		subword value,diff,min		rcall D_FastMult,in=(#4:x,count:y),out=(count:a)		movelong [Hdl],Ptr		stz offsetLoop	cmpw offset,count		bge notthere		moveword [Ptr]:offset,newval		iny		iny		moveword [Ptr]:y,type		scmpw newval,min		blt cont		scmpw newval,max		bge notthere		; found one.		lda ftype		bmi done		iny		iny		cmp [ptr],y		bne cont		bra donecont	addword offset,#4,offset		bra Loopnotthere	moveword #-1,offset		moveword value,newvaldone	return		ENDP; еее Dead Code;;---------------------------------------------------------------------------;;;; P_DoInsert  ;;;;		   stick a long into an var-array of longs;;P_DoInsert	PROC		EXPORT;		input Hdl:l,offset:w,item:l,current:w;		local ptr:l;		error err;		begin;;		call P_InsertData,in=(Hdl:l,offset:w,#1:w,#4:w,current:w),err=(err);		movelong [Hdl],ptr;		ldy offset;		movelong item,[ptr]:y;;		return;		ENDP;---------------------------------------------------------------------------;; P_Merge   merge 2 arrays of long into a 3rd array;P_Merge	PROC		EXPORT		input Hdl1:l,Hdl2:l,Hdl3:l,size1:w,size2:w		output size3:w		local ptr1:l,ptr2:l,ptr3:l		local offset1:w,offset2:w,offset3:w		error err		begin		stz err		cmpl Hdl1,Hdl2		bne NotTemplate		stz size1		   ; D_Ignore the 'template' passed in.NotTemplate	addword size1,size2,size3		asl size3		asl size3		jeq exit		call D_GrowHandle,in=(#0:w,size3:w,Hdl3:l),err=(err)		jcs exit		IsNil Hdl1		beq No1		rcall D_Deref,in=(Hdl1:ax),out=(ptr1:ax)		asl size1		asl size1		bra Try2No1	stz size1Try2	IsNil Hdl2		beq No2		rcall D_Deref,in=(Hdl2:ax),out=(ptr2:ax)		asl size2		asl size2		bra Do3No2	stz size2Do3	rcall D_Deref,in=(Hdl3:ax),out=(ptr3:ax)		stz offset1		stz offset2		stz offset3loop	cmpw offset1,size1		bge DoSecond		cmpw offset2,size2		bge DoFirst		cmpw [ptr1]:offset1,[ptr2]:offset2		bgt DoSecond;		   blt DoFirst;		 ; They're equal, so...;		   movelong [ptr1]:offset1,[ptr3]:offset3;		   addword offset1,#4,offset1;		   addword offset2,#4,offset2;		   bra continueDoFirst	movelong [ptr1]:offset1,[ptr3]:offset3		addword offset1,#4,offset1		bra continueDoSecond	movelong [ptr2]:offset2,[ptr3]:offset3		addword offset2,#4,offset2continue	addword offset3,#4,offset3		cmp size3		jlt loop		IsNil Hdl1		beq Unlock2		rcall D_UnLock,in=(Hdl1:ax)Unlock2	IsNIl Hdl2		beq Unlock3		rcall D_UnLock,in=(Hdl2:ax)Unlock3	rcall D_UnLock,in=(Hdl3:ax)exit	lsr size3		lsr size3		return		ENDP;------------------------------------------------------------------------------;; P_InsertData (Hdl:l, Offset:w, items:w, UnitSize:w, Count:w) : memory errs.;					  ^bytes	^insert			  ^current;;		   NOTE: Hdl must already exist & be non-nilP_InsertData	PROC		EXPORT		INPUT Hdl:l,offset:w,items:w,UnitSize:w,Count:w		LOCAL Size:l,Increase:l,Src:l,off:l,tmp:l		error err		BEGIN		stz err		moveword offset,off		stz off+2		tool _Multiply,in=(Count:w,UnitSize:w),out=(Size:l)		tool _Multiply,in=(items:w,UnitSize:w),out=(Increase:l)		addlong Size,Increase,tmp		IsNil tmp		beq exit		call D_GrowHandle,in=(tmp:l,Hdl:l),err=(err)		bcs exit		addlong off,[Hdl],Src		pushlong Src		addlong Src,Increase,s		sublong Size,off,s		_BlockMoveexit	RETURN		ENDP;------------------------------------------------------------------------------;; P_DeleteData (Hdl:l, offset:w, items:w, UnitSize:w, Count:w) : memory errs;P_DeleteData	PROC		EXPORT		INPUT Hdl:l,offset:w,items:w,UnitSize:w,Count:w		LOCAL Size:l,Decrease:l,DestOffset:l,Dest:l,temp:l,off:l		error err		BEGIN		stz err		moveword offset,off		stz off+2		tool _Multiply,in=(UnitSize:w,Count:w),out=(Size:l)		tool _Multiply,in=(items:w,UnitSize:w),out=(Decrease:l)		addlong [Hdl],off,Dest		addlong Dest,Decrease,s		pushlong Dest		sublong Size,off,temp		sublong temp,Decrease,s		_BlockMove		sublong Size,Decrease,off		IsNil off		beq exit		call D_GrowHandle,in=(off:l,Hdl:l),err=(err)exit	RETURN		ENDP;---------------------------------------------------------------------------;; Fix2Asc	 ;;		   converts fixedpoint to ascii, with 2 decimal places;		   assumes str is long enough to accomodate.;;		   doesn't work right for small negative numbers: -1 <= x < 0;;		   limits string to 4 characters.  E.g., '1.24'Fix2Asc	PROC		EXPORT		input value:l,str:l		local neg:w,fill:r,tmpstr:w,tmpval:l,tmp:l		local offset:w,length:w		begin		moveword value,tmpval		stz tmpval+2		stz neg		lda value+2		asl a		bcc NotNeg		inc neg		inc value+2NotNeg		tool _Int2Dec,in=(value+2:w,!tmpstr:l,#6:w,#1:w)		moveword #$2E,tmpstr+6			;	the character ╥.╙		lda neg		beq NotNeg2		sublong #$00010000,tmpval,tmp		movelong tmp,tmpvalNotNeg2	tool _FixMul,in=(#0:w,#100:w,tmpval:l),out=(tmpval:l)		tool _Int2Dec,in=(tmpval:w,!tmpstr+7:l,#2:w,#0:w)		; convert any spaces to zeroes.		short		lda tmpstr+7		cmp #' '		bne Ck2nd		lda #'0'		sta tmpstr+7Ck2nd	lda tmpstr+8		cmp #' '		bne DidZeroes		lda #'0'		sta tmpstr+8DidZeroes	long		moveword #9,length		movelong !tmpstr,tmp		stz offsetD_EatBlanks	moveword [tmp]:offset,a		and #$FF		cmp #' '		bne GotIt		dec length		inc offset		bra D_EatBlanksGotIt	cmpw length,#5		blt GotLen		moveword #4,lengthGotLen	lda offset		addlong a,tmp,s		addlong str,#1,s		pushlongword length		_BlockMove		lda [str]		and #$FF00		ora length		sta [str]		return		ENDP;---------------------------------------------------------------------------;; P_AddGuide ;;		   rulerguides = 0, col guides = 1, margin guides = 2P_AddGuide	PROC		EXPORT		input pos:w,array:l,count:w,type:w		output newcount:w		local tmp:l,ptr:l		error err		begin		moveword count,newcount		call P_Traverse,in=(array:l,pos:w,#4:w,count:w),out=(tmp:w)		call P_InsertData,in=(array:l,tmp:w,#1:w,#4:w,count:w),err=(err)		rcall D_Deref,in=(array:ax),out=(ptr:ax)		jcs whoops		moveword pos,[ptr]:tmp		iny		iny		moveword type,[ptr]:y		rcall D_UnLock,in=(array:ax)		inc newcountwhoops	return		ENDP;---------------------------------------------------------------------------;; P_ExplodeGuide ;P_ExplodeGuide	PROC		EXPORT		input arrayhdl:l,count:w,val:w,type:w,dir:w		output newval:w		local offset:w,ptr:l,max:w		error err		begin		moveword #1,err		lda count		asl a		asl a		sta max		call P_Traverse,in=(arrayhdl:l,val:w,#4:w,count:w),out=(offset:w)		movelong [arrayhdl],ptr		lda dir		bpl SearchFSearchR	lda offset		beq quit		subword offset,#4,offset		moveword [ptr]:offset,newval		lda type		bmi exit		iny		iny		cmpw [ptr]:y,type		bne SearchR		bra exitSearchF	cmpw offset,max		beq quit		moveword [ptr]:offset,newval		lda type		bmi exit		iny		iny		cmpw [ptr]:y,type		beq exit		addword offset,#4,offset		bra SearchFexit	stz errquit	return		ENDP;---------------------------------------------------------------------------;; P_DrawATab;;;		   newpt of -1,-1 says to erase the old, period.;;		   newpt == oldpt says to XOR over the old, then XOR the D_New.;;		   oldpt == -1,-1 says just draw it, as if in an D_Update.;;		   need to clip as necessary before calling this.;		   Coordinates are in WINDOW local -- not offset nor scaled.;P_DrawATab	PROC		EXPORT			;Using P_Data			;Using P_RulerData			;Using P_TabIcons		input oldpt:l,newpt:l,type:w		local iconptr:l,tmp:w		begin +b		lda type		inc a		asl a		asl a		addlong a,#P_TabTable,iconptr		_PenNormal		cmpl newpt,#-1		bne cont		; Totally erase the old		subword oldpt+2,#4,oldpt+2		call D_DrawIcon,in=(#P_NothingPc:l,oldpt:l,#modeCopy:w)		bra exit		; UnDraw the old first...cont	cmpl oldpt,#-1		beq DrawNew		subword oldpt+2,#4,tmp		call D_DrawIcon,in=([iconptr]:l,tmp:w,oldpt:w,#notXOR:w)		; Now the D_New...DrawNew	cmpl newpt,oldpt		bne DrawIt		; Really place it.PlaceIt	subword newpt+2,#4,newpt+2		call D_DrawIcon,in=([iconptr]:l,newpt:l,#notBIC:w)		bra exitDrawIt	cmpl OldPt,#-1		beq PlaceIt		subword newpt+2,#4,newpt+2		call D_DrawIcon,in=([iconptr]:l,newpt:l,#notXOR:w)exit	return		ENDP;---------------------------------------------------------------------------;; P_TabIcons  ;P_TabIcons	PROC		EXPORT		EXPORT	P_TabTable		EXPORT	P_IndentPc		EXPORT	P_LTabPc		EXPORT	P_DTabPc		EXPORT	P_RTabPc		EXPORT	P_NothingPcP_TabTable	DC.L	P_DTabPc,P_LTabPc,P_RTabPc,P_IndentPcP_IndentPc	DC.W	0,0,5,10	DC.B	$ff,$4f,$ff	DC.B	$ff,$4f,$ff	DC.B	$ff,$4f,$ff	DC.B	$f4,$44,$ff	DC.B	$44,$44,$4fP_LTabPc	DC.W	0,0,5,10	DC.B	$ff,$4f,$ff	DC.B	$ff,$44,$ff	DC.B	$ff,$44,$4f	DC.B	$ff,$44,$ff	DC.B	$ff,$4f,$ffP_DTabPc	DC.W	0,0,5,10	DC.B	$ff,$4f,$ff	DC.B	$f4,$44,$ff	DC.B	$f4,$f4,$ff	DC.B	$f4,$44,$ff	DC.B	$ff,$4f,$ffP_RTabPc	DC.W	0,0,5,10	DC.B	$ff,$4f,$ff	DC.B	$f4,$4f,$ff	DC.B	$44,$4f,$ff	DC.B	$f4,$4f,$ff	DC.B	$ff,$4f,$ffP_NothingPc	DC.W	0,0,5,14	DC.B	$ee,$ee,$ee,$ee	DC.B	$ee,$ee,$ee,$ee	DC.B	$ee,$ee,$ee,$ee	DC.B	$ee,$ee,$ee,$ee	DC.B	$ee,$ee,$ee,$ee		ENDP;---------------------------------------------------------------------------;; P_DoSpacingDlog ;P_DoSpacingDlog	PROC		EXPORT		input default:w		output height:w		local TheDlog:l,result:w,pagetext:l		begin		tool _Int2Dec,in=(default:w,#P_Height+1:l,#2:w,#0:w)		jsl	D_UseStdColors		call D_GetNewModalDialog,in=(#P_SetLHDlog:l),out=(TheDlog:l)DlogLoop	tool _ModalDialog,in=(#D_DigitsOnly+$80000000:l),out=(result:w)		cmp #OK		beq DoneDlog		cmp #Cancel		beq DoneDlog		bra DlogLoopDoneDlog	tool _GetIText,in=(TheDlog:l,#4:w,!pagetext:l)		lda pagetext		and #$00FF		bne CkValid		moveword #Cancel,result		bra QuitDlogCkValid	tax		tool _Dec2Int,in=(!pagetext+1:l,x:w,#0:w),out=(height:w)		bcs Oops		cmpw height,#4		bge CheckMax		lda #4CheckMax	cmp #65		blt GotHeight		lda #64GotHeight	sta height		bra QuitDlogOops	moveword #Cancel,resultQuitDlog	call D_CloseDialog,in=(TheDlog:l)		cmpw result,#OK		beq exit		stz heightexit	return;---------------------------------------------------------------------------; Set Line Height Dialog;;		   1 = OK;		   2 = Cancel;		   3 = "Set Q_Line Height';		   4 = Q_Line HeightP_SetLHDlog	DC.W	48,185,101,462	DC.W	1	DC.L	0	DC.L	P_LHOK,P_LHCancel,P_SetLHCnt,P_SetLHText	DC.L	0P_LHOK	DC.W	1	DC.W	34,160,47,230	DC.W	$000A	DC.L	OKTxt	DC.W	0	DC.W	0	DC.L	0OKTxt	STR 'OK'P_LHCancel	DC.W	2	DC.W	34,40,47,110	DC.W	$000A	DC.L	CancelTxt	DC.W	0	DC.W	0	DC.L	0CancelTxt	STR 'Cancel'P_SetLHText	DC.W	3	DC.W	10,40,23,161	DC.W	$800F	DC.L	P_SetLHTextMsg	DC.W	0	DC.W	0	DC.L	0P_SetLHTextMsg	STR 'Set line height'P_SetLHCnt	DC.W	4	DC.W	8,165,21,203	DC.W	$8011	DC.L	P_Height	DC.W	3	DC.W	0	DC.W	0P_Height	STR '99'		ENDP;---------------------------------------------------------------------------;; Asc2Fix	 ;Asc2Fix	PROC		EXPORT		input strptr:l		output value:l		local tmp:l,len:w,fraclen:w,divisor:w,decpos:w		error err		begin		moveword #1,err		stzl value		lda [strptr]		and #$FF		sta len		jeq exit		; find the period		moveword #$2E01,tmp			 ;  == '.'		call D_StrPos,in=(!tmp:l,strptr:l,#1:w),out=(decpos:w)		bmi DoInt		; calculate the fraction		cmpw decpos,len		beq DoInt		spaceword		ina		addlong a,strptr,s		subword len,decpos,fraclen		pha		pushword #0		_Dec2Int		sta err		pullword value		bcs exit		; Convert from decimal to binary fraction		moveword #10,divisorDecLoop	dec fraclen		beq DidDec		rcall D_FastMult,in=(divisor:x,#10:y),out=(divisor:a)		bra DecLoopDidDec	tool _FixRatio,in=(value:w,divisor:w),out=(value:l)		; calculate the integerDoInt	lda decpos		bpl GotOff		addword #1,len,decposGotOff	stz err		subword decpos,#1,tmp		beq exit		addwl #1,strptr		tool _Dec2Int,in=(strptr:l,tmp:w,#0:w),out=(value+2:w),err=(err)exit	return		ENDP;---------------------------------------------------------------------------;; P_GetModifiers():w;;		   returns a modifier word as per the event mgr.;P_GetModifiers	PROC		EXPORT		output mods:w		local	modifiers:w,where:l,when:l,message:l,event:w		begin		tool _GetNextEvent,in=(#0:w,!event:l),out=(a:w)		moveword modifiers,mods				return		ENDP;---------------------------------------------------------------------------;; P_SetCursor (_cursor:w,width:w);P_SetCursor	PROC		EXPORT			;Using P_Cursors			;Using CursorData		input _cursor:w,width:w		local ptr:l		begin +b		lda _cursor		bpl NotDraw		movelong #DrawCursors,ptr		cmpw _cursor,>D_CurCursor		bne SetIt		cmpw Width,OldHeight		beq ExitSetIt		lda Width		sta OldHeight		dec a		asl a		asl a		tay		tool _SetCursor,in=([ptr]:y:l)Exit		call D_SetCursor,in=(_cursor:w)		RETURNNotDraw	stz OldHeight		bra exit		ENDPP_Cursors	PROC		EXPORT		EXPORT	OldHeight		EXPORT	DrawCursors		EXPORT	DrawCurs1		EXPORT	DrawCurs2		EXPORT	DrawCurs3		EXPORT	DrawCurs4		EXPORT	DrawCurs5OldHeight		DS.B 2DrawCursors	DC.L	DrawCurs1,DrawCurs2,DrawCurs3,DrawCurs4,DrawCurs5DrawCurs1	DC.W	9	;Slices	DC.W	4	;words / slice	DC.B	$00,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$00,$00,$00,$00	DC.B	$ff,$ff,$ff,$ff,$f0,$00,$00,$00	DC.B	$00,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.W	4	;Hot Y	DC.W	8	;Hot XDrawCurs2	DC.W	10	;Slices	DC.W	4	;words / slice	DC.B	$00,$00,$ff,$00,$00,$00,$00,$00	DC.B	$00,$00,$ff,$00,$00,$00,$00,$00	DC.B	$00,$00,$ff,$00,$00,$00,$00,$00	DC.B	$00,$00,$ff,$00,$00,$00,$00,$00	DC.B	$ff,$ff,$ff,$ff,$ff,$00,$00,$00	DC.B	$ff,$ff,$ff,$ff,$ff,$00,$00,$00	DC.B	$00,$00,$ff,$00,$00,$00,$00,$00	DC.B	$00,$00,$ff,$00,$00,$00,$00,$00	DC.B	$00,$00,$ff,$00,$00,$00,$00,$00	DC.B	$00,$00,$ff,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.W	4	;Hot Y	DC.W	8	;Hot XDrawCurs3	DC.W	11	;Slices	DC.W	4	;words / slice	DC.B	$00,$00,$ff,$f0,$00,$00,$00,$00	DC.B	$00,$00,$f0,$f0,$00,$00,$00,$00	DC.B	$00,$00,$f0,$f0,$00,$00,$00,$00	DC.B	$00,$00,$f0,$f0,$00,$00,$00,$00	DC.B	$ff,$ff,$ff,$ff,$ff,$f0,$00,$00	DC.B	$f0,$00,$f0,$f0,$00,$f0,$00,$00	DC.B	$ff,$ff,$ff,$ff,$ff,$f0,$00,$00	DC.B	$00,$00,$f0,$f0,$00,$00,$00,$00	DC.B	$00,$00,$f0,$f0,$00,$00,$00,$00	DC.B	$00,$00,$f0,$f0,$00,$00,$00,$00	DC.B	$00,$00,$ff,$f0,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.W	4	;Hot Y	DC.W	8	;Hot XDrawCurs4	DC.W	12	;Slices	DC.W	4	;words / slice	DC.B	$00,$00,$ff,$ff,$00,$00,$00,$00	DC.B	$00,$00,$f0,$0f,$00,$00,$00,$00	DC.B	$00,$00,$f0,$0f,$00,$00,$00,$00	DC.B	$00,$00,$f0,$0f,$00,$00,$00,$00	DC.B	$ff,$ff,$ff,$ff,$ff,$ff,$00,$00	DC.B	$f0,$00,$f0,$0f,$00,$0f,$00,$00	DC.B	$f0,$00,$f0,$0f,$00,$0f,$00,$00	DC.B	$ff,$ff,$ff,$ff,$ff,$ff,$00,$00	DC.B	$00,$00,$f0,$0f,$00,$00,$00,$00	DC.B	$00,$00,$f0,$0f,$00,$00,$00,$00	DC.B	$00,$00,$f0,$0f,$00,$00,$00,$00	DC.B	$00,$00,$ff,$ff,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00	DC.W	4	;Hot Y	DC.W	8	;Hot XDrawCurs5	DC.W	13	;Slices	DC.W	5	;words / slice	DC.B	$00,$00,$ff,$ff,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$f0,$00,$00,$00,$00,$00	DC.B	$ff,$ff,$ff,$ff,$ff,$ff,$f0,$00,$00,$00	DC.B	$f0,$00,$f0,$00,$f0,$00,$f0,$00,$00,$00	DC.B	$f0,$00,$f0,$00,$f0,$00,$f0,$00,$00,$00	DC.B	$f0,$00,$f0,$00,$f0,$00,$f0,$00,$00,$00	DC.B	$ff,$ff,$ff,$ff,$ff,$ff,$f0,$00,$00,$00	DC.B	$00,$00,$f0,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$f0,$00,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$ff,$ff,$f0,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.B	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00	DC.W	4	;Hot Y	DC.W	8	;Hot X		ENDP		END