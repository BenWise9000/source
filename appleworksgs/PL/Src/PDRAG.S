	load 'macros.dump'	include 'driver.equ'	include 'pl.equ';-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	D_Deref	IMPORT	D_NeedHand	IMPORT	P_AddGuide	IMPORT	P_ContentRect	IMPORT	P_FixPt	IMPORT	P_H	IMPORT	P_PageMode	IMPORT	P_RoundGuide	IMPORT	P_Traverse	IMPORT	P_V	IMPORT	D_UnLock	IMPORT	P_PaperRect	IMPORT	P_FullPaperRect;		   pdrag.s;		   Notes for D_DrawProc:;		   newpt of -1,-1 says to get rid of the old drawing & nothing else;		   newpt == oldpt says to get rid of old, then redraw it for real.;		   need to clip as necessary.;---------------------------------------------------------------------------;; P_DragStuff (OldPt:l,		 starting D_MouseDown Q_Point;			  Array:l,		 array HANDLE of guides/tabs;			  Count:w,		 Number of items currently in array.;			  D_DrawProc:l,	  procedure/function to draw tab/guide;			  TabType:w,	   L/D/R;			  Vert:w,		  Vertical Guide?;			  Max:w,		   Maximum pixel position for valid whatever;			  Min:w,		   Minimum   '	   '	 '	'	   ";			  Erase:w		  Erase an old whatever first?;;	---->  NewCount, NewArrayHdl, NewPtP_DragStuff	PROC		EXPORT			;Using P_Data		local adjpt:l,hoffset:w,voffset:w		local newpt:l,tmp:l,ptr:l,ppi:l		input oldpt:l,count:w,array:l,D_DrawProc:l,tabtype:w		input vert:w,max:w,min:w,dist:w,erase:w		output newcount:w,amt:w		error err		begin		stz err		lda oldpt+2		and #$FFFE		sta oldpt+2		moveaddr D_DrawProc,DrawIt+1		  ; patch in the functional		moveaddr D_DrawProc,DrawIt2+1		 ; parameter.		moveaddr D_DrawProc,DrawIt3+1		subword P_V,P_ContentRect,voffset   ; correct for		subword P_H,P_ContentRect+2,a	   ; scrolled-over-ness		and #$FFFE						  ; make sure it's even		sta hoffset						 ; pixelized, to be safe...		lda vert		bne VertMaxMin		moveword max,newpt		jsr AdjustPt		moveword amt,max		moveword min,newpt		jsr AdjustPt		moveword amt,min		bra DidMaxMinVertMaxMin	moveword max,newpt+2		jsr AdjustPt		moveword amt,max		moveword min,newpt+2		jsr AdjustPt		moveword amt,minDidMaxMin		lda count		beq StartDrag		rcall D_Deref,in=(array:ax),out=(ptr:ax)StartDrag	lda erase		beq DragLoop		movelong #-1,newpt		brl OKDrawDragLoop	tool _GetMouse,in=(!newpt:l)		lda newpt+2		and #$FFFE		sta newpt+2		lda vert								; Only redraw		beq HorizCmp							; when vertical		cmpw oldpt+2,newpt+2					; or horizontal		jeq ContLoop							; changes, as		bra DoneCmp							 ; is appropriateHorizCmp	cmpw oldpt,newpt						;	   .		jeq ContLoop							;	   :DoneCmp	jsr AdjustPt		; Check to see if it is too D_Close to another one...		lda count		beq OKDraw		call P_Traverse,in=(array:l,amt:w,#4:w,count:w),out=(tmp:w)		lsr a		lsr a		cmp count		bge CheckLesser		addword amt,dist,a		scmpw a,[ptr]:tmp		bge DontMoveCheckLesser	subword amt,dist,y		subword tmp,#4,tmp		bmi OKDraw		tya		scmpw a,[ptr]:tmp		ble DontMoveOKDraw	pushlong oldpt		pushlong newpt		pushword tabtype		pushword vertDrawIt	jsl *		bra ContLoopDontMove	movelong oldpt,newpt		bra CheckDownContLoop	movelong newpt,oldptCheckDown	tool _StillDown,in=(#0:w),out=(a:w)		jne DragLoopPutDown	movelong newpt,oldpt		jsr AdjustPt		scmpw amt,min		jlt NoDice		scmpw max,amt		jlt NoDice		lda count		beq NeedNew		rcall D_UnLock,in=(array:ax)		bra UnlockedNeedNew	call D_NeedHand,in=(#4:l),out=(array:l)		movelong [array],ptr		movelong #0,[ptr]Unlocked	lda P_PageMode		beq DoAddG		; Round		call P_RoundGuide,in=(amt:w,vert:w),out=(amt:w)		moveword amt,newpt		moveword amt,newpt+2		rcall P_FixPt,in=(newpt:ax),out=(newpt:ax)		pushlong oldpt		pushlong newpt		pushword tabtype		pushword vertDrawIt3	jsl *		movelong newpt,oldptDoAddG		in amt:w,array:l,count:w,tabtype:w		out count:w		xerr err		xcall P_AddGuide		bra DiceNoDice	movelong #-1,newptDice	pushlong oldpt		pushlong newpt		pushword tabtype		pushword vertDrawIt2	jsl *		moveword count,newcount		return;-------------------------;; AdjustPt (local routine)   ; adjust a Q_Point for drawing;AdjustPt	addword newpt,voffset,adjpt		addword newpt+2,hoffset,adjpt+2		lda P_PageMode		beq DidMap		subword adjpt,voffset,adjpt		subword adjpt+2,hoffset,adjpt+2		tool _MapPt,in=(!adjpt:l,#P_FullPaperRect:l,#P_PaperRect:l)DidMap	lda vert		beq HorizAmt		lda adjpt+2	 ;		and #$FFFE	  ; Q_Mask to even pixel		sta amt		bra DidHVHorizAmt	moveword adjpt,amtDidHV	rts		ENDP		END