	load 'macros.dump'	include 'driver.equ'	include 'pl.equ';-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	D_DateToStr	IMPORT	D_FastMult	IMPORT	D_GetRefCon	IMPORT	D_KillFont	IMPORT	P_AllHGCount	IMPORT	P_AllHGuides	IMPORT	P_AllVGCount	IMPORT	P_AllVGuides	IMPORT	P_ContentRect	IMPORT	P_CurDate	IMPORT	P_CurrentWin	IMPORT	P_Cursor	IMPORT	P_FindGuide	IMPORT	P_FirstPOff	IMPORT	P_FullPageRect	IMPORT	P_FullPaperRect	IMPORT	P_H	IMPORT	P_ImportType	IMPORT	P_LineSize	IMPORT	P_MagGuides	IMPORT	P_OldIdlePt	IMPORT	P_Page	IMPORT	P_PageMode	IMPORT	P_PageRect	IMPORT	P_PaperRect	IMPORT	P_Placing	IMPORT	P_PortRect	IMPORT	P_PrintHand	IMPORT	P_SetCursor	IMPORT	P_SpecStr	IMPORT	P_TrackMaskHorz	IMPORT	P_TrackMaskVert	IMPORT	P_TrackOn	IMPORT	P_V	IMPORT	P_ValidRect	IMPORT	P_VisRuler	IMPORT	P_WinStuffSize	IMPORT	P_WindowStuff	IMPORT	D_PrintToLW	IMPORT	D_SelectFont	IMPORT	D_Set4Pat	IMPORT	T_DotObj;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------;--------------------------------------------------------------------------------;; This is a massive kludge to get around Apple's fucked up LaserWriter driver.; The LaserWriter driver uses the current pen D_Pattern for drawing Q_Text instead; of the current Q_Text pen.  Furthermore, because of the way Quickdraw records; pictures, it is not sufficient to just set the pen D_Pattern, because Quickdraw; will not record the change until something it applies to, i.e. not Q_Text, is; drawn.  Therefore the bogus call to FrameRect.  Argggg!!;P_AppleFuck	PROC		EXPORT			;Using D_GlobalData		lda >D_PrintToLW		beq Exit		tool _PenNormal		tool _FrameRect,in=(#BogusRect:l)Exit	rtlBogusRect	DC.W	0,0,0,0		ENDP;------------------------------------------------------------------------------;; P_Entry ();; Entry routine.P_Entry	PROC		EXPORT			;Using P_Data		tool _SetPort,in=(P_CurrentWin:l)		jsl D_KillFont		rtl		ENDP;---------------------------------------------------------------------------;; P_SaveWindowStuff ;P_SaveWindowStuff	PROC		EXPORT			;Using P_Data		input window:l		local tmp:l		begin		IsNil window		beq Exit		call D_GetRefCon,in=(window:l),out=(tmp:l)		tool _BlockMove,in=(#P_WindowStuff:l,[tmp]:l,#P_WinStuffSize:l)Exit	return		ENDP;---------------------------------------------------------------------------;; P_LoadWindowStuff ;P_LoadWindowStuff	PROC		EXPORT			;Using P_Data		input NewWindow:l		local tmp:l		begin		cmpl NewWindow,P_CurrentWin		beq Done		call P_SaveWindowStuff,in=(P_CurrentWin:l)		IsNil NewWindow		beq SetWin		call D_GetRefCon,in=(NewWindow:l),out=(tmp:l)		tool _BlockMove,in=([tmp]:l,#P_WindowStuff:l,#P_WinStuffSize:l)SetWin	movelong NewWindow,P_CurrentWinDone	return		ENDP;---------------------------------------------------------------------------;; P_LShift;;		   shifts A to the left X bits;		   trashes Y.;		   returns in AP_LShift	PROC		EXPORT		txyShift	beq DoneShift		asl a		dex		bra ShiftDoneShift	rtl		ENDP;---------------------------------------------------------------------------;; P_RShift	;;		   shifts A to the right X bits;		   trashes Y.;		   returns in AP_RShift	PROC		EXPORT		txyShift	beq DoneShift		lsr a		dex		bra ShiftDoneShift	rtl		ENDP;---------------------------------------------------------------------------;; P_Fix2Int   ;;		   converts <ax> fp to <a> short, rounding accordingly.;P_Fix2Int	PROC		EXPORT		tay		bpl exit		inxexit	txa		rtl		ENDP;--------------------------------------------------------------------------;; P_DoScritch;P_DoScritch	PROC		EXPORT			;Using P_Data			;Using P_RulerData		input Pt:l		begin		lda P_VisRuler		jeq Exit		tool _SetPort,in=(P_CurrentWin:l)		tool _GetPenState,in=(#P_PennState:l)		call D_Set4Pat,in=(#Black:w)		tool _SetPenMode,in=(#notXOR:w)		tool _SetPenMask,in=(#P_TrackMaskVert:l)		tool _SetPenSize,in=(#1:w,#1:w); Horizontal tracking		tool _MoveTo,in=(Pt+2:w,#0:w)		tool _Line,in=(#0:w,#9:w)		tool _SetPenMask,in=(#P_TrackMaskHorz:l); Vertical tracking		subword P_ContentRect+2,#P_VRulWdth,s		pushword Pt		_MoveTo		tool _Line,in=(#38:w,#0:w)norm	tool _SetPenState,in=(#P_PennState:l)Exit	returnP_PennState		DS.B 50		ENDP;---------------------------------------------------------------------------;; P_TrackCursor (PtPtr:l);P_TrackCursor	PROC		EXPORT			;Using P_Data		input PtPtr:l		local D_Cursor:w,Pt:l,Width:w		beginD_DoIdle	movelong [PtPtr],Pt		lda P_Placing		beq NotPlacing		lda P_ImportType		beq ItsText		moveword #PlaceGrfCursor,D_Cursor		bra PlacedItsText	moveword #PlaceTxtCursor,D_Cursor		bra PlacedNotPlacing	moveword P_Cursor,D_CursorPlaced		tool _ClipRect,in=(#P_PortRect:l)		tool _PtInRect,in=(PtPtr:l,#P_ContentRect:l),out=(a:w)		bne TrackCurs		moveword #ArrowCursor,D_Cursor		lda P_TrackOn		jeq GotCurs		call P_DoScritch,in=(P_OldIdlePt:l)		stz P_TrackOn		brl GotCursTrackCurs		cmpw Pt+2,P_ContentRect+2		bge cont		subword P_ContentRect+2,2,Pt+2cont		cmpw Pt,P_ContentRect		bge cont2		moveword #0,Ptcont2		cmpl Pt,P_OldIdlePt		jeq GotCurs		lda P_TrackOn		beq AlreadyOff		call P_DoScritch,in=(P_OldIdlePt:l)AlreadyOff	call P_DoScritch,in=(Pt:l)		movelong Pt,P_OldIdlePt		moveword #1,P_TrackOnGotCurs	moveword #1,Width		lda P_PageMode		bne FullPage		moveword P_LineSize,WidthFullPage		call P_SetCursor,in=(D_Cursor:w,Width:w)Exit	tool _ClipRect,in=(#P_ContentRect:l)		return		ENDP;----------------------------------------------------------------------------;; P_Local2PL (a = Vert; x =Horix);; Converts a Q_Point from local window coordinates to D_PL coordinates.P_Local2PL	PROC		EXPORT			;Using P_Data		ldy P_PageMode		beq NoMap		movelong ax,Pt		tool _MapPt,in=(#Pt:l,#P_FullPageRect:l,#P_PageRect:l)		movelong Pt,ax		bra ExitNoMap		addword a,P_V,a		subword a,P_ContentRect,s		addword x,P_H,a		subword a,P_ContentRect+2,x		plaExit	rtlPt		DS.B 4		ENDP;----------------------------------------------------------------------------;; P_PL2Local (a = Vert; x =Horix)P_PL2Local	PROC		EXPORT			;Using P_Data		ldy P_PageMode		beq NoMap		movelong ax,Pt		tool _MapPt,in=(#Pt:l,#P_PageRect:l,#P_FullPageRect:l)		movelong Pt,ax		bra ExitNoMap		subword a,P_V,a		addword a,P_ContentRect,s		subword x,P_H,a		addword a,P_ContentRect+2,x		plaExit	rtlPt		DS.B 4		ENDP;---------------------------------------------------------------------------;; P_FixPt;;		   i/o=(vert:a, horiz:x), in=(Q_Mask:y);			   i.e. (Q_Point:ax);;		   Converts a document Q_Point to a window-local Q_Point.;		   If currently in FullPageMode, Q_Point is mapped accordingly.;		   If Y register is non-zero, Q_Point is masked to an even pixel.;		   Presumably, masking to even pixel is never desired in FullPageMode;P_FixPt	PROC		EXPORT			;Using P_Data		movelong ax,ThePt		phy		lda P_PageMode		beq DontMap		tool _MapPt,in=(#ThePt:l,#P_PaperRect:l,#P_FullPaperRect:l)		movelong ThePt,ax		ply		bra exitDontMap	lda ThePt+2		subword a,P_H,a		addword a,P_ContentRect+2,x		lda ThePt		subword a,P_V,a		addword a,P_ContentRect,aDidMap	ply		beq exit		pha		txa		and #$FFFE		tax		plaexit	rtlThePt		DS.B 4		ENDP;------------------------------------------------------------------------------;; P_FixRect (RectPtr:l; ObjType:w; Map:w; Offset:w);P_FixRect	PROC		EXPORT			;Using P_Data			;Using P_ObjData		INPUT  RectPtr:l,ObjType:w,Map:w,Offset:w		BEGIN		lda ObjType		cmp #P_LINE		beq DoLine		cmp #P_STRLINE		beq DoLine		call P_ValidRect,in=(RectPtr:l),out=(a:w)		bra DoMapDoLine		cmpw [RectPtr],[RectPtr]:#4		blt DoMap		pushlong [RectPtr]		movelong [RectPtr]:#4,[RectPtr]		pulllong [RectPtr]:#4DoMap	lda Map		beq NoMap		tool _MapRect,in=(RectPtr:l,#P_PageRect:l,#P_FullPageRect:l)		ldy #2		lda [RectPtr],y		and #$FFFE		sta [RectPtr],y		ldy #6		lda [RectPtr],y		and #$FFFE		sta [RectPtr],y		bra NoOffsetNoMap		lda Offset		beq NoOffset		pushlong RectPtr		subword P_ContentRect+2,P_H,s		subword P_ContentRect,P_V,s		_OffsetRectNoOffsetExit	RETURN		ENDP;---------------------------------------------------------------------------;; P_UnMapPt ();; Converts a Q_Point from window coordinates to documentP_UnmapPt	PROC		EXPORT		BEGIN		RETURN		ENDP;---------------------------------------------------------------------------;; Local2TextObj ;Local2TextObj	PROC		EXPORT			;Using P_ObjData			;Using P_Data			;Using T_Data			;Using T_TextEqu		input pt:l		output newpt:l		local hdl:l,ptr:l		begin		movelong T_DotObj,Hdl		movelong [hdl],ptr		subword pt,[ptr]:#P_TRect,a		addword a,P_V,a		subword a,P_ContentRect,newpt		subword pt+2,[ptr]:#P_TRect+2,a		addword a,P_H,a		subword a,P_ContentRect+2,a		and #$FFFE		sta newpt+2		RETURN		ENDP;---------------------------------------------------------------------------;; TextObj2Local ;TextObj2Local	PROC		EXPORT			;Using P_ObjData			;Using P_Data			;Using T_Data			;Using T_TextEqu		input pt:l		output newpt:l		local hdl:l,ptr:l		begin		movelong T_DotObj,hdl		movelong [hdl],ptr		addword pt,[ptr]:#P_TRect,a		subword a,P_V,a		addword a,P_ContentRect,newpt		addword pt+2,[ptr]:#P_TRect+2,a		subword a,P_H,a		addword a,P_ContentRect+2,a		and #$FFFE		sta newpt+2		RETURN		ENDP;---------------------------------------------------------------------------;; P_RoundGuide (amt:w,vert:w):w;P_RoundGuide	PROC		EXPORT			;Using P_Data			;Using P_RulerData		input amt:w,vert:w		output newamt:w		local hdl:l,ppi:l,quo:w,rem:w,tmp:l,dist:w		begin		movelong P_PrintHand,hdl		movelong [hdl],tmp		movelong [tmp]:#4,ppi		moveword #P_MIN_VPIX,dist		lda vert		beq DidVert		moveword ppi+2,ppi		moveword #P_MIN_HPIX,distDidVert		tool _UDivide,in=(amt:w,ppi:w),out=(tmp:w,amt:w)		ldx #0		lda ppiLoop	cmp dist		blt DoShift		lsr a		inx		bra loopDoShift	dex		stx dist		rcall P_LShift,in=(tmp:a),out=(tmp:a)		tool _UDivide,in=(tmp:w,ppi:w),out=(rem:w,quo:w)		rcall P_LShift,in=(#1:a,dist:x),out=(dist:a)		moveword ppi,tmp+2		lsr tmp+2		cmpw rem,tmp+2		blt DidDiv		inc quoDidDiv	rcall D_FastMult,in=(ppi:x,quo:y)		tool _UDivide,in=(a:w,dist:w),out=(a:w,quo:w)		rcall D_FastMult,in=(ppi:x,amt:y)		addword a,quo,newamt		return		ENDP;------------------------------------------------------------------------------;; P_MagValue (OldValue:w; Vert:w) : NewValue:w;P_MagValue	PROC		EXPORT			;Using P_Data		INPUT  OldValue:w,Vert:w		OUTPUT NewValue:w		BEGIN		lda Vert		beq Horiz		in P_AllHGuides:l,P_AllHGCount:w,OldValue:w,#4:w,#-1:w		out a:w,NewValue:w,a:w		xcall P_FindGuide		bra ExitHoriz	in P_AllVGuides:l,P_AllVGCount:w,OldValue:w,#8:w,#-1:w		out a:w,NewValue:w,a:w		xcall P_FindGuideExit	RETURN		ENDP;-----------------------------------------------------------------------------;; P_MagPt (PtPtr1:l,Pt_Ptr2:w,Figure:w);P_MagPt	PROC		EXPORT			;Using P_Data		INPUT PtPtr:l,AncPtPtr:l,Figure:w		BEGIN		lda P_MagGuides		beq Exit		lda Figure		beq Exit		call P_MagValue,in=([PtPtr]:w,#1:w),out=([PtPtr]:w)		call P_MagValue,in=([PtPtr]:#2:w,#0:w),out=([PtPtr]:#2:w)		cmpw [AncPtPtr],[PtPtr]		bge TryHoriz		lda [PtPtr]		ina		sta [PtPtr]TryHoriz	ldy #2		cmpw [AncPtPtr]:y,[PtPtr]:y		bge Exit		lda [PtPtr],y		ina		sta [PtPtr],yExit	RETURN		ENDP;----------------------------------------------------------------------------;; P_MagMove (RectPtr:l);; If magnetic guides are turned on, this routine will bump the rectangle.P_MagMove	PROC		EXPORT			;Using P_Data		INPUT RectPtr:l		LOCAL Q_Rect:r,NewValue:l,VDiff:w,HDiff:w		BEGIN		lda P_MagGuides		jeq Exit		moverect [RectPtr],Q_Rect		call P_MagValue,in=(Q_Rect:w,#1:w),out=(NewValue:w)		cmp Q_Rect		beq TryBottom		subword a,Q_Rect,VDiff		moveword NewValue,Q_Rect		addword Q_Rect+4,VDiff,Q_Rect+4		bra DoHorizTryBottom		call P_MagValue,in=(Q_Rect+4:w,#1:w),out=(:w)		pla									 ;		ina									 ;		sta NewValue							;		cmp Q_Rect+4		beq DoHoriz		subword a,Q_Rect+4,VDiff		moveword NewValue,Q_Rect+4		addword Q_Rect,VDiff,Q_RectDoHoriz		call P_MagValue,in=(Q_Rect+2:w,#0:w),out=(NewValue:w)		cmp Q_Rect+2		beq TryRight		subword a,Q_Rect+2,HDiff		moveword NewValue,Q_Rect+2		addword Q_Rect+6,HDiff,Q_Rect+6		bra SetItTryRight	call P_MagValue,in=(Q_Rect+6:w,#0:w),out=(:w)		pla									 ;		ina									 ;		ina									 ;		sta NewValue							;		cmp Q_Rect+6		beq SetIt		subword a,Q_Rect+6,HDiff		moveword NewValue,Q_Rect+6		addword Q_Rect+2,HDiff,Q_Rect+2SetIt	moverect Q_Rect,[RectPtr]Exit	RETURN		ENDP;-----------------------------------------------------------------------------;; P_SetSpecStr (ObjPtr:l);; Sets P_SpecStr to the correct Q_Text for either a page or date object and; sets the current font.P_SetSpecStr	PROC		EXPORT			;Using P_Data			;Using P_ObjData		INPUT ObjPtr:l,ForBounds:w		BEGIN		pushword [ObjPtr]:#P_ItemFontID		moveword [ObjPtr]:#P_ItemFontID+2,x		moveword [ObjPtr]:#P_ItemColor,y		pla		jsl D_SelectFont		cmpw [ObjPtr]:#P_Type,#P_DATETOOL		beq X_dodate		cmpw P_Page,#2		bge NotMaster		lda ForBounds		beq ShoveNumb		moveword #4,P_SpecStr		movelong #$35353535,P_SpecStr+1		bra ExitShoveNumb		moveword NumStr,P_SpecStr		bra ExitNotMaster		addword P_Page,P_FirstPOff,a		tool _Int2Dec,in=(a:w,#P_SpecStr+1:l,#4:w,#0:w)		movebyte #4,P_SpecStr		bra ExitX_dodate		call D_DateToStr,in=(P_CurDate:l,#P_SpecStr:l,#2:w,#0:w)Exit	RETURNNumStr	DC.B	1,35		ENDP;----------------------------------------------------------------------------;; P_GetPageMode () : PageMode:a;; The bank must be set when calling this routine from another bank.P_GetPageMode	PROC		EXPORT			;Using P_Data		lda P_PageMode		rtl		ENDP		END