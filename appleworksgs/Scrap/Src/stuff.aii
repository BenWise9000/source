	load	'macros.dump'	include 'driver.equ'	include 'scrap.equ'	IMPORT	X_AsciitoDBScrap	IMPORT	X_AsciitoSSScrap	IMPORT	X_AsciitoPLText	IMPORT	X_AsciitoWPScrap	IMPORT	X_BogusType	IMPORT	X_CacheRefcon	IMPORT	X_CacheType	IMPORT	D_CmpStrings	IMPORT	X_CopyGRPict	IMPORT	X_CopyPLObj	IMPORT	X_CopyWPScrap	import	X_DBtoAsciiScrap	import	X_DBtoPICT	import	X_DBtoPLScrap	import	X_DBtoWPScrap	import	X_DBtoSSScrap	IMPORT	X_DiScrap	IMPORT	X_DisposeWPScrap	IMPORT	X_FreeGRPict	import	X_GRPictToPict	IMPORT	X_KillPLObj	IMPORT	D_NeedHand	import	X_PL2PictScrap	import	X_PLtoWPScrap	IMPORT	X_ReadStandardScrap	IMPORT	X_SSDecRec	import	X_SStoAsciiScrap	import	X_SStoDBScrap	import	X_SStoPLScrap	import	X_SStoWPScrap	IMPORT	X_SWorksTypes	import	X_PLtoAsciiScrap	import	X_SWtoDBScrap	import	X_SWtoSSScrap	IMPORT	X_ScrapRefCon	IMPORT	X_ScrapType	IMPORT	X_ShortAsciiText	IMPORT	X_ShortDBScrap	IMPORT	X_ShortPLText	IMPORT	X_ShortSSScrap	IMPORT	X_ShortWPText	import	X_WPtoAsciiScrap	import	X_WPtoDBScrap	import	X_WPtoPLScrap	IMPORT	X_WPtoSSScrap	ENTRY	X_ConIgnore	ENTRY	X_OtherCopy	entry	X_DisposeScrap	entry	X_CopyScrap	entry	X_DisposeSimpleHandle	entry	X_CopyOneHandle;***********************************************************************;;   X_KillOldScrap - Disposes of scrap on clipboard.  If none, does nothing;;***********************************************************************X_KillOldScrap	PROC	EXPORT	;Using X_ClipData	begin +b	lda X_ScrapType	cmp #-1	jeq exit	PushWord X_ScrapType	PushLong X_ScrapRefCon	jsl X_DisposeScrap	MoveWord #-1,X_ScrapTypeexit	return	ENDPX_KillCacheScrap	PROC	EXPORT	;Using X_ClipData	begin +b	lda X_CacheType	cmp #-1	jeq exit	PushWord X_CacheType	PushLong X_CacheRefcon	jsl X_DisposeScrap	MoveWord #-1,X_CacheTypeexit	return	ENDP;************************************************************************;;   X_ConvertScrap(SrcType:w,SrcRefCon:l,NewType:w):NewRefcon:l -;	Takes a scrap of one type and converts to another.  If it;	isn't possible, returns 0.  Also returns memory manager;	errors, etc.  Returns a D_New handle.;;************************************************************************X_ConvertScrap	PROC	EXPORT	;Using X_ClipData	input SrcType:w,SrcRefCon:l,NewType:w	local Types:l,Index:w	output NewRefcon:l	error err	begin +b	stz err	MoveLong #X_SWorksTypes,Types	ldy #0loop	lda [Types],y	jeq invaltype	cmp NewType	beq foundtype	iny	iny	brl loopfoundtype	tya	lsr a	pha	asl a	asl a	asl a	clc	adc 1,s	sta Index	pla	ldy #0loop2	lda [Types],y	jeq invaltype	cmp SrcType	beq foundtype2	iny	iny	brl loop2foundtype2	tya	lsr a	clc	adc Index	sta Index	SpaceLong	MoveWord SrcType,X_BogusType	PushLong SrcRefCon	lda index	Jtl ConvertTable	sta err	PullLong NewRefCon	bcc exit	bra converterrinvaltype	MoveWord #-1,errconverterr	MoveLong #0,NewRefConexit	return err;This monster is the jump table to do conversionConvertTable	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_ConIgnore,X_OtherCopy,X_PLtoWPScrap	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_AsciitoWPScrap,X_SStoWPScrap,X_DBtoWPScrap	DC.L	X_ConIgnore,X_WPtoPLScrap,X_OtherCopy	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_AsciitoPLText,X_SStoPLScrap,X_DBtoPLScrap	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_OtherCopy,X_PL2PictScrap,X_GRPictToPict	DC.L	X_ConIgnore,X_ConIgnore,X_DBtoPICT	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_ConIgnore,X_OtherCopy,X_ConIgnore	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_ConIgnore,X_ConIgnore,X_OtherCopy	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_ConIgnore,X_WPtoAsciiScrap,X_PLtoAsciiScrap	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_OtherCopy,X_SStoAsciiScrap,X_DBtoAsciiScrap	DC.L	X_ConIgnore,X_WPtoSSScrap,X_SWtoSSScrap	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_AsciitoSSScrap,X_OtherCopy,X_DBtoSSScrap	DC.L	X_ConIgnore,X_WPtoDBScrap,X_SWtoDBScrap	DC.L	X_ConIgnore,X_ConIgnore,X_ConIgnore	DC.L	X_AsciitoDBScrap,X_SStoDBScrap,X_OtherCopy	ENDPX_ConIgnore	PROC	EXPORT	input SrcRefCon:l	output NewRefCon:l	error err	begin	MoveWord #-1,err	return	ENDPX_OtherCopy	PROC	EXPORT	;Using X_ClipData	input SrcRefCon:l	output NewRefCon:l	error err	begin	stz err	SpaceLong	PushWord X_BogusType	PushLong SrcRefCon	jsl X_CopyScrap	sta err	PullLong NewRefCon	jcc exit	MoveLong #0,NewRefConexit	return err	ENDP;************************************************************************;;   X_DisposeScrap(Type:w,Refcon:l) - Disposes of a scrap of a particular type;;************************************************************************X_DisposeScrap	PROC	EXPORT	;Using X_ClipData	input Type:w,Refcon:l	local Types:l	begin +b	PushLong RefCon	MoveLong #X_SWorksTypes,Types	ldy #0loop	lda [Types],y	jeq invaltype	cmp Type	beq done	iny	iny	brl loopdone	tya	lsr a	jtl DisposeTable	brl exitinvaltype	pla	plaexit	returnDisposeTable	DC.L	X_DisposeSimpleHandle	;SWText	DC.L	X_DisposeWPScrap	DC.L	X_DisposeSimpleHandle	;StaticText	DC.L	X_DisposeSimpleHandle	;PICT	DC.L	X_KillPLObj	DC.L	X_FreeGRPict	DC.L	X_DisposeSimpleHandle	;Ascii	DC.L	X_DisposeSimpleHandle	;D_SS	DC.L	X_DisposeSimpleHandle	;D_DB	ENDPX_DisposeSimpleHandle	PROC	EXPORT	input Handle:l	begin	PushLong Handle	_DisposeHandle	return	ENDP;************************************************************************;;   X_CopyScrap(Type:w,Refcon:l):refcon;;************************************************************************X_CopyScrap	PROC	EXPORT	;Using X_ClipData	input Type:w,Refcon:l	local Types:l	output Newref:l	error err	begin +b	stz err	SpaceLong	PushLong RefCon	MoveLong #X_SWorksTypes,Types	ldy #0loop	lda [Types],y	jeq invaltype	cmp Type	beq done	iny	iny	brl loopdone	tya	lsr a	jtl CopyTable	sta err	PullLong NewRef	bcc exit	bra mem_errinvaltype	pla	pla	pla	pla	MoveWord #-1,errmem_err	MoveLong #0,NewRefexit	return errCopyTable	DC.L	X_CopyOneHandle	;SWText	DC.L	X_CopyWPScrap	DC.L	X_CopyOneHandle	;StaticText	DC.L	X_CopyOneHandle	;PICT	DC.L	X_CopyPLObj	DC.L	X_CopyGRPict	DC.L	X_CopyOneHandle	;AsciiText	DC.L	X_CopyOneHandle	;SSScrap	DC.L	X_CopyOneHandle	;D_DB	ENDPX_CopyOneHandle	PROC	EXPORT	input Handle:l	local Size:l	output Copy:l	error err	begin	spacelong	  ; <rewritten, sans stack magic,	pushlong handle	;  7/23, jge>	_GetHandleSize	sta err	pulllong size	bcs exit	spacelong	pushlong size	jsl D_NeedHand	sta err	pulllong copy	bcs exit	pushlong [handle]	  ; No memory will move, so why	pushlong [copy]	;  use _HandToHand?	pushlong size	_BlockMoveexit	return	ENDPX_DialogFromScrap	PROC	EXPORT	;Using X_ClipData	;Using X_FieldScannerData	local ScrapSize:l,err:w,DSPtr:l,DialogScrap:l	begin +b	lda X_ScrapType	cmp #AsciiText	bne notAsciiText	PushLong X_ScrapRefCon	jsl X_ShortAsciiText	brl doneshortnotAsciiText	cmp #StaticText	bne notPLText	PushLong X_ScrapRefCon	jsl X_ShortPLText	brl doneshortnotPLText	cmp #WPText	bne notWPText	PushLong X_ScrapRefCon	jsl X_ShortWPText	brl doneshortnotWPText	cmp #SSScrap	bne notSSScrap	PushLong X_ScrapRefCon	jsl X_ShortSSScrap	brl doneshortnotSSScrap	cmp #DBScrap	bne nomatch	PushLong X_ScrapRefCon	jsl X_ShortDBScrap	brl doneshortnomatch	stz X_DiScrapdoneshort	_ZeroScrap	stz ScrapSize+2	lda X_DiScrap	and #$ff	sta ScrapSize	beq exit	PushLong ScrapSize	PushWord #0	PushLong #X_DiScrap+1	_PutScrap	_LEFromScrap	_ZeroScrapexit	return	ENDPX_DialogToScrap	PROC	EXPORT	;Using X_ClipData	;Using X_SSScrapData	local ScrapSize:l,TempScrap:l,TSPtr:l	begin +b	_LEToScrap	SpaceLong	PushWord #0	_GetScrapSize	PullLong ScrapSize	call	D_NeedHand,in=(ScrapSize:l),out=(TempScrap:l)	bcs	exit	tool	_GetScrap,in=(TempScrap:l,#0:w)		MoveLong [TempScrap],TSPtr	MoveWord ScrapSize,X_SSDecRec	pei TSPtr+2	pei TSPtr	PushLong #X_SSDecRec+1	PushLong ScrapSize	_BlockMove	SpaceWord	PushLong #X_DiScrap	PushLong #X_SSDecRec	PushWord #1	;Case sensitive	jsl D_CmpStrings	pla	beq nochange	jsl X_ReadStandardScrapnochange	PushLong TempScrap	_DisposeHandleexit	return	ENDP;*********************************************************************;;   X_CompareHandles - Takes two handles.  Returns a zero if equal,;	   a one if not equal.;;*********************************************************************X_CompareHandles	PROC	EXPORT	input Src1:l,Src2:l	local S1ptr:l,S2ptr:l,S1size:l,S2size:l,Temp:l	local OddFlag:w	output Result:w	error err	begin;Initialize variables	stz err	stz Result;Get sizes of two handles	SpaceLong	PushLong Src1	_GetHandleSize	PullLong S1size	SpaceLong	PushLong Src2	_GetHandleSize	PullLong S2size	Cmpl S1size,S2size	jne notequal	lda S1size	asl a	bcs odd1	stz OddFlag	bra test2odd1	MoveWord #1,OddFlag;Dereference two handlestest2	MoveLong [Src1],S1ptr	MoveLong [Src2],S2ptr;We are going to use x as the bank counter for comparison for sizes.;OddFlag will be used at the end to compare the last byte. y is the;index into both handles	ldx #0	ldy #0loop	cpy S1size	bge hitsizeentry	lda [S1ptr],y	cmp [S2ptr],y	bne notequal	iny	iny	beq bankboundary	bra loophitsize	cpx S1size+2	bge checkodd	bra entrybankboundary	inx	inc S1ptr+2	inc S2ptr+2	bra entrycheckodd	lda OddFlag	beq equal	dey	lda [S1ptr],y	cmp [S2ptr],y	bne notequal	bra equalnotequal	MoveWord #1,Resultequal	return	ENDP	END