	load	'macros.dump'	include	'driver.equ'	include	'scrap.equ'	IMPORT	X_AWIndent	IMPORT	X_AWLeftMargin	IMPORT	D_AlertBox	IMPORT	X_AsciitoWPScrap	IMPORT	X_BHand	IMPORT	X_BRuler	IMPORT	X_BAttr	IMPORT	D_BeachBall	IMPORT	X_BOffset	IMPORT	X_CantImportStr	IMPORT	D_CurCursor	IMPORT	X_CurrentParRecord	IMPORT	X_DisposeWPScrap	IMPORT	D_GrowHandle	IMPORT	D_GrowLHandle	IMPORT	X_MassageWPScrap	IMPORT	D_Message1	IMPORT	D_Message2	IMPORT	D_MessageThere	IMPORT	D_NeedHand	IMPORT	D_NeedHandle	IMPORT	X_OldCursor	IMPORT	X_PLtoWPScrap	IMPORT	X_ParBlockSize	IMPORT	X_RulerSize	IMPORT	X_SStoPLScrap	IMPORT	X_ScrStdRuler	IMPORT	D_SetCursor	IMPORT	X_StdTabRuler	import	X_MakeStandardRuler	import	X_TenthsTo80ths	import	X_ClipData	ENTRY	X_DoCR	ENTRY	X_DoPageBreakX_AWMinVers	equ $B7X_AWMinLM	equ $5BX_AWWPLMMin	equ 6;***************************************************************************;;   X_AWWPtoWPScrap;;****************************************************************************X_ScAWWPtoWPScrap	PROC	EXPORT	;Using X_WPScrapData	;Using X_WorksData	;Using D_GlobalData	;Using X_WPFileData	;Using D_OpenData	;Using X_ClipData	;Using D_CursorData	EXPORT	X_DoPageBreak	EXPORT	X_DoCR	input Src:l	local Aptr:l,Dptr:l,Doff:l,Block:l,RulerFlag:w	local BPtr:l,Offset:w,CurPar:l	local Ruler:l,Rptr:l,RealDptr:l,Dsize:l,FunPtr3:l	local Asize:l,Bsize:l,CRFlag:w,HeadSize:w	local Bpars:w,CharsInLine:w,FoundHeader:w,FoundFooter:w	local Message:l,MessSize:l,HeaderFlag:w,FooterFlag:w	local TempPtr:l,TempHand:l,TH2Ptr:l,RealMessSize:l	local FunPtr1:l,FunPtr2:l,HeadIndex:w,HeadDestDex:w	local AW30:w,AWMinLM:w,RulerPtr:l,CurStyle:w	local TabCnt:w,TabPos:w	output Dest:l	error err	begin	MoveWord >D_CurCursor,X_OldCursor	stz X_AWIndent	stz CRFlag	stz err	lda #0	sta >D_MessageThere	sta >D_Message1	sta >D_Message1+2	sta >D_Message2	sta >D_Message2+2	stz FooterFlag	stz HeaderFlag	stz FoundHeader	stz FoundFooter	jsr InitStyle	jsl X_MakeStandardRuler	PushLong Src	_HLock	MoveLong [Src],Aptr	ldy #X_AWMinVers	; Check and remember the SFMinVers byte	lda [Aptr],y	and #$00ff	sta AW30; Set the Minimum Left Margin so we can offset tab stops correctly	ldy #X_AWMinLM	; Set the Minimum Left Margin	lda [Aptr],y	and #$00ff		;   (from 10ths to 80ths)	cmp #X_AWWPLMMin	bcs setMinLM	lda #X_AWWPLMMin	; Must have at least .5" for AWGS	secsetMinLM	sbc #X_AWWPLMMin	jsl X_tenthsto80ths	sta AWMinLM	AddLong Aptr,#5,RulerPtr	MoveWord #40,X_AWLeftMargin	MoveWord X_AWLeftMargin,X_ScrStdRuler:#X_scr_or_IndentM	AddWord X_AWIndent,X_AWLeftMargin,X_ScrStdRuler:#X_scr_or_LeftM	AddLong [Src],#300,Aptr	stz RulerFlag	lda AW30	beq oldAW		; If zero, old AW format	Addwl #2,Aptr	; Skip the first line recordoldAW	SpaceLong		; ÀÀunused??	PushLong Src	_GetHandleSize	PullLong Asize	SpaceLong	PushLong #X_Blocksize	PushWord #X_Locked	jsl D_NeedHandle	sta err	PullLong Block	jcs exit	MoveLong #X_Blocksize,Bsize	MoveLong [Block],Bptr	MoveWord Bsize,[Bptr]	MoveWord #4,[Bptr]:#2	MoveWord #4,Offset	PushLong #DefaultHeader	Addwls Offset,Bptr	PushLong #7	_BlockMove	MoveWord Offset,X_BOffset	AddWord Offset,#7,Offset	MoveLong Block,X_BHand	lda AW30	beq rulerOK	jsl SetRulerrulerOK	jsr MakeRuler	SpaceLong	_MaxBlock	PullLong Dsize	SpaceLong	PushLong Dsize	jsl D_NeedHand	sta err	PullLong Dest	jcs exit	MoveLong #X_ParBlockSize+2,Dsize	MoveLong #2,Doff	PushLong Dsize	PushLong Dest	jsl D_GrowHandle	PushLong Dest	_HLock	MoveLong [Dest],RealDptr	lda #0	sta [RealDptr]	AddLong RealDptr,#2,Dptr	PushLong #X_CurrentParRecord	PushLong Dptr	PushLong #X_ParBlockSize	_BlockMove	MoveWord #1,Bparstextloop	jsl D_BeachBall	lda [Aptr]	and #$ff00	jeq Q_Text	xba	cmp #X_EOF	jeq done	cmp #X_BlankLine	jne format	AddLong Aptr,#2,Aptr	brl putheaderformat	sec	sbc #$D4		; #$D8 in Old AW	jts FormatTable	lda RulerFlag	jeq rulerno	jsr NewRulerrulerno	AddLong Aptr,#2,Aptr	brl textloopQ_Text	AddLong Aptr,#2,Aptr	lda HeaderFlag	beq noheaderhere	lda FoundHeader	bne secondtime	jsr DoHeadernoheaderhere	lda FooterFlag	beq nofooterhere	lda FoundFooter	bne secondtime	jsr DoFooter	lda HeaderFlag	bne clearheader	lda FooterFlag	beq nofooterhereclearheader	Addwl RealMessSize,Aptr	Addwl #2,Aptr	lda AW30	bne clrhdrout	stz HeaderFlag	stz FooterFlagclrhdrout	brl textloopsecondtime	lda [Aptr]	and #$7f00	xba	clc	adc Aptr	sta Aptr	bcc noinc1	inc Aptr+2noinc1	Addwl #2,Aptr	lda AW30	bne stimeout	stz HeaderFlag	stz FooterFlagstimeout	brl textloopnofooterhere	lda HeaderFlag	bne clearheader	lda [Aptr]	bpl nocr	inc CRFlag	bra justtextnocr	stz CRFlag	and #$00ff			; first test if it is a Tab Ruler	cmp #$00ff	bne justtexttabruler	AddLong Aptr,#2,RulerPtr	; Then set the correct stops	jsl SetRuler	jsr NewRuler		; Make the new ruler first	AddLong Aptr,#$51,Aptr		; and skip over it in the text	brl textloop	justtext	lda [Aptr]	xba	and #$7f	sta CharsInLine	AddLong Aptr,#2,Aptrcharloop	lda CharsInLine	; all for one bad sample file	beq linedone	shortm	lda [Aptr]	cmp #$19		; #$d for old AW	jge notspecial	longm	and #$ff	jts StyleTable	brl nonewpar	LONGA Offnotspecial	ldy Offset	sta [Bptr],y	longm	inc Offset	lda Offset	cmp Bsize	blt nonewpar	lda Bpars	cmp #1	bne noresize2	jsr ResizeBlock	brl nonewparnoresize2	jsr StartParOver	brl textloopnonewpar	IncLong Aptr	dec CharsInLine	jne charlooplinedone	lda CRFlag	jeq textloopputheader	jsr X_DoCR	MoveLong Aptr,Curpar	jsr InitStyle	brl textloopdone	shortm	lda #CR	ldy Offset	sta [Bptr],y	longm	lda [Rptr]	inc a	sta [Rptr]	lda [RealDptr]	inc a	sta [RealDptr]	PushLong Dest	_Hunlock	PushLong Ruler	_Hunlock	inc Offset	MoveWord Offset,[Bptr]	MoveWord Offset,[Bptr]:#2	PushLong Block	_HUnlock	PushWord #0	PushWord Offset	PushLong Block	jsl D_GrowHandle	MoveLong [Dest],Dptr	MoveWord [Dptr],Bpars	dec Bpars	SpaceLong	PushWord Bpars	PushWord #X_ParBlockSize	_Multiply	PullLong Doff	AddLong Dptr,Doff,Dptr	Addwl #2,Dptr	MoveWord [Dptr]:#X_scpAttr,a	jeq nopagebreak	Addwl #X_ParBlockSize,Dsize	PushLong Dsize	PushLong Dest	jsl D_GrowHandle	SpaceLong	PushLong #12	jsl D_NeedHand	sta err	PullLong Block	bcc okhere	PushLong Dest	jsl X_DisposeWPScrap	brl exitokhere	MoveLong Block,X_BHand	MoveWord #4,X_BOffset	stz X_BAttr	MoveLong Ruler,X_BRuler	MoveLong [Block],Bptr	MoveWord #12,[Bptr]	MoveWord a,[Bptr]:#2	PushLong #DefaultHeader	Addwls #4,Bptr	PushLong #8	_BlockMove	MoveLong [Ruler],Rptr	lda [Rptr]	inc a	sta [Rptr]	Addwl #X_ParBlockSize,Doff	AddLong [Dest],Doff,Dptr	Addwl #2,Dptr	PushLong #X_CurrentParRecord	PushLong Dptr	PushLong #X_ParBlockSize	_BlockMove	MoveLong [Dest],Dptr	lda [Dptr]	inc a	sta [Dptr]nopagebreak	PushLong Dest	jsl X_MassageWPScrap	MoveLong [Dest],FunPtr1	Cmpw [FunPtr1],#2	jge notnull	MoveLong [FunPtr1],TempHand	MoveLong [TempHand],FunPtr2	Cmpw [FunPtr2]:#2,#13	jge notnull	SpaceWord	PushWord #OKBox	PushLong #X_CantImportStr	jsl D_AlertBox	pla	PushLong Dest	jsl X_DisposeWPScrap	lda #0	sta >D_MessageThere	MoveWord #-1,err	Cpzl >D_Message1	jeq nullnohead	lda >D_Message1+2	pha	lda >D_Message1	pha	_DisposeHandlenullnohead	Cpzl >D_Message2	jeq exit	lda >D_Message2+2	pha	lda >D_Message2	pha	_DisposeHandle	brl exitnotnull	lda >D_Message1	bne headerthere	lda >D_Message1+2	jeq noheaderheaderthere	MoveLong >D_Message1,TempHand	SpaceLong	PushLong TempHand	jsl X_AsciitoWPScrap	PullLong >D_Message1	PushLong Temphand	_Disposehandlenoheader	lda >D_Message2	bne footerthere	lda >D_Message2+2	beq exitfooterthere	MoveLong >D_Message2,TempHand	SpaceLong	PushLong TempHand	jsl X_AsciitoWPScrap	PullLong >D_Message2	PushLong Temphand	_Disposehandleexit	PushWord X_OldCursor	jsl D_SetCursor	return errDefaultHeader	DC.W	-1	DC.B	0	DC.B	$ff	DC.B	0	DC.W	0	DC.B	CRNewRuler	lda [Rptr]	bne nodispose	jsr CheckRuler	bra nroutnodispose	PushLong Ruler	_HUnlock	jsr MakeRulernrout	MoveLong Ruler,[Dptr]:#8	rtsMakeRuler	SpaceLong	PushLong #X_RulerSize	PushWord #X_Locked	jsl D_NeedHandle	sta err	PullLong Ruler	jcs exit	MoveLong [Ruler],RptrCheckRuler	PushLong #X_ScrStdRuler	PushLong Rptr	PushLong #X_RulerSize	_BlockMove	ldy X_ScrStdRuler+X_scr_or_NumTabs	tya	dec a	asl a	asl a	tax;	now check this ruler to make sure all tabs;	are within the left and right margin	AddLong #X_ScrStdRuler,#X_scr_or_TabList,RulerPtr;	check first for tabs outside the right marginnrrmloop	lda X_ScrStdRuler+X_scr_or_TabList,x	cmp X_ScrStdRuler+X_scr_or_RightM	bcc nrlm	dey 	beq nrbad	dex	dex	dex	dex	bpl nrrmloop	bra nrbadnrlm	tya	ldy #X_scr_or_NumTabs	sta [Rptr],y	tax	lda X_ScrStdRuler+X_scr_or_LeftM	cmp X_ScrStdRuler+X_scr_or_IndentM	bcs nrlmloop	lda X_ScrStdRuler+X_scr_or_IndentMnrlmloop	cmp [RulerPtr]	bcc nrlmout	tay		; save rightmost left margin	Addwl #4,RulerPtr	tya		; retrieve rightmost left margin	dex	bne nrlmloop	bra nrbadnrlmout	cpx X_ScrStdRuler+X_scr_or_NumTabs	beq mrout;	save the number of tabs, then convert it;	to the number of words to move	ldy #X_scr_or_NumTabs		txa	sta [Rptr],y	asl a	tax		Addwl #X_scr_or_TabList,Rptr	ldy #0nrtabloop	lda [RulerPtr],y	sta [Rptr],y	iny	iny	dex	bpl nrtabloop	bra mrout;	we have bad margins, so let's set one tab stop;	in the middle of the right & left margins.nrbad	ldx #X_scr_or_LeftM	lda X_ScrStdRuler,x	inx	inx	cmp X_ScrStdRuler,x	bcc nrgotmax	ldx #X_scr_or_LeftMnrgotmax	lda X_ScrStdRuler+X_scr_or_RightM	sec	sbc X_ScrStdRuler,x	lsr a	clc	adc X_ScrStdRuler,x	tax	MoveLong [Ruler],Rptr	txa	ldy #X_scr_or_tab1	sta [Rptr],y	iny	iny	lda #X_scr_rt_left	sta [Rptr],y	ldy #X_scr_or_NumTabs	lda #1	sta [Rptr],ymrout	MoveLong [Ruler],Rptr	MoveLong Ruler,X_BRuler	lda #0	sta [Rptr]	sta RulerFlag	rtsStartParOver	ldy #2	lda [Bptr],y	sta [Bptr]	PushLong Block	_HUnlock	pea 0	lda [Bptr]	pha	PushLong Block	jsl D_GrowHandle	MoveLong CurPar,Aptr	SpaceLong	PushLong #X_Blocksize	PushWord #X_Locked	jsl D_NeedHandle	PullLong Block	MoveLong Block,X_BHand	MoveWord #4,Offset	MoveWord Offset,X_BOffset	PushLong #X_CurrentParRecord	PushLong Dptr	PushLong #X_ParBlockSize	_BlockMove	MoveLong [Block],Bptr	MoveWord Bsize,[Bptr]	MoveWord Offset,[Bptr]:#2	PushLong #DefaultHeader	lda Bptr	clc	adc Offset	tax	lda Bptr+2	adc #0	pha	phx	PushLong #7	_BlockMove	AddWord Offset,#7,Offset	MoveLong #X_Blocksize,Bsize	stz Bpars	rtsNewParBlock	ldy #2	lda [Bptr],y	sta [Bptr]	PushLong Block	_HUnlock	pea 0	lda [Bptr]	pha	PushLong Block	jsl D_GrowHandle	SpaceLong	PushLong #X_Blocksize	PushWord #X_Locked	jsl D_NeedHandle	PullLong Block	MoveWord #X_Blocksize,Bsize	MoveLong Block,X_BHand	MoveWord #4,Offset	MoveWord Offset,X_BOffset	MoveLong [Block],Bptr	MoveWord Bsize,[Bptr]	MoveWord Offset,[Bptr]:#2	stz Bpars	rtsResizeBlock	AddWord Bsize,#X_Blocksize,Bsize	SpaceLong	PushLong Bsize	PushLong Block	jsl D_GrowLHandle	sta err	PullLong Bptr	jcc noerr1	pla	brl exitnoerr1	MoveWord Bsize,[Bptr]	rtsFormatTable	DC.W	S_Ignore	; $D4 (Reserved??)	DC.W	EndHeader	; Page Header End	DC.W	EndFooter	; Page Footer End	DC.W	DoRight	; Right Justified	DC.W	S_Ignore	;PlatenWidth	DC.W	DoLeftMargin	DC.W	DoRightMargin	DC.W	S_Ignore	;Characters per inch	DC.W	S_Ignore	;Proportional-1	DC.W	S_Ignore	;Proportional-2	DC.W	DoIndent	DC.W	DoFull	DC.W	DoLeft	DC.W	DoCenter	DC.W	S_Ignore	;Paper Length	DC.W	S_Ignore	;Top Margin	DC.W	S_Ignore	;Bottom Margin	DC.W	S_Ignore	;Lines per Inch	DC.W	DoSingle	DC.W	DoDouble	DC.W	DoTriple	DC.W	X_DoPageBreak	DC.W	S_Ignore	;Group begin	DC.W	S_Ignore	;Group end	DC.W	DoHeaderFlag	DC.W	DoFooterFlag	DC.W	DoSkipLines	DC.W	S_Ignore	;Page Number	DC.W	S_Ignore	;Pause each page	DC.W	S_Ignore	;Pause here	DC.W	S_Ignore	;Set Marker	DC.W	S_Ignore	;Page Number	DC.W	DoCRPageBreak	DC.W	DoCRPageBreak	DC.W	DoCRPageBreak	DC.W	DoCRPageBreakDoLeftMargin	lda [Aptr]	and #$ff	jsl X_tenthsto80ths	ldx #4	cmp #4	bcc dlmset	SubWord a,#40,a		tax	AddWord a,#160,a	cmp X_ScrStdRuler+X_scr_or_RightM	bcc dlmset	SubWord X_ScrStdRuler+X_scr_or_RightM,#160,a	SubWord a,X_AWIndent,xdlmset	stx X_AWLeftMargin	txa	sta X_ScrStdRuler+X_scr_or_IndentM	AddWord X_AWIndent,X_AWLeftMargin,X_ScrStdRuler:#X_scr_or_LeftM	inc RulerFlag	rtsDoRightMargin	shortm	lda #75	sec	sbc [Aptr]	longm	and #$00ff	jsl X_tenthsto80ths		tax	SubWord a,#160,a	cmp X_ScrStdRuler+X_scr_or_LeftM	bcc drmbad	cmp X_ScrStdRuler+X_scr_or_IndentM	bcs drmsetdrmbad	lda X_ScrStdRuler+X_scr_or_LeftM	cmp X_ScrStdRuler+X_scr_or_IndentM	bcs drmadjust	lda X_ScrStdRuler+X_scr_or_IndentMdrmadjust	AddWord a,#160,xdrmset	stx X_ScrStdRuler+X_scr_or_RightM	inc RulerFlagdrmout	rtsDoIndent	lda [Aptr]	and #$ff	jsl X_tenthsto80thsdiloop	tax	AddWord a,X_AWLeftMargin,a	AddWord a,#160,a	cmp X_ScrStdRuler+X_scr_or_RightM	bcc diset	SubWord x,#2,a	bpl diloop	ldx #0	diset	stx X_AWIndent	AddWord X_AWLeftMargin,X_AWIndent,X_ScrStdRuler:#X_scr_or_LeftM	inc RulerFlag	rts	StyleTable	DC.W	S_Ignore	DC.W	DoBold	DC.W	UndoBold	DC.W	DoSuper	DC.W	UndoSuper	DC.W	DoSub	DC.W	UndoSub	DC.W	DoUnder	DC.W	UndoUnder	DC.W	DoSpace	DC.W	DoSpace	DC.W	DoStickySpace	DC.W	D_DoPrintMerge	DC.W	S_Ignore	; $0D	DC.W	S_Ignore	; Print Date	DC.W	S_Ignore	; Print Time	DC.W	S_Ignore	; SC 1	DC.W	S_Ignore	; SC 2	DC.W	S_Ignore	; SC 3	DC.W	S_Ignore	; SC 4	DC.W	S_Ignore	; SC 5	DC.W	S_Ignore	; SC 6	DC.W	DoTab	; Tab Character	DC.W	S_Ignore	; Tab Fill Character	DC.W	S_Ignore	; Add-On Stuff 	DC.W	S_Ignore	; Nothing right nowD_DoPrintMerge	ldy #1	lda [Aptr],y	and #$ff	cmp #'<'	jeq mergegoaway	MoveByte #'<',[Aptr]:#1	ldy #2	shortmmergeloop	lda [Aptr],y	cmp #']'	beq foundit	iny	bra mergeloopfoundit	lda #'>'	sta [Aptr],ymergegoaway	longm	rtsDoTab	lda #$09	; I assume Tab is used for Tabs?!?	plx	brl notspecialDoSpace	lda #' '	plx	brl notspecialDoStickySpace	lda #$ca	plx	brl notspecialEndHeader	stz HeaderFlag	rtsEndFooter	stz FooterFlag	rtsS_Ignore	rtsInitStyle	lda #$200	sta CurStyle	rtsDoBold	PushWord #Bold	jsr SetStyle	rtsDoSuper	PushWord #SuperScript	jsr SetStyle	rtsDoSub	PushWord #SubScript	jsr SetStyle	rtsDoUnder	PushWord #Underline	jsr SetStyle	rtsSetStyle	lda Offset	inc a	inc a	cmp Bsize	bne goodfit	lda Bpars	cmp #1	bne noresize3	jsr ResizeBlockgoodfit	lda CurStyle	ora 3,s	sta CurStyle	xba	ldy Offset	sta [Bptr],y	inc Offset	inc Offset	plx	pla	phx	rtsnoresize3	pla	pla	jsr StartParOver	brl textloopUndoBold	PushWord #Bold	jsr ResetStyle	rtsUndoSuper	PushWord #SuperScript	jsr ResetStyle	rtsUndoSub	PushWord #SubScript	jsr ResetStyle	rtsUndoUnder	PushWord #Underline	jsr ResetStyle	rtsResetStyle	lda Offset	inc a	inc a	cmp Bsize	bne goodfit2	lda Bpars	cmp #1	jne noresize3	jsr ResizeBlockgoodfit2	lda #-1	eor 3,s	sta 3,s	lda CurStyle	and 3,s	sta CurStyle	xba	ldy Offset	sta [Bptr],y	inc Offset	inc Offset	plx	pla	phx	rtsDoRight	ldx #2	lda X_ScrStdRuler,x	and #X_JustReset	ora #X_scr_r_right	sta X_ScrStdRuler,x	inc RulerFlag	rtsDoFull	ldx #2	lda X_ScrStdRuler,x	and #X_JustReset	ora #X_scr_r_full	sta X_ScrStdRuler,x	inc RulerFlag	rtsDoLeft	ldx #2	lda X_ScrStdRuler,x	and #X_JustReset	ora #X_scr_r_left	sta X_ScrStdRuler,x	inc RulerFlag	rtsDoCenter	ldx #2	lda X_ScrStdRuler,x	and #X_JustReset	ora #X_scr_r_center	sta X_ScrStdRuler,x	inc RulerFlag	rtsDoSingle	ldx #2	lda X_ScrStdRuler,x	and #X_SpaceReset	ora #X_scr_r_single	sta X_ScrStdRuler,x	inc RulerFlag	rtsDoDouble	ldx #2	lda X_ScrStdRuler,x	and #X_SpaceReset	ora #X_scr_r_double	sta X_ScrStdRuler,x	inc RulerFlag	rtsDoTriple	ldx #2	lda X_ScrStdRuler,x	and #X_SpaceReset	ora #X_scr_r_triple	sta X_ScrStdRuler,x	inc RulerFlag	rtsX_DoPageBreak	;	jsr X_DoCR	shortm	lda #CR	ldy Offset	sta [Bptr],y	longm	inc Offset	lda Offset	sta X_BOffset	ldy #2	sta [Bptr],y	AddWord Offset,#7,a	cmp Bsize	blt noprob9	jsl NewParBlock	bra skip9noprob9	MoveLong #0,[Dptr]:#X_scpRulerHand	MoveWord #1,[Dptr]:#X_scpAttrskip9	PushLong #DefaultHeader	lda Bptr	clc	adc Offset	tax	lda Bptr+2	adc #0	pha	phx	PushLong #7	_BlockMove	MoveWord Offset,X_BOffset	AddWord Offset,#7,Offset	MoveLong Block,X_BHand	AddLong Doff,#X_ParBlockSize,Doff	AddLong Dsize,#X_ParBlockSize,Dsize	SpaceLong	PushLong Dsize	PushLong Dest	jsl D_GrowLHandle	PullLong RealDptr	AddLong RealDptr,Doff,Dptr	lda [RealDptr]	inc a	sta [RealDptr]	PushLong #X_CurrentParRecord	PushLong Dptr	PushLong #X_ParBlockSize	_BlockMove	rtsdofooterflag	inc FooterFlag	rtsdoheaderflag	inc HeaderFlag	rtsDoFooter	MoveWord #2,StuffStyle	lda [Aptr]	and #$7f00	xba	sta RealMessSize	stz RealMessSize+2	AddLong RealMessSize,RealMessSize,MessSize	AddLong Aptr,#2,TempPtr	SpaceLong	PushLong MessSize	jsl D_NeedHand	sta err	PullLong >D_Message2	bcc nofooterr	pla	PushLong Dest	jsl X_DisposeWPScrap	brl exitnofooterr	MoveWord RealMessSize,MessSize	MoveLong >D_Message2,Message	MoveLong [Message],TH2Ptr	PushLong TempPtr	PushLong TH2Ptr	PushWord RealMessSize	jsr GetStuffFromAWorks	MoveLong >D_Message2,Message	AddLong [Message],MessSize,TempPtr	MoveByte #CR,[TempPtr]	inc MessSize	pea 0	PushWord MessSize	PushLong Message	jsl D_GrowHandle	MoveWord #1,>D_MessageThere	inc FoundFooter	rtsDoHeader	MoveWord #2,StuffStyle	lda [Aptr]	and #$00ff			; first test if it is a Tab Ruler	cmp #$00ff	bne headtext	AddLong Aptr,#$51,Aptr		; skip over it in the text	pla			; pop the return address (ugly, I know )	brl textloop		; just try it again	headtext	lda [Aptr]	and #$7f00	xba	sta RealMessSize	stz RealMessSize+2	AddLong RealMessSize,RealMessSize,MessSize	AddLong Aptr,#2,TempPtr	SpaceLong	PushLong MessSize	jsl D_NeedHand	sta err	PullLong >D_Message1	bcc noheaderr	pla	PushLong Dest	jsl X_DisposeWPScrap	brl exitnoheaderr	MoveLong >D_Message1,Message	MoveLong [Message],TH2Ptr	MoveWord RealMessSize,MessSize	PushLong TempPtr	PushLong TH2Ptr	PushWord RealMessSize	jsr GetStuffFromAWorks	MoveLong >D_Message1,Message	AddLong [Message],MessSize,TempPtr	MoveByte #CR,[TempPtr]	inc MessSize	pea 0	PushWord MessSize	PushLong Message	jsl D_GrowHandle	MoveWord #1,>D_MessageThere	inc FoundHeader	rtsGetStuffFromAWorks	stz HeadIndex	stz HeadDestDex	MoveLong 9:s,FunPtr1	MoveLong 5:s,FunPtr2	lda FunPtr1	clc	adc 3,s	sta FunPtr3	lda FunPtr1+2	adc #0	sta FunPtr3+2headloop	shortm	lda [Funptr1]	cmp #$20	bge headnormalchar	longm	and #$ff	dec a	asl a	tax	jsr (StuffTable,x)	brl doloop	LONGA Offheadnormalchar	sta [Funptr2]	longm	IncLong Funptr2doloop	IncLong Funptr1	Cmpl Funptr1,Funptr3	blt headloop	plx	pla	pla	pla	pla	pla	phx	rtsStuffTable	DC.W	HeadDoBold	DC.W	HeadUndoBold	DC.W	HeadDoSuper	DC.W	HeadUndoSuper	DC.W	HeadDoSub	DC.W	HeadUndoSub	DC.W	HeadDoUnder	DC.W	HeadUndoUnder	DC.W	HeadPageNumber	DC.W	HeadSpace	DC.W	HeadStickySpace	DC.W	HeadPrintMerge	DC.W	HeadIgnore	; $0D	DC.W	HeadIgnore	; Print Date	DC.W	HeadIgnore	; Print Time	DC.W	HeadIgnore	; SC 1	DC.W	HeadIgnore	; SC 2	DC.W	HeadIgnore	; SC 3	DC.W	HeadIgnore	; SC 4	DC.W	HeadIgnore	; SC 5	DC.W	HeadIgnore	; SC 6	DC.W	HeadTab	; Tab Character	DC.W	HeadIgnore	; Tab Fill Character	DC.W	HeadIgnore	; Add-On Stuff 	DC.W	HeadIgnore	; Nothing right nowHeadIgnoreHeadPrintMerge	dec MessSize	lda 5,s	dec a	sta 5,s	rts	; No print merge in AWGS headersStuffStyle	DC.W	2HeadPageNumber	MoveByte #5,[Funptr2]	IncLong Funptr2	rtsHeadSpace	MoveByte #' ',[Funptr2]	IncLong Funptr2	rtsHeadTab	MoveByte #9,[Funptr2]	IncLong Funptr2	rtsHeadStickySpace	MoveByte #$ca,[Funptr2]	IncLong Funptr2	rtsHeadDoBold	lda #Bold	xba	pha	lda StuffStyle	ora 1,s	sta StuffStyle	sta [FunPtr2]	pla	Addwl #2,FunPtr2	inc Messsize	rtsHeadDoSuper	lda #SuperScript	xba	pha	lda StuffStyle	ora 1,s	sta StuffStyle	sta [FunPtr2]	pla	Addwl #2,FunPtr2	inc Messsize	rtsHeadDoSub	lda #SubScript	xba	pha	lda StuffStyle	ora 1,s	sta StuffStyle	sta [FunPtr2]	pla	Addwl #2,FunPtr2	inc MessSize	rtsHeadDoUnder	lda #Underline	xba	pha	lda StuffStyle	ora 1,s	sta StuffStyle	sta [FunPtr2]	pla	Addwl #2,FunPtr2	inc MessSize	rtsHeadUndoBold	lda #Bold	xba	pha	lda #-1	eor 1,s	sta 1,s	lda StuffStyle	and 1,s	sta StuffStyle	sta [Funptr2]	pla	Addwl #2,FunPtr2	inc Messsize	rtsHeadUndoSuper	lda #SuperScript	xba	pha	lda #-1	eor 1,s	sta 1,s	lda StuffStyle	and 1,s	sta StuffStyle	sta [Funptr2]	pla	Addwl #2,FunPtr2	inc Messsize	rtsHeadUndoSub	lda #SubScript	xba	pha	lda #-1	eor 1,s	sta 1,s	lda StuffStyle	and 1,s	sta StuffStyle	sta [Funptr2]	pla	Addwl #2,FunPtr2	inc MessSize	rtsHeadUndoUnder	lda #Underline	xba	pha	lda #-1	eor 1,s	sta 1,s	lda StuffStyle	and 1,s	sta StuffStyle	sta [Funptr2]	pla	Addwl #2,FunPtr2	inc MessSize	rtsDoSkipLines	lda [Aptr]	and #$ff	phacrloop	lda 1,s	jeq crdone	jsr X_DoCR	pla	dec a	pha	brl crloopcrdone	pla	AddLong Aptr,#2,Curpar	jsr InitStyle	rtsDoCRPageBreak	jsr X_DoCR	AddLong Aptr,#2,Curpar	jsr InitStyle	rtsX_DoCR	;	shortm	lda #CR	ldy Offset	sta [Bptr],y	longm	inc Offset	lda Offset	sta X_BOffset	ldy #2	sta [Bptr],y	AddWord Offset,#7,a	cmp Bsize	blt noprobx	jsr NewParBlocknoprobx	AddLong Doff,#X_ParBlockSize,Doff	AddLong Dsize,#X_ParBlockSize,Dsize	SpaceLong	PushLong Dsize	PushLong Dest	jsl D_GrowLHandle	PullLong RealDptr	AddLong RealDptr,Doff,Dptr	PushLong #X_CurrentParRecord	PushLong Dptr	PushLong #X_ParBlockSize	_BlockMove	PushLong #DefaultHeader	lda Bptr	clc	adc Offset	tax	lda Bptr+2	adc #0	pha	phx	PushLong #7	_BlockMove	AddLong Offset,#7,Offset	lda [RealDptr]	inc a	sta [RealDptr]	lda [Rptr]	inc a	sta [Rptr]	inc Bpars	stz CRFlag	rts	SetRuler	ldy #0	DecLong RulerPtr	; start at column one	stz TabCntrulerLoop	iny	cpy #$50	bcs noMoreStops	lda [RulerPtr],y	and #$ff	cmp #'='	beq rulerLoopgotTabStop	sty TabPos		; save the tab stop's position (10ths)	ldx TabCnt	cpx #10	bcs noMoreStops	cmp #'<'	beq isLeftnotLeft	cmp #'.'	bne notDecimal	lda #X_scr_rt_decimal	bra setTabnotDecimal	cmp #'>'	bne isLeft	lda #X_scr_rt_right	bra setTabisLeft	lda #X_scr_rt_leftsetTab	pha		; save the tab's type (right, left, or decimal)	lda TabCnt		; get the count, and convert it to	asl a		;   an offset in the ruler record	asl a	clc	adc #X_scr_or_TabList	tay	lda TabPos		; retrieve the tab stop's position	and #$ff		;   and convert it to 80ths of an inch	jsl X_tenthsto80ths	clc	adc AWMinLM	ldx #X_scr_or_RightM	; if it's beyond the right margin, stop	cmp X_ScrStdRuler,x	bcs noMoreStops1	ldx #X_scr_or_LeftM	; if it's beyond the right margin, stop	cmp X_ScrStdRuler,x	bgt storetab	AddWord a,#10,a	; bump the ruler so tabs don't missalign tooooo much	cmp X_ScrStdRuler,x	ble back2loop	; still lessthan or equal, forget this onestoretab	phy	plx	sta X_ScrStdRuler,x	inx		; Now take care of the type	inx	pla		; retrieve the tab's type	sta X_ScrStdRuler,x		inc TabCnt	ldy TabPos	bra rulerLoopback2loop	pla	ldy TabPos	bra rulerLoopnoMoreStops1 planoMoreStops	lda TabCnt	bne setrulerout;	if it's beyond the right margin, stop	SubWord X_ScrStdRuler+X_scr_or_RightM,X_ScrStdRuler+X_scr_or_LeftM,a	lsr a	AddWord a,X_ScrStdRuler+X_scr_or_LeftM,a	sta X_ScrStdRuler+X_scr_or_TabList	lda #X_scr_rt_right	sta X_ScrStdRuler+X_scr_or_TabList+2	lda #1setrulerout	sta X_ScrStdRuler+X_scr_or_NumTabs	rtl	ENDP	END