* high level* NOTE:	All vector entries (PrOpenPage, etc...) get their data bank passed in A.*		This means that they can  phd, tcd  correctly.  Be careful what you do*		at the beginning of one of these routines!  ÑÑMSL;	 DynamicExits			;------------------------------------------------------------------------------;------------------------------------------------------------------------------;; Dynamic Exits;;; Each dynamic exit takes 2 RTS and moves them some number of bytes up the; stack.;;------------------------------------------------------------------------------;-----------------------------------------------------------------------------DynamicExits	PROC	EXPORT				EXPORT	exit20		exit20				tax				lda	5,s				sta	25,s				lda	3,s				sta	23,s				lda	1,s				sta	21,s				tsc				clc				adc	#20				tcs				txa				brl	exit0				EXPORT	Exit16		Exit16				tax				lda	5,s				sta	21,s				lda	3,s				sta	19,s				lda	1,s				sta	17,s				tsc				clc				adc	#16				tcs				txa				brl	Exit0				EXPORT	Exit14		Exit14				tax				lda	5,s				sta	19,s				lda	3,s				sta	17,s				lda	1,s				sta	15,s				tsc				clc				adc	#14				tcs				txa				brl	Exit0				EXPORT	Exit12		Exit12				tax				lda	5,s				sta	17,s				lda	3,s				sta	15,s				lda	1,s				sta	13,s				tsc				clc				adc	#12				tcs				txa				bra	Exit0				EXPORT	Exit10		Exit10				tax				lda	5,s				sta	15,s				lda	3,s				sta	13,s				lda 1,s				sta 11,s				pla				pla				pla				pla				pla				txa				brl exit0				EXPORT	Exit8		Exit8				tax				lda	5,s				sta	13,s				lda	3,s				sta	11,s				lda	1,s				sta	9,s				pla				pla				pla				pla				txa				brl	Exit0				EXPORT	Exit6		Exit6				tax				lda	5,s				sta	11,s				lda	3,s				sta	9,s				lda	1,s				sta	7,s				pla				pla				pla				txa				brl	Exit0				EXPORT	Exit4		Exit4				tax				lda	5,s				sta	9,s				lda	3,s				sta	7,s				lda	1,s				sta	5,s				pla				pla				txa				brl	Exit0				EXPORT	Exit2		Exit2				tax				lda	5,s				sta	7,s				lda	3,s				sta	5,s				lda	1,s				sta	3,s				pla				txa				EXPORT	Exit0		Exit0				cmp	#1				rtl																ENDP			;-----------------------------------------------------------;; PortOffset;; This is the offset to fields in the grafport.;				DSECT 0o_PortSCB		WORDo_ImageRef		LONGo_Width 		WORDo_BoundsRect	BLOCK 8o_PortRect		BLOCK 8o_ClipRgn		LONGo_VisRgn		LONGo_BkPat 		BLOCK 32o_PnLoc 		BLOCK 4o_PnSize		BLOCK 4o_PnMode		WORDo_PnPat 		BLOCK 32o_PnMask		BLOCK 8o_PnVis 		WORD				EXPORT o_FontID				EXPORT o_ChExtrao_Font			LONGo_FontID		LONGo_FontFlags		WORDo_TxSize		WORDo_TxFace		WORDo_TxMode		WORDo_SpExtra		LONGo_ChExtra		LONGo_FGColor		WORDo_BGColor		WORDo_PicSave		LONGo_RgnSave		LONGo_PolySave		LONGo_GrafProcs		LONGo_ArcRot		WORDo_UserField		LONGo_SysField		LONGPortSize		DSectSize; 	ZP Equates;------------------------------------------------------------------------------;; Global and Zero Page Equates;;------------------------------------------------------------------------------Temp1          equ 0                    Temp values to dereference easilyTemp2          equ temp1+4             4hPicList       equ temp2+4             apPicList       equ hPicList+4          eOurport        equ pPicList+4          12hOurport       equ OurPort+2           14hNewPic        equ hOurport+4          18ourStatus      equ hNewPic+4           1chStatus        equ ourStatus+2         1ehport          equ hStatus+4           22UserId         equ hPort+4             26hscreenport    equ userId+2            28pscreenport    equ hscreenport+4       2chprbuf         equ pscreenport+4       30pprbuf         equ hprbuf+4            34bandheight	   equ pprbuf+4			   38OldGraphProcs  equ bandheight+2		   3APZ_PrStatus    equ $C0PZ_pPrPort     equ PZ_PrStatus+4PZ_hPrint      equ PZ_pPrPort+4TPrintsize     equ 140StatRecSize    equ 28oPrintDefault  equ 0*5oPrValidate    equ 1*5oPrStlDialog   equ 2*5oPrJobDialog   equ 3*5oPrDrvrVer     equ 4*5oPrOpenDoc     equ 5*5oPrCloseDoc    equ 6*5oPrOpenPage    equ 7*5oPrClosePage   equ 8*5oPrPicfile     equ 9*5oPrControl     equ 10*5oPrError       equ 11*5oPrSetError    equ 12*5oPrChanged     equ 13*5oPrPixelMap    equ 14*5* Error CodesnoErr          equ 0iIOAbort       equ -27iMemFullErr    equ -108iPrAbort       equ 128;	 PrtRecord.equ			******************************							** PrtRecordEqu				**							** Current Rev: Nov. 1987	**							******************************Top 			equ	0Left			equ	2Bottom			equ	4Right			equ	6* offset for the TPrint record length = 140 bytesiPrVersion		equ	0		 Integer	Printing manager version numberprInfo			equ	2		 subrecord	Printer Info SubrecordrPaper			equ	16		 RectprStl			equ	24		 SubRecordprInfoPT		equ	42		 SubRecordprXInfo 		equ	56		 SubRecordprJob			equ	80		 SubRecordprintx			equ	100 	 Array[1..19] of integer (38 bytes)* prInfo subrecord length = 14 bytesidev			equ	0		 IntegeriVRes			equ	2		 IntegeriHRes			equ	4		 IntegerrPage			equ	6		 Rect* iDev valuesbDevCitoh		equ	1		 image writerbDevLaser		equ	3		 Laser writer* TPrJob subrecord length = 20 bytesiFstPage		equ	0		 IntegeriLstPage		equ	2		 IntegeriCopies 		equ	4		 IntegerbjDocLoop		equ	6		 Signed bytefFromUsr		equ	7		 signed bytepIdleProc		equ	8		 Long addresspFileName		equ	12		 Long addressiFileVol		equ	16		 Integer		  ??? Unit number ???bFileVers		equ	18		 signed bytebJobX			equ	19		 signed byte		internal* bjDocLoop valuesbDraftLoop		equ	0bSpoolLoop		equ	128* TPrStl subrecord info length = 18 byteswDev			equ	0		 IntegeriPageV			equ	2					nombres de points par pageiPageH			equ	4bPort			equ	6					Refnumfeed			equ	8PaperType		equ	10CRwidth 		equ	12* valeur du feedfeedcut 		equ	0feedfanFold	 equ	1* values linked to wDevf0				equ	1					hiresf1				equ	2					portraitf2				equ	4					double vertical densityf3				equ	8					2x zoomf4				equ	16					scrollf5				equ	32					color/bwf6				equ	64					Gapf7				equ 128					Darker* TprXInfo subrecord info length = 24 bytesiRowBytes		equ	0		 IntegeriBandV			equ	2		 IntegeriBandH			equ	4		 IntegeriDevBytes		equ	6		 Integeribands			equ	8		 IntegerbPatScale		equ	10		 bytebULThick		equ	11		 bytebULOffset		equ	12		 bytebULShadow		equ	13		 bytescan			equ	14		 tscanbXInfoX 		equ	16		 reservedSCBList 		equ	18		 pointer to a list of modes.scanTB			equ	0scanBT			equ	1scanLR			equ	2scanRL			equ	3* TPrStatus record length = 28 bytesiTotPages		equ	0iCurpage		equ	2iTotCopies		equ	4iCurCopy		equ	6iTotBands		equ	8iCurBand		equ	10fPgDirty		equ	12fImaging		equ	14ShPrint 		equ	16pPrPort 		equ	20hPic			equ	24;	 PrtRecord.Dflt	;Default print record			******************************							** PrtRecordDflt 			**							** Current Rev: Nov 1987 	**							******************************PrtRecordDflt	PROC	EXPORT				Export	hPrint_testhPrint_test		DC.L	pPrint_test				Export	pPrint_testpPrint_test		DC.L	Print_test					EXPORT	PRINT_TESTPrint_test* offset for the TPrint record length = 140 bytes				DC.B	$02,$02 			*iPrVersion 	equ  0*prInfo 		equ  2		  				subrecord  Printer Info Subrecord* prInfo subrecord length = 14 bytes				DC.W	1					*idev			equ  0				DC.W	72					*iVRes			equ  2				DC.W	80					*iHRes			equ  4				DC.W	0,0,396,640 		*rPage $$$$$	equ  6				DC.W	-36,-20,752,660 	*rPaper 		equ  16*											*prStl			equ  24 	  SubRecord* TPrStl subrecord info length = 18 bytes;; wDev is set initially to be normal quality, portrait, normal vertical; density, no reduction, B/W, and with gap.;				DC.W	f1+f2+f3+f6 		wDev			equ	0				DC.W	1320				iPageV			equ	2				DC.W	1020				iPageH			equ	4				DC.W	0					bPort			equ	6				DC.W	1					feed			equ	8				DC.W	0					PaperType		equ	10				DC.W	960 				CRwidth 		equ	12				DC.W	0					reserved				DC.W	0*prInfoPT		equ  42 	  SubRecord				DC.W	0					*idev			equ  0				DC.W	72					*iVRes			equ  2				DC.W	80					*iHRes			equ  4				DC.W	0,0,396,640 		*rPage			equ  6*prXInfo		equ  56 	  SubRecord				DC.W	80					iRowBytes		equ	0				DC.W	32					iBandV			equ	2				DC.W	640 				iBandH			equ	4				DC.W	10240				iDevBytes		equ	6				DC.W	12					ibands			equ	8				DC.B	0					bPatScale		equ	10				DC.B	1					bULThick		equ	11				DC.B	1					bULOffset		equ	12				DC.B	1					bULShadow		equ	13				DC.B	0					scan			equ	14				DC.B	0					bXInfoX 		equ	16				DCB.B	8,0					reserved*prJob			equ  80 	  SubRecord* TPrJob subrecord length = 20 bytes				DC.W	1					iFstPage		equ	0				DC.W	9999				iLstPage		equ	2				DC.W	1					iCopies 		equ	4				DC.B	$80 				bjDocLoop		equ	6				DC.B	1					fFromUsr		equ	7				DC.L	0					pIdleProc		equ	8				DC.L	0					pFileName		equ	12				DC.W	0					iFileVol		equ	16				DC.B	0					bFileVers		equ	18				DC.B	0					bJobX			equ	19*printx 		equ  100	  Array[1..19] of integer (38 bytes)				DC.W	0	plus two reserved bytes				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0				DC.W	0*TPrintsize 	equ  140				Export	GapGap 			DC.W	0				DC.W	60				Export	VresVres			DC.W	36				DC.W	72				Export	HresHres			DC.W	40				DC.W	80				Export	PaperVsizePaperVsize		DC.W	1320				DC.W	1680				DC.W	1400				DC.W	1440				Export	PaperHsizePaperHsize		DC.W	1020				DC.W	1020				DC.W	990				DC.W	990				Export	CarriageWidthCarriageWidth	DC.W	960				DC.W	960				DC.W	960				DC.W	960* US Letter/640 portrait gap:				36 80 0 0 378 640  -9 -20 387 660* US Letter/640 landscape gap:				40 72 0 0 320 756 -10 -18 330 774				ENDP										;	 Maindata			******************************							** MainData					**							** Current Rev: Nov. 1987	**							******************************MainData		PROC	EXPORT				Export EndTime,DrawTime,PortTime,TmpTime,StartTimeStartTime		DS.B 4EndTime			DS.B 4DrawTime		DS.B 4PortTime		DS.B 4TmpTime			DS.B 4				Export	ZeroPageZeroPage		DS.B	2				Export	iPrErriPrErr			DS.B	2				Export	iPageNumiPageNum		DS.B	2				Export	PicListCountPicListCount	DS.B	2					; count of pages used in piclist 				Export	iDocPageiDocPage		DS.B	2				Export	MethodMethod			DS.B	2				Export	hPrinthprint			DS.B	140					TPrintsize				Export	rBandrBand			DS.B	8					rect				Export	LinesLeftOnPageLinesLeftOnPage DS.B	2				  ; # of lines left to be printed				Export	LinesPerPageLinesPerPage	DS.B	2					; total # of lines on each page				Export	resolutionresolution		DS.B	2				Export	MainUserIDMainUserID		DS.B	2				Export	BandPortBandPort		DS.B	portsize				Export	ScreenPortScreenPort		DS.B	portsize				Export	OurStatusRecordOurStatusRecord DS.B	StatRecSize;; flag to indicated	if status or progress messages can be displayed, set to; false by PrPixelMap since it doesn't put up a window;				EXPORT NoShowMessageNoShowMessage	DS.B 2				EXPORT	PStatusPStatus			DS.B	2					; printer status: 0 = OK				EXPORT CursorAdCursorAd		DS.B 4				Export	BandLocBandLoc 		DS.B	20				Export	RectSize1RectSize1		DC.W	0,0,$10,$10				Export	RectSize2RectSize2		DC.W	0,0,$20,$20				Export	SizingRectSizingRect		DS.B	8				Export	hugeRecthugeRect		DC.W	0,0,16382,16382* you'd better not to be outside this hugeRect !!!				Export	PPParmsPPParms 		DC.L	BandPort				DC.L	ScreenPort				DC.L	BandLoc+8				DC.L	destpoint				DC.W	0						; PenCopy				DC.W	0						; maskhandle				DC.W	0				Export	destpointdestpoint		DC.W	0,0,32,320	home				Export	Pt1Pt1 			DC.W 20,25				Export	Pt2Pt2 			DC.W 110,60				Export	Pt3Pt3 			DC.W	5,210	if LQ=1 goto .notimagewriter				EXPORT	Printer_namePrinter_name	str '='				str 'ImageWriter'				str '*'	goto .notlq				.notimagewriter				EXPORT	Printer_namePrinter_name	str '='				str 'LQ'				str '*'.notlq				Export	TESTRECTTESTRECT		DC.W	15,20,100,200				Export	whitewhite			DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff				DC.W	$ffff												Export	grisgris			DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888				DC.W	$8888								Export DeadLoc2 			DeadLoc2		DS.B 32				Export LLD_PaperRectLLD_PaperRect	DS.B 8				ENDP																					;	 ErrorCalls.ASM	;_PrError, _PrSetError			;*****************************************************************************;*****************************************************************************;;  NAME:		PrError;;  PURPOSE:	 High level printer routine "_PrError" which returns last error;				that has occured (iPrErr).;;  PASSED:		(None);;  RETURNED:	LastError				WORD, last error that occured.;;*****************************************************************************;*****************************************************************************PrError 		PROC	EXPORT				DefineStack* iPrErr* parameters* error valueError_DPage		word 0Error_BReg		byte 0Error_rtl1		block 3Error_rtl2		block 3Error_Value		word 0				phd				tcd				phb				phk				plb				lda iPrErr				;get the error value				sta Error_Value,s		;return it on the stack				lda #0				plb				pld				jmp exit0				EJECT;*****************************************************************************;*****************************************************************************;;  NAME:		PrSetError;;  PURPOSE:	 High level printer routine "_PrSetError" which sets the error;				value (iPrErr).;;  PASSED:		ErrorNumber				WORD, error number to be saved.;;  RETURNED:	(NONE);;*****************************************************************************;*****************************************************************************				EXPORT	PrSetError	PrSetError* parameters* error value				DefineStackSetError_DPage	word 0SetError_BReg	byte 0SetError_rtl1	block 3SetError_rtl2	block 3SetError_value	word 0				phd				tcd				phb				phk				plb				lda SetError_value,s 	;get the passed error value				sta iPrErr				;save it at iPrErr								cmp #$0080				bne NoCancel								lda DraftFlag				beq NoCancel								pea 0				pea 0				_SetGrafProcs								stz DraftFlagNoCancel		lda #0				plb				pld				jmp exit2				ENDP										EJECT;*****************************************************************************;*****************************************************************************;;  NAME:		PrChanged;;  PURPOSE:	 This routine calls the port driver with the name and type;     		 of this printer (IMAGEWRITER).;;  PASSED:		<None>;;  RETURNED:	(NONE);;*****************************************************************************;*****************************************************************************PrChanged		PROC	EXPORT				phd				phb				phk				plb				tcd				PushPtr Printer_Name				_PrDevPrChanged				plb				pld				jmp exit0				ENDP						;	 DraftProcs						;******************************************************************************;******************************************************************************;** 																		 **;** 																		 **;** 			I M M E D I A T E	M O D E	 P R O C S.					 **;** 																		 **;** 																		 **;******************************************************************************;******************************************************************************Draftprocs		PROC	EXPORT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  Standard Pixel Procedure (Prints Pixel Maps);;------------------------------------------------------------------------------;------------------------------------------------------------------------------				EXPORT	Pixel		Pixel			;----------------------------------------------------------------------;; QuickDraw II's zeropage equates;QdPort			equ $24SrcPixelMapRef	equ $CE					; ptr to src pixel mapSrcWidth		equ $D2					; width of src pixel mapSrcBounds		equ $D4					; bounds rect of src pixel mapSrcRect 		equ $DCDestRect		equ $1CDrawVerb		equ $38TextPtr 		equ $datextLength		equ $d8chartodraw		equ $d6				phb				phk				plb				lda iPrErr				beq Continueexitnow 		brl ExitPixel;----------------------------------------------------------------------;; Gets information about the source pixel map from QD's zero page.;Continue	;				lda [QdPort] 			; SCB				sta pixelLoc				lda srcPixelMapRef		; pointer to the pixel map				sta pixelLoc+2				lda srcPixelMapRef+2				sta pixelLoc+4				lda SrcWidth 			; width of pixel map				sta pixelLoc+6				ldx #6					; bounds rectmoveBounds		lda srcBounds,x				sta PixelLoc+8,x				dex				dex				bpl moveBounds				PushWord #0				; Result				PushWord #0				; bank address of zero page				tdc						; transfer direct page into acc				clc				adc #srcBounds			; get actual address of srcBounds				pha				PushWord #0				; bank address of zero page				tdc						; transfer direct page into acc				clc				adc #srcRect 			; get actual address of srcRect				pha				PushLong #PixelRect		; intersected rect goes here				_SectRect				pla				beq ExitPixel			; if false, no intersection;---------------------------------------------------------------;; Look at the source rect.	If its upper/left corner is 0,0; then no adjustment is necessary.	If it is not 0,0, we must; adjust the pointer to the pixel map so that it points to; the first pixel in the source rect.;; Note that this scheme does not work with source rects that; do not have the first pixel to draw as the first pixel in; a byte.;				lda		PixelRect				sec				sbc		PixelLoc+8				beq		NoAdjustmentY				pha						; space for result				pha				pha						; Top of src rect				PushWord PixelLoc+6		; width				_Multiply				pla				clc				adc PixelLoc+2				sta PixelLoc+2				pla				adc PixelLoc+4				sta PixelLoc+4NoAdjustmentY	;				lda PixelRect+2				sec				sbc PixelLoc+10				beq NoAdjustmentX				lsr a				bit PixelLoc-1				bpl ModeWas320				lsr aModeWas320		clc				adc PixelLoc+2				sta PixelLoc+2				bcc NoCarryHere				inc PixelLoc+4NoCarryHere ;NoAdjustmentX	;				lda PixelRect				sta PixelLoc+8				lda PixelRect+2				sta PixelLoc+10				lda PixelRect+4				sta PixelLoc+12				lda PixelRect+6				sta PixelLoc+14;------------------------------------------------------------;; Call LLDBitMap using the adjusted (if necessary) values in; PixelLoc and PixelRect.;				pushptr PixelLoc 		; source Loc info				pushptr PixelRect		; source rect				pushword MainUserID				lda hprint+prstl+wdev				and #f7				jsl LLDBitmap				lda #0ExitPixel		clc				plb				rtlPixelLoc	DS.B 16 					; changed from 8 to 16 by Suki 6/1/87PixelRect	DS.B 8;------------------------------------------------------------------------------;------------------------------------------------------------------------------;; _StdText Procedure (Prints Standard Text);;------------------------------------------------------------------------------;------------------------------------------------------------------------------				EXPORT	DraftText	DraftText				phb						;save data bank reg. on stack				phk						;get program bank reg.				plb						;use as data bank reg.				PushPtr PenPos				_GetPen					;current pen pos. -> PenPos* here we move the printer head to penpos				asl PenPos				lda hPrint+prStl+wdev				and #f2					; condensed?				beq By2Only				; yes, skip the next multiply				asl PenPos* I think PenPos is in 144 th/inch vertically.By2Only 		PushLong PenPos				pushword MainUserID				jsl LLDSetPenPos				PushWord #0				;space for textwidth;										;(for call to _TextWidth)				lda DrawVerb 			;get the DrawVerb				beq DoCar				;if DrawVerb=0 then DoCar				cmp #1				beq dotext2				;if DrawVerb=1 then DoText2;;We get here if it's a "C" string (DrawVerb=2);DoCstring	;							; Cstrings are handled differently				sep #$20 				; since the string is terminated				longa off				; by a 0 and no length is kept;Search down through string looking for terminator to calculate length				ldy #0KeepLooking	 	lda [TextPtr],y				beq TheEnd				iny				bra KeepLookingTheEnd			rep #$20				longa on				lda TextPtr+2				pha						;push the pointer to string				lda Textptr				pha				phy						;push the length of string				bra common;;We get here if it's just one character (DrawVerb=0);DoCar	;				pushword #0				tdc				clc				adc #chartodraw			;calculate addr. of char.				pha						;push addr. of character				Pushword #1				;push length of one char.				bra common;;We get here if it's a string of text (DrawVerb=1);DoText2 ;				lda TextPtr+2				pha						;push pointer to the string				lda Textptr				pha				lda textLength				pha						;push the strings lengthcommon			lda 5,s					; Dup the last 3 words on the				pha						; stack to be used with TextWidth				lda 5,s				pha				lda 5,s				pha* here we send the text on the printer				pushword MainUserID;-----------------------------------------------------------------------;; The stack should look like this at this point:;		 ...;		 00 (result space) --;		 TextPtr			|	parameters for TextWidth;		 length 			--;		 TextPtr			--;		 length 			|	parameters for PrText;		 UserID 			--; sp ->				jsl LLDText				;print the text				_TextWidth				;get the texts width (DH)				Pushword #0				;set (DV)=0				_move					;move current pen locationExitText		lda #0					;return with no errors				clc				plb						;restore data bank				rtlPenPos			DS.B 4				ENDP						;;	 Metrics		  ;_PrDefault, _PrValidate, _PrStlDialog;										;_PrJobDialog			metrics 		PROC	EXPORT;*****************************************************************************;*****************************************************************************;;  NAME:		PrDefault;;  PURPOSE:	 High level printer routine "_PrDefault" which fills the fields;				of the specified print record with default values for this;				particular printer.;;  PASSED:		PrintRecordHandle		LONG, Handle to print record.;;  RETURNED:	(None);;*****************************************************************************;*****************************************************************************				EXPORT	PrDefault	PrDefault				EXPORT	PrintDefault				;alias for PrDefaultPrintDefault* parameters* hprint				DefineStackDefault_DPage	word 0Default_BReg	byte 0Default_rtl1	block 3Default_rtl2	block 3Default_hprint	long 0				phd				tcd				phb				phk				plb				sta ZeroPage;See if user passed a valid handle				lda Default_hPrint,s				ora Default_hPrint+2,s				bne notNIL;;We arrive here if an invalid handle, we must flag as an error;				lda #NoPrintRecord				bra ExitnotNil	;*										read the handle;;Copy the default print record "Print_test" to internal hprint buffer;;; Transfer the print record to the internal print record,; this is necessary because CiXmetrics expects the print; record in hprint;				pushptr Print_test				pushptr hprint				pushlong #TPrintsize				_blockmove				jsr CiXmetrics			;set metrics from defaults;;Dereference the "PrintRecordHandle" that was passed to Temp1;				lda Default_hPrint,s				sta temp1				lda Default_hPrint+2,s				sta Temp1+2				pushlong #hprint 		; moves good values into				pushlong Temp1			; application's print record				pushlong #TPrintSize				_PtrToHand				bcs Exit 				; memory manager error				lda #$0000exit			plb				pld				jmp exit4				EJECT;*****************************************************************************;*****************************************************************************;;  NAME:		PrValidate;;  PURPOSE:	 High level printer routine "_PrValidate" which checks the;				specified print record for compatibility with the printer.;				If the print record is valid, it returns FALSE, and if it;				is invalid, it returns TRUE and adjusts the print record;				values to the defaults.;;  PASSED:		PrintRecordHandle		LONG, Handle to the print record.;;  RETURNED:	ChangeFlag				WORD, Boolean.;;*****************************************************************************;*****************************************************************************				EXPORT	PrValidate	PrValidate		* parameters* results* hPrint				DefineStackValidate_DPage 	word 0					;Saved D-PageValidate_BReg  	byte 0					;Saved B-Reg.Validate_rtl1  	block 3Validate_rtl2  	block 3Validate_hPrint	long 0					;Passed print record handleValidate_Result	word 0					;returned changeflag				phd						;save the d page reg.				tcd				phb				phk				plb				lda #False				; assume no change to print				sta Validate_Result,s	; record at start				lda Validate_hPrint,s	; get the handle off the stack				sta temp1				; and put into a temp location				lda Validate_hPrint+2,s				sta Temp1+2;------------------------------------------------------------;; Transfer the print record to the internal print record,; this is necessary because CiXmetrics expects the print; record in hprint;				PushLong Temp1				PushLong #hprint				PushLong #TPrintSize				_HandToPtr				bcs ErrorExit			; memory manager error;-----------------------------------------------------------------;; Test if correct printer type ( 1 = imagewriter 3 = Laserwriter ); and correct version number;				lda hprint+prInfo+idev				cmp #1					; this is ImageWriter driver				bne WrongType				lda hprint+iPrVersion	; check if correct version				xba						; swap since hi-lo bytes are				cmp #VersionNb			; swapped during lda				beq GoodTypeWrongType		pushptr Print_test		; move default values in				pushptr hprint				pushlong #TPrintSize				_blockmove				lda #True				; set result to reflect a				sta Validate_Result,s	; change in print recordGoodType	;				jsr CiXmetrics				pushlong #hprint				pushlong Temp1				pushlong #TPrintSize				_PtrToHand				bcs ErrorExit			; memory manager error				lda #0ErrorExit		plb				pld				jmp exit4				EJECT;*****************************************************************************;*****************************************************************************;;  NAME:		PrStlDialog;;  PURPOSE:	 High level printer routine "_PrStlDialog", which performs a;				style dialog with the user.	The initial settings are taken;				from the print record.  If the user confirms the dialog, the;				results are saved in the print record and "_PrValidate" is;				called and the routine returns TRUE.  If not, the print record;				is left unchanged and returns FALSE.;;  PASSED:		PrintRecordHandle		LONG, Handle to the print record.;;  RETURNED:	ConfirmFlag				WORD, Boolean.;;*****************************************************************************;****************************************************************************** buttonstate for Style* +0	US Letter						Default* +2*1	US Legal* +2*2	Computer Paper* +2*3	A4 Letter* +2*4	International Fanfold* +2*5	Condensed Vsizing* +2*6	50% reduction* +2*7	No Gaps Between Pages* +2*8	Portrait* +2*9	Landscape* +2*10 Normal Vsizing				EXPORT	PrStlDialog PrStlDialog	* parameters* results* hPrint				DefineStackStlDialog_DPage	word 0StlDialog_BReg	byte 0StlDialog_rtl1	block 3StlDialog_rtl2	block 3StlDialog_hPrint	long 0 				;PrintRecordHandleStlDialog_result	word 0 				;ConfirmFlag results				phd				tcd				phb				phk				plb				sta ZeroPage;Copy the passed "PrintRecordHandle" to PZ_hprint and lock it				lda	StlDialog_hPrint,s				sta	PZ_hprint				lda	StlDialog_hPrint+2,s				sta	PZ_hprint+2				pushlong PZ_hprint				_hlock				_error;; call PrValidate to check if printer type is same;				PushWord #0				PushLong PZ_hprint				_PrValidate				;validate the print record				plx				bcc MoveOn				brl ErrorExit1			; memory manager error;MoveOn			lda [PZ_hprint]				tax				ldy #2				lda [PZ_hprint],y				sta PZ_hprint+2			;dereferences				stx PZ_hprint;;Copy the passed print record data to the internal print record "hprint".;				ldy	#TPrintsize-2		 pairslooph			lda	[PZ_hprint],y				sta	hprint,y				dey				dey				bpl	slooph;;Clear all the button states;				lda #$0000				ldx #26clrbtn			sta buttonstate,x				dex				dex				bpl clrbtn;;Validate paper type and sets the appropriate button state;				lda hprint+prStl+PaperType				cmp #4				blt valid;We get here if the paper type is invalid (default to zero)				stz hprint+prStl+PaperType				lda #0Valid										; what if the prtrecord				asl a					; never did go through				tax						; prdefault;This sets the appropriate button state				lda #$ffff				sta buttonstate,x		; et voila pour le papier;;This initilizes the portrait/landscape buttonstate;				lda hprint+prstl+wdev				and #f1					;check for portrait mode				beq do9				dec buttonstate+2*8		;set portrait				bra over9do9 			dec buttonstate+2*9		;set landscapeover9	;;;This initilizes the 50% reduction buttonstate;				lda hprint+prstl+wdev				and #f3					;check for 50% reduction				bne over6				dec buttonstate+2*6		;set 50% reductionover6	;;;This initilizes the no GAP buttonstate;				lda hprint+prstl+wdev				and #f6					;check for no GAP				bne over7				dec buttonstate+2*7		;set for no GAPover7	;				lda hprint+prstl+wdev				and #f2					2Vsize				beq do5				dec buttonstate+2*10				bra over5do5 			dec buttonstate+2*5over5	;;------------------------------------------------------------------------------;Now call "StyleDialog" to do the actual dialog work;------------------------------------------------------------------------------				jsr styledialog				sta StlDialog_result,s	;save results on stack				bne okStyle				;branch if confirmed dialog				brl outStyle 			;branch if canceled dialog;;We get here if the user confirmed and we can update the print record;okStyle ;* +0	US Letter						Default* +2*1	US Legal* +2*2	International Fanfold* +2*3	A4 Letter* +2*4	Computer Paper;;Now figure out which paper size was selected;				ldx #0				lda buttonstate+2*0		;see if US Letter				bmi NewPaperSize				inx				lda buttonstate+2*1		;see if US legal				bmi NewPaperSize				inx				lda buttonstate+2*2		;see if Internationl Fanfold				bmi NewPaperSize				inxNewPaperSize	stx hprint+prStl+PaperType		;now set paper type;;Now see about vertical sizing;				lda #f2					2Vsize				tsb hprint+prstl+wdev				bit buttonstate+2*5				bpl no2				trb hprint+prstl+wdevno2 ;;;Now see if GAP or NO GAP was selected;				lda #f6					Gap				tsb hprint+prstl+wdev				bit buttonstate+2*7				bpl no6				trb hprint+prstl+wdevno6 ;;;Now see if 50% reduction was selected;				lda #f3					2x zoom				tsb hprint+prstl+wdev				bit buttonstate+2*6				bpl no3				trb hprint+prstl+wdevno3 ;;;Now see which of portrait/landscape was selected;				lda #f1					portrait				tsb hprint+prstl+wdev				bit buttonstate+2*9				bpl no1				trb hprint+prstl+wdevno1 ;				Jsr CiXmetrics			;go calculate the metrics;;Now copy the internal print record to the users;				ldy	#TPrintsize-2		 pairslooph2 		lda	hprint,y				sta	[PZ_hprint],y				dey				dey				bpl	slooph2;;We get here when we are done or the user canceled the dialog;OutStyle		lda #0ErrorExit1		plb				pld				jmp exit4				EJECT;*****************************************************************************;*****************************************************************************;;  NAME:		PrJobDialog;;  PURPOSE:	 High level printer routine "_PrStlDialog", which performs a;				job dialog with the user.  The initial settings are taken;				from the print record.  If the user confirms the dialog, the;				results are saved in the print record and "_PrValidate" is;				called and the routine returns TRUE.  If not, the print record;				is left unchanged and returns FALSE.;;  PASSED:		PrintRecordHandle		LONG, Handle to the print record.;;  RETURNED:	ConfirmFlag				WORD, Boolean.;;*****************************************************************************;****************************************************************************** buttonstate for JobDialog* +0	best* +2*1 faster* +2*2 Draft* +2*3 all pages* +2*4 from pages* +2*5 paper auto* +2*6 paper hand* +2*7 value for From* +2*8 Value for To* +2*9 value for Copies* +2*10 color/bw* +2*11 darker				EXPORT	PrJobDialog PrJobDialog* prarmeters* results* hPrint				DefineStackJobDialog_DPage	word 0JobDialog_BReg	byte 0JobDialog_rtl1	block 3JobDialog_rtl2	block 3JobDialog_hPrint	long 0 				;passed PrintRecordHandleJobDialog_result	word 0 				;returned ConfirmFlag;First save registers and setup environment				phd				tcd				phb				phk				plb				sta ZeroPage;;Make a copy of the passed print record handle at "PZ_hprint" and lock it;				lda	JobDialog_hPrint,s				sta	PZ_hprint				lda	JobDialog_hPrint+2,s				sta	PZ_hprint+2				pushlong PZ_hprint				_hlock					;lock the handle				_error;; call PrValidate to check if printer type is same;				PushWord #0				PushLong PZ_hprint				_PrValidate				plx				bcc OnWard				brl ErrorExit2			;memory manager error;;Dereferences the handle at "PZ_hprint";Onward			lda	[PZ_hprint]				tax				ldy	#2				lda	[PZ_hprint],y				sta	PZ_hprint+2 		dereference				stx	PZ_hprint;;This copies the passed print record data to the internal print record "hprint";				ldy	#TPrintsize-2		 pairlooph			lda	[PZ_hprint],y				sta	hprint,y				dey				dey				bpl	looph;;This initializes all the buttonstates to zero;				lda #$0000				ldx #28clrbtn2 		sta buttonstate,x				dex				dex				bpl clrbtn2;;This sets the correct buttonstate for print quality; BEST, FASTER, DRAFT;				lda #$80				and hprint+prJob+bjDocLoop				bne BetOrFast				dec buttonstate+2*2		;set DRAFT				bra jover1;We get here if it could be BEST or FASTERBetOrFast	;				lda hprint+prstl+wdev				and #f0				beq jover0				dec buttonstate+2*0		;set BEST				bra jover1jover0			dec buttonstate+2*1		;set FASTjover1	;;;This sets the correct buttonstate for paper feed; AUTOMATIC, HAND FEED;				lda hprint+prStl+feed				cmp #feedfanfold				beq doauto				dec buttonstate+2*6		;set HAND FEED				bra doHanddoauto			dec buttonstate+2*5		;set AUTOMATICdoHand	;;;This sets the COLOR/BW buttonstate;				lda hprint+prstl+wdev				and #f5				beq jover10				dec buttonstate+2*10 	;set COLORjover10 ;;This sets the Darker buttonstate;				lda hprint+prstl+wdev				and #f7				beq jover11				dec buttonstate+2*11 	;set Darkerjover11 ;;;This always initilizes the page range to ALL;				dec buttonstate+2*3		always all;;This sets FROM=1, COPIES=1 and TO=999;				lda #1				sta buttonstate+2*7		;init. FROM to 1				sta buttonstate+2*9		;init. COPIES to 1				lda #999				sta buttonstate+2*8		;init TO to 999;------------------------------------------------------------------------------;Now call "JobDialog" to do the actual dialog work;------------------------------------------------------------------------------				jsr jobdialog				sta JobDialog_result,s	;save results				bne okJob				;branch if OK				brl outJoB				;branch if CANCELokJob	;* we need to update the quality values:** prstl.wdev f0* prXinfo.idevbytes will be calculated by CiXmetrics*;;This sets up the COLOR/BW bit appropriately;				lda #f5				trb hprint+prstl+wdev	;clear the COLOR/BW bit				bit buttonstate+2*10				bpl no4				tsb hprint+prstl+wdev	;set to COLORno4 ;;;This sets up the Darker bit appropriately;				lda #f7				trb hprint+prstl+wdev	;clear the Darker bit				bit buttonstate+2*11				bpl no7				tsb hprint+prstl+wdev	;set to Darkerno7;;;This sets up the BEST bit appropriately;				lda #f0				trb hprint+prstl+wdev	;clear the BEST bit				bit buttonstate+2*0				bpl no0				tsb hprint+prstl+wdev	;set the BEST bitno0 ;;;This sets up the DRAFT bit appropriately;				lda #$80				tsb hprint+prJob+bjDocLoop		;clears the DRAFT bit				bit buttonstate+2*2				bpl notdraft				trb hprint+prJob+bjDocLoop		;sets the DRAFT bitnotdraft	;* then the paper range* PrJob.ifstpage, iLst page, iCopies* if all then first := 1 ; last := 9999 ; icopies := 1* else user value;;This copies FROM, TO, and COPIES;				lda Buttonstate+2*7				sta hprint+prjob+ifstpage				lda Buttonstate+2*8				sta hprint+prjob+ilstpage				lda Buttonstate+2*9				sta hprint+prjob+iCopies* then the paperfeeding* prStl.feed := feedfanfold (A) or feedcut		;;This sets paper feed;				lda #feedfanfold				sta hprint+prStl+Feed	;assume AUTOMATIC				lda buttonstate+2*5		;get buttonstate from dialog				bmi no5_2				;branch if assumption was correct				lda #feedcut 			;else its HAND FEED				sta hprint+prStl+Feedno5_2	;				jsr CiXmetrics			;go calculate the metrics;;Now copy the internal print record to the users data area;				ldy	#TPrintsize-2		 pairlooph2			lda	hprint,y				sta	[PZ_hprint],y				dey				dey				bpl	looph2;;We get here when we are done or the user canceled the dialog;OutJob			lda #0ErrorExit2		plb				pld				Jmp exit4				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		CiXmetrics;;  PURPOSE:	 Calculates metrics of page;;  PASSED:		(None);;  RETURNED:	(None);;------------------------------------------------------------------------------;------------------------------------------------------------------------------				EXPORT	CiXmetrics	CiXmetrics;;NOTE: print resolution is calculated in 120 dots per inch.;* first find out the resolution				stz resolution			;init. to zero (assume 320)				pha				_GetMasterSCB				pla				sta DeadLoc2				and #$80				beq r320				inc resolution			;we get here if its 640r320	;* Landscape (f1)	 { 0=landscape ; 1=Portrait }* PaperType (0,1,2,3) { 0= Us Letter; 1= US Legal; 2= A4 Letter; 3= int'l fold}* CarriageWidth (0,1,2,3) same* Resolution (0,1)	  { 0=320 ; 1=640 }* Gap (0,1)* if 50% (f3) then all resolution are twice as big* newVmargin: Landscape(Gap,f6:(PaperHsize,PaperType - CarriageWidth,paperType))*			  mul Landscape(Vres:Hres) div 240* newHmargin: Landscape((PaperHsize,PaperType - CarriageWidth,paperType):Gap,f6)*			  mul Landscape(Hres:Vres),resolution div 240* NewPaperVsize: Landscape(PaperVsize:CarriageWidth),PaperType*				 Mul Landscape(Vres:Hres) div 120 - 2*newVmargin** NewPaperHsize: Landscape(CarriageWidth:PaperVsize),PaperType*				 Mul Landscape(Hres:Vres),resolution div 120* rPage := 0,0,NewPaperVsize,NewPaperHsize* rPaper := -newVmargin,-newHmargin,NewPaperVsize+newVmargin,*			 NewPaperHsize+newHmargin* go for it;------------------------------------------------------------------------------;;Calculates TOP, LEFT, BOTTOM, RIGHT for papers rectangle "rPaper";;------------------------------------------------------------------------------* newVmargin: Landscape(Gap,f6:(PaperHsize,PaperType - CarriageWidth,paperType))*			  mul Landscape(Vres:Hres) div 240				lda resolution				asl a					;times two				tax						;use as index				lda Hres,X				;get horz. resolution				sta hprint+prInfo+iHRes	;init horz. pixel resolution;???????????????????????????lda Vres,X (because its the same value)				lda Vres				sta hprint+prInfo+iVres	;init. vertical pixel resolution				stz TableIndex			;init index;;First see which mode (portrait or landscape);				lda #f1					;see if landscape				and hprint+prstl+wDev				bne Portt				;branch if portrait;We get here if landscape (set index to landscape table entries)				lda #IntLandVals-IntPortVals	 ;set index to landscape values				sta TableIndex				;-----------------------------------------------------------------------;This wasn't being done at all.	*BugFix*				ÑMSL 10/15/88;;Now fix the resolutions, swapping and halving or doubling each as needed. ;				lda hprint+prInfo+iHRes	; horz. pixel resolution				lsr a				tay				lda hprint+prInfo+iVres	; vertical pixel resolution					asl a				sta hprint+prInfo+iHRes				sty hprint+prInfo+iVres;Now take paper type and multiply by 10 because each entry is 10 bytes longPortt	;				lda hprint+prStl+PaperType		;get paper size type				asl a					;first mult. by 8 (10 byte table)				asl a				asl a				clc				adc hprint+prStl+PaperType		;times 9				adc hprint+prStl+PaperType		;times 10				adc TableIndex			;add in initial table index				tax						;we now have the correct index;;Now move the initial paper values from the table;				ldy #0					;init loop counterMvIntVals	;				lda IntPortVals,X		;get initial values from table				sta Hprint+rPaper+Top,Y	;set "rPaper" values				inx				inx				iny				iny				cpy #8				bne MvIntVals				lda IntPortVals,X		;get initial assocaiated GAP value				sta TableIndex			;save the GAP value at TableIndex;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Now see if 320 or 640 mode (because table were designed for 640 mode)				lda resolution				bne Rez640				;branch if 640 (no modification needed);With 320 mode, we need to modify				clc						; do a signed divide by 2 because left may be				lda HPrint+rPaper+Left	; negative in portrait mode.				bpl @1				sec@1				ror HPrint+rPaper+Left				lsr Hprint+rPaper+Right	; (right never negative so can do unsigned div)Rez640	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Now see if GAP				lda #f6				and hprint+prstl+wDev				beq noGap1;;We Get here if GAP;				lda TableIndex			;get the GAP value				bmi LandGAP				;if negative, its landscape GAP;We get here if portrait GAP				eor #$ffff				;first we must make negative				ina				sta Hprint+rPaper+Top	;set "rPaper" TOP to GAP				clc				adc Hprint+rPaper+Bottom				sta Hprint+rPaper+Bottom ;set "rPaper" BOTTOM with GAP				bra noGap1;We get here if landscape GAPLandGAP ;				sta Hprint+rPaper+Left	;set "rPaper" LEFT to GAP				clc				adc Hprint+rPaper+Right				sta Hprint+rPaper+Right	;Adjusted  "rPaper" Right with GAPnoGap1	;;;Now see if 50% reduction (twice the resolution) was selected;				lda #f3				and hprint+prStl+wDev				bne notHalf1 			;branch if no 50% reduction selected;We get here if 50% reduction (multiply TOP, LEFT, BOTTOM, RIGHT by two)				ldx #0HalfResLoop ;				asl Hprint+rPaper+Top,X	;multiply by two				inx						;go to next value				inx				cpx #8				bne HalfResLoop				asl hprint+prInfo+iHRes	;multiply horz. pixel resolution by 2				asl hprint+prInfo+iVRes	;multiply vertical pixel resolution by 2notHalf1	;;;Now see if condensed vertical resolution was selected;				lda #f2				and hprint+prstl+wDev				bne NormVSize			;branch if normal vertical size;We get here when condensed vertical size was selected				asl Hprint+rPaper+Bottom				asl Hprint+rPaper+Top				asl hprint+prInfo+iVRes	;update rPage vResNormVSize	;;------------------------------------------------------------------------------;;Calculate the page rectangle "rPage";;------------------------------------------------------------------------------;; update hprint+prInfo+rPage for now, prInfoPT will be updated later;				stz hprint+prInfo+rPage+Top		;init TOP to zero				stz hprint+prInfo+rPage+Left	 ;init LEFT to zero				lda hprint+rPaper+Bottom				clc				adc hprint+rPaper+Top				sta hprint+prInfo+rPage+Bottom  ;set BOTTOM				lda hprint+rPaper+Right				clc				adc hprint+rPaper+Left				sta hprint+prInfo+rPage+Right	;set RIGHT;;Now copy the new calculated PrInfo subrecord to PrInfoPT subrecord;* Update the PrInfoPT record also				ldy #12UpdatePT		lda hprint+PrInfo,y				sta hprint+PrInfoPT,y				dey				dey				bpl UpdatePT;;Now determine physical papers resolution;				lda hprint+prStl+PaperType				asl a				tax				lda PaperVsize,x				sta hprint+PrStl+iPageV			;set pages vertical res.				lda PaperHsize,x				sta hPrint+PrStl+iPageH			;set pages horz. resolution				lda CarriageWidth,x				sta hPrint+PrStl+CRwidth 		;set carriage width resolution				rtsTableIndex		DS.B 2							  ;temporary;NOTE: The Initial and Normal horz. resolution is 80 dots per inch.;		The Initial and Normal vertical resolution is 36 dots per inch.;		The carriage is only 8 inches wide (therefore there are 1/4" margins.);;NOTE: All values are relative to the carriages 0,0 value.;------------------------------------------------------------------------------; Initial Portrait rPaper values;------------------------------------------------------------------------------IntPortVals ;;;US normal 8.5" x 11";				DC.W	0	;Top				DC.W	-20 ;Left (-1/4" offset from carriage zero)				DC.W	396 ;Bottom (11" times 36 dpi)				DC.W	660 ;Right (8" x 80 + 1/4" * 80)				DC.W	9	;GAP top and bottom (1/4" x 36);;US Legal 8.5" x 14";				DC.W	0	;Top				DC.W	-20 ;Left (-1/4" offset from carriage zero)				DC.W	504 ;Bottom (14" times 36 dpi)				DC.W	660 ;Right (8" x 80 + 1/4" * 80)				DC.W	9	;GAP top and bottom (1/4" x 36);;A4 Letter 8.25" (210mm)  x 11 2/3" (297mm)	NOTE: 25.4mm/inch;				DC.W	0	;Top				DC.W	-10 ;Left (-1/8" offset from carriage zero)				DC.W	420 ;Bottom (11.6667" times 36 dpi)				DC.W	650 ;Right (8.25 x 80)				DC.W	9	;GAP top and bottom (1/4" x 36);;International FanFold 8.25 (210mm) x 12";				DC.W	0	;Top				DC.W	-10 ;Left (-1/8" offset from carriage zero)				DC.W	432 ;Bottom (12" times 36)				DC.W	650 ;Right (8.25 x 80)				DC.W	9	;GAP top and bottom (1/4" x 36dpi);------------------------------------------------------------------------------; Initial Landscape rPage values;------------------------------------------------------------------------------;NOTE: Normal and Initial vertical (in actuality horz. carriage) is 40 dpi.;		Normal and Initial Horz. (in actuality vertical) is 72 dpi.;		GAP must be negative for landscape (simplified programming).IntLandVals ;;;US normal 8.5" x 11";				DC.W	-10 ;Top (1/4" x 40 offset from carriage 0)				DC.W	0	;Left				DC.W	330 ;Bottom (8" x 40 + 1/4 * 40)				DC.W	792 ;Right (11" x 72)				DC.W	-18 ;GAP (1/4" x 72) (neg. flags landscape);;US LEGAL 8.5" x 14";				DC.W	-10 ;Top (1/4" x 40 offset from carriage 0)				DC.W	0	;Left				DC.W	330 ;Bottom (8" x 40 + 1/4 * 40)				DC.W	1008	;Right (14" x 72)				DC.W	-18 ;GAP (1/4" x 72) (neg. flags landscape);;A4 Letter 8.25 x 11 2/3";				DC.W	-5	;Top (1/8" x 40 offset from carriage 0)				DC.W	0	;Left				DC.W	325 ;Bottom (8 * 40 + 1/8 *40)				DC.W	840 ;Right (11.* 72 + 2/3 * 72)				DC.W	-18 ;GAP (1/4" x 72) (neg. flags landscape);;International FanFold 8.25 (210mm) x 12";				DC.W	-5	;Top (1/8" x 40 offset from carriage 0)				DC.W	0	;Left				DC.W	325 ;Bottom (8 * 40 +1/8 * 40)				DC.W	864 ;Right (12 * 72)				DC.W	-18 ;GAP (1/4" x 72) (neg. flags landscape)				ENDP						;	 DocPage.Calls	  ;_PrOpenDoc, _PrCloseDoc, _PrOpenPage;										;_PrClosePage			******************************							** DocPage.calls 			**							** Current Rev: Nov. 1987	**							******************************;------------------------------------------------------------------------------;; NAME: 		PrDrvrVer;; PURPOSE:		Returns version # of currently installed driver;; PASSED:		WORD 					Space for result;; RETURNED:	 WORD 					Driver Version;;------------------------------------------------------------------------------PrDrvrVer		PROC	EXPORT				DefineStackDVerOrigD		Word 0DVerOrigB		Byte 0DVer_Rtl1		Block 3DVer_Rtl2		Block 3Version 		Word 0				phd				tcd				phb				phk				plb				lda #VersionNb				sta Version,s				lda #0				plb				pld				jmp exit0				ENDP;******************************************************************************;******************************************************************************;;  NAME:		PrOpenDoc;;  PURPOSE:	 High level printer routine "_PrOpenDoc" which opens the document;;  PASSED:		(Space for Result)		POINTER;				PrintRecordHandle		HANDLE, to print record;				PrinterPortPtr			POINTER, to GrafPort, (zero indicates;										to allocate new GrafPort).;;  RETURNED:	PrintrPortPtrRet 		POINTER, pointer to Grafport if;										PrinterPortPtr was zero.;;******************************************************************************;******************************************************************************				Export	PrOpenDoc	PrOpenDoc		PROC				DefineStackOrigD			word 0OrigB			byte 0rtl1			block 3rtl2			block 3UsersPortPtr	long 0UsersPrintRecH	long 0ResultPtr		long 0				pha						; save value of d;;First see if the port is ON;				pha				_DevIsItSafe 			;see if port is working				pla				bne Yes					;branch if safe;;We get here when the port is not on and we can't proceed;				lda #PortNotOn			;get error no.				sta >iPrErr				;save it				plx				jmp Exit8;;We arrive here when the port is ON;Yes ;				pla;------------------------------------------------------------;; save the registers and set direct page and  data bank;				phd				tcd				phb				phk				plb;------------------------------------------------------------;; Get the current cursor record's address and turn on the watch cursor.;				PushLong #0	; space for the address				_GetCursorAdr				pla				sta CursorAd				pla				sta CursorAd+2				_WaitCursor				stz DraftFlag;------------------------------------------------------------;; Don't Verify the print record!	*Hack*					ÑMSL 10/15/88;;				pha						; space for result;				lda UsersPrintRecH+4,s;				pha;				lda UsersPrintRecH+4,s;				pha;				_PrValidate;				pla						; dont care about the result;------------------------------------------------------------;; Clear the error code.  Move the user id.	Copy the users; print record to our print record.;				stz iPrErr				; zero error				stz PStatus				; and printer status								lda UserId				; move user id				sta MainUserID				lda UsersPrintRecH+2,s	; copy the print record				pha						; using HandToPtr				lda UsersPrintRecH+2,s				pha				PushLong #hprint				PushLong #Tprintsize				_HandToPtr;------------------------------------------------------------;; Lets look at the print method and set the variable; "METHOD".  Method will be zero for draft printing and; $8000 for spool printing. ;				lda hprint+prJob+bjDocLoop				and #$80				xba				sta method				;set the method;------------------------------------------------------------;; Put up the dialog that says preparing data (or draft; printing.;				stz NoShowMessage		; enable message display				jsr OpenInfoPrepare;------------------------------------------------------------;; Now we decide whether to use our own port or the user's; port. 				lda #false				; start by assuming it				sta ourport				; is the user's port.				lda UsersPortPtr,s		; if port ptr is non zero				ora UsersPortPtr+2,s 	; we use theirs				bne Portexist;------------------------------------------------------------;; Damn, the user wants us to do all his work for him/her.; We get a handle for a port.;				lda #PortSize			; size of handle				ldx #%1000000000011000	; attributes				jsr OurGetHandle 		;get a handle of port size				bcc @1				sta iPrErr				jsr CloseInfo				brl errorExitDoc@1				sta temp1				;save handle at tem1				stx temp1+2				lda [Temp1]				sta UsersPortPtr,s		;dereference handle at UsersPortPtr				ldy #2				lda [Temp1],y				sta UsersPortPtr+2,s 				lda #true				;set OURPORT true (remember)				sta ourportPortExist	;;------------------------------------------------------------;; Put copies of the port pointer everywhere.;				lda UsersPortPtr,s		;get port pointer				sta ResultPtr,s			;save to be passed back				sta hOurPort				sta PZ_pPrPort				lda UsersPortPtr+2,s				sta ResultPtr+2,s				sta hOurPort+2				sta PZ_pPrPort+2 ;------------------------------------------------------------;; Open the grafport.;				pei PZ_pPrPort+2				pei PZ_pPrPort				_OpenPort				;open the grafport;------------------------------------------------------------;; Initialize these page number varibles.;				stz iPageNum 			; init page num				stz iDocPage 			; init. document pages				stz PicListCount 		; page count of hPicList;------------------------------------------------------------;; Look at the printing method.	If it is deferred, get a handle; to enough memory to contain list of pictures for the number; of pages asked by the application to be printed.;				lda method				bpl draftOpenDoc 		;branch if immediate mode (draft);------------------------------------------------------------------------------;; DEFERRED Mode Code;;------------------------------------------------------------------------------;-------------------------------------------------------------;; We'll begin with a piclist for 20 pages. In PrOpenPage, we'll; check if this is enough, if not, we get more in 20 page increments;				lda #20*4				; start with 20 pages worth				ldx #%0000000000000000	; nothing special				jsr OurGetHandle 		;get a handle				bcc @1									sta iPrErr				; clean up the port we				jsr CloseInfo			; allocated.								pei PZ_pPrPort+2				pei PZ_pPrPort				_ClosePort				;close the graf port				lda #0					;zero out what we give back.				sta UsersPortPtr,s				sta UsersPortPtr+2,s				lda ourPort				;see if ours				cmp #true				bne @2 					;branch if not ours				pha						; first find the handle to				pha						; memory that port is in.				pei PZ_pPrPort+2				pei PZ_pPrPort				_FindHandle				; find the handle to pointer				_DisposeHandle			; then dispose it.@2				bra errorExitDoc@1				sta hPicList 			;save it at hPicList				stx hPicList+2;;We get here with no errors and its time to exit PrOpenDoc;				lda #0exitOpenDoc						sta iPrErr				; Added by Suki 5/25/88errorExitDoc	plb				pld				jmp Exit8;------------------------------------------------------------------------------;; IMMEDIATE Mode Code;;------------------------------------------------------------------------------draftOpenDoc	;				jsr startLLD 			; start up the LLD				bra ExitOpenDoc				ENDP				EJECT;******************************************************************************;******************************************************************************;;  NAME:		PrCloseDoc;;  PURPOSE:	 High level printer routine "_PrCloseDoc" which closes the doc.;;  PASSED:		PrinterGrafPortPtr		POINTER, to printer graf port.;;  RETURNED:	(NONE);;******************************************************************************;******************************************************************************PrCloseDoc		PROC	EXPORT				DEFINESTACKOrigD			word 0OrigB			byte 0rtl1			block 3rtl2			block 3PortPtr 		long 0				pha				lda >iPrErr				;see if any errors				beq Continue 			;branch if no erros				cmp #PortNotOn			;see if port-not-on error				bne Continue 			;branch if not				plx				jmp Exit4;;Save registers and setup environment;Continue	;				pla				phd				tcd				phb				phk				plb;------------------------------------------------------------;; Close the port.;				lda PortPtr+2,s				pha				lda PortPtr+2,s				pha				_ClosePort				;close the graf port;------------------------------------------------------------;; If the port is our's (created in PrOpenDoc), we must get rid of the memory we; allocated for it.;				lda ourPort				;see if ours				cmp #true				bne userport 			;branch if not ours				pha						; first find the handle to				pha						; memory that port is in.				lda PortPtr+4+2,s				pha				lda PortPtr+4+2,s				pha				_FindHandle				; find the handle to pointer				_DisposeHandle			; then dispose it.userport	;;------------------------------------------------------------;; If we are doing immediate (draf)t printing, we need to shut down.;				lda method				bpl CloseDocDraft		;branch if immediate mode;------------------------------------------------------------------------------;; DEFERRED Mode;;------------------------------------------------------------------------------;------------------------------------------------------------;; We're done.;NoErrorExit ;				lda #0				pha				jsr CloseInfo			; get rid of info dialog box				pla						;restore registers				plb				pld				jmp Exit4;------------------------------------------------------------------------------;; IMMEDIATE Mode;;------------------------------------------------------------------------------CloseDocDraft	;				pushword UserID				jsl LLDShutDown								PushLong CursorAd				_Setcursor								bra NoErrorExit				ENDP				EJECT;******************************************************************************;******************************************************************************;;  NAME:		PrOpenPage;;  PURPOSE:	 High level printer routine "_PrOpenPage" which opens the page;;  PASSED:		GrafPortPtr				POINTER, to grafport;				PageFramePtr 			POINTER, to scaling parameter (zero if;										none.);;  RETURNED:	(NONE);;******************************************************************************;******************************************************************************PrOpenPage		PROC	EXPORT				DefineStackOrigD			word 0OrigB			byte 0rtl1			block 3rtl2			block 3PageFramePtr	long 0PortPtr 		long 0				pha				lda >iPrErr				;see if any errors				beq SallRight			;branch if none				plx				jmp Exit8SallRight	;				pla						;save registers and setup environment				phd				tcd				phb				phk				plb;------------------------------------------------------------;; First we set the port to the port that is passed.;				lda PortPtr+2,s				pha				lda PortPtr+2,s				pha				_Initport;------------------------------------------------------------;; Zero the bounds rect.  This prevents any drawing: even; if user makes the pen visible.;				lda #0				ldy #o_BoundsRectZeroLoop		sta [PZ_pPrPort],y				iny				iny				cpy #o_BoundsRect+8				bcc ZeroLoop ;------------------------------------------------------------;; Now we bump the page counter and look at the method.	If it; is draft printing then do something, else we open a picture.;				inc iDocPage 			;increment the document page				lda method				;get the printing method				bmi spoolPage			;branch if deferred				brl OpenPageDraft		;branch if immediate;------------------------------------------------------------------------------;; DEFERRED Mode;;------------------------------------------------------------------------------spoolPage		stz hNewPic				; start by zeroing handle to				stz hNewPic+2			; picture.				lda iDocPage 			; look at page number.				cmp hprint+prjob+ifstpage ; are we in range?				blt exitnow				; no, get out now				dea				cmp hprint+prjob+ilstpage ; yes-start a picture				blt continue;;We get here when we are out of page range;exitnow 		brl NoErrorExitcontinue	;;-----------------------------------------------------------;; Lets look at the page frame pointer that was passed.	If it is NIL,; we replace it with a pointer to rPage.;				lda PageFramePtr,s		;get passed pointer				ora PageFramePtr+2,s				bne UserHasFramePtr		;branch if NIl				lda #hprint+prInfoPT+rpage				sta PageFramePtr,s				lda #^hprint+prInfoPT+rpage				sta PageFramePtr+2,sUserHasFramePtr ;				pha				pha				lda PageFramePtr+4+2,s	;get PageFramePointer from stack				pha				lda PageFramePtr+4+2,s				pha				_openpicture 			;open a picture;------------------------------------------------------------;; We leave result of open picture on stack until we deref; the pic list below.;;; Bump the picture list counter to reflect current page;				inc PicListCount ;------------------------------------------------------------;; PicListCount is used to test if hPicList is large to enough; to hold the number of pages in the document. It counts from; 1 to 20, since we increase memory 20 pages at a time. This; variable is initialised in PrOpenDoc.;				lda PicListCount				cmp #21					; run out of allocated memory?				blt EnoughMem			; not yet				pha						; space for size				pha				PushLong hPicList				_GetHandleSize			; get current block size				pla						; current size				clc				adc #20*4				; increase it by another 20 pages				pha						; new size				PushLong hPicList				_SetHandleSize			; set new block size										; MEMERR!EnoughMem		lda [hPicList]			; deref the pic list				sta pPicList				ldy #2				lda [hPicList],y				sta pPicList+2				lda iPagenum 			; use iPageNum as index into				asl a					; pic list				asl a				tay				pla						; now put picture handle into				sta [pPicList],y 		; pic list				sta hNewPic				; and in hNewPic				iny				iny				pla						; (high word too)				sta [pPicList],y				sta hNewPic+2;----------------------------------------------------------;; Set the cliprgn and visrgn to the sizing Framing rect;				lda PageFramePtr+2,s				pha				lda PageFramePtr+2,s				pha				_cliprect				pushlong #0				; and the vis rect!				_getcliphandle				_setvisrgn;-----------------------------------------------------------;; Lets set the port rect to this frameing rect too.;				lda PageFramePtr+2,s				pha				lda PageFramePtr+2,s				pha				_SetPortRect												;------------------------------------------------------------;; Bump the page number;				inc ipagenum;------------------------------------------------------------;; We are done.;NoErrorExit ;				lda #0				plb				pld				jmp Exit8;------------------------------------------------------------------------------;; IMMEDIATE Mode;;------------------------------------------------------------------------------OpenPageDraft	;;-----------------------------------------------------------;; If this is a page that will be printed, then we install; printing procs.;				lda iDocPage 			; look at page number.				cmp hprint+prjob+ifstpage ; are we in range?				blt NoErrorExit			; no, get out now				dea				cmp hprint+prjob+ilstpage ; yes-start a picture				bge NoErrorExit				lda #1					; so we know to zap the graphprocs				sta DraftFlag			; on a draft-mode cancel.				PushLong #ProcsTable 	; put std procs in table				_SetStdProcs				lda #<Drafttext-1		; Put our text proc in table				sta ProcsTable				lda #^Drafttext-1				sta ProcsTable+2				lda #<Pixel-1			; Put our pixel proc in table				sta ProcsTable+$20				lda #^Pixel-1				sta ProcsTable+$22				PushLong #ProcsTable 	; put pointer to our table in				_SetGrafProcs			; the graf port				bra NoErrorExit;------------------------------------------------------------;; Here's where we keep the proc table.;				EXPORT ProcsTable, DraftFlagProcsTable		DS.B 16*4DraftFlag		DS.W 1	ENDP				EJECT;******************************************************************************;******************************************************************************;;  NAME:		PrClosePage;;  PURPOSE:	 High level printer routine "_PrClosePage" which closes the page;;  PASSED:		PrinterGrafPortPtr		POINTER, to GrafPort to be used;;  RETURNED:	(NONE);;******************************************************************************;******************************************************************************PrClosePage	 	PROC	EXPORT				DefineStackOrigD			word 0OrigB			byte 0rtl1			block 3rtl2			block 3PortPtr 		long 0				pha				lda >iPrErr				;see if any errors				beq Continue 			;branch if none				cmp #PortNotOn			;see if port-not-on error				bne Continue 			;branch if none				plx				jmp Exit4Continue	;						;save registers and setup environment				pla				phd				tcd				phb				phk				plb;------------------------------------------------------------;; Look at method and go to correct routine.;				lda method				;look at method				bpl ClosePageDraft		;branch if immediate mode;------------------------------------------------------------------------------;; DEFERRED Mode;;------------------------------------------------------------------------------				lda hNewPic				; if there is no picture then				ora hNewPic+2			; we are done.				beq NoErrorExit			;branch if no picture				lda PortPtr+2,s				pha				lda PortPtr+2,s				pha				_SetPort 				;set the graf port;	Check for Picture error.  If one has happened, don't close the picture, because this;		can blast the clip rgn under System 5.0.				tool _GetPicSave,out=(ax:l)				cpx #$FFFF				bne @closeit								tool _SetPicSave,in=(#0:l)				bra @picErr@closeIt		_ClosePicture			;close the picture				bcc NoErrorExit				@picErr			lda #$0201				sta >iPrErr				bra errorExitNoErrorExit	 	lda #0errorExit		plb				pld				jmp Exit4;------------------------------------------------------------------------------;; IMMEDIATE Mode;;------------------------------------------------------------------------------ClosePageDraft	;;------------------------------------------------------------;; For draft printing we make LLD new page call. (unless; we've reached the end of the pages to print.;				lda iDocPage				cmp hprint+prjob+ifstpage				blt exitclosenow				dea				cmp hprint+prjob+ilstpage				bge exitclosenow				jsl newpageexitclosenow	bra NoErrorExit				ENDP				EJECT;------------------------------------------------------------------------------** NAME: 		OurGetHandle** PURPOSE:		Gets a handle to memory.** PASSED:		(A-reg.) 				size passed in a-reg.*				(X-reg.) 				attributes passed in x-register.** RETURNED:	 A Handle is returned in A & X registers unless there is a*				memory manager error (carry set) in which case the error;				number returns in the A-reg.*;------------------------------------------------------------------------------OurGetHandle	PROC	EXPORT				pha				pha				pea 0				pha						amount requested.				PushWord UserID			your ID				phx						attributes				pea 0				pea 0				_NewHandle				result on the stack				bcs AnError				pla				plx				rts;We get here if an error occured trying to get a handleAnError 		plx				plx				rts				ENDP											;------------------------------------------------------------;; CalcBandSize;;	This code was ripped out of CiXMetrics to be called seperately. ÑMSL	;CalcBandSize	PROC EXPORT			* now calculate iBandV ,iBandH ,iRowBytes and iDevBytes* iBandV= landscape(32,hprint+prInfo+rPage+Bottom'*2 if best or 50%')* iBandH= landscape(hprint+prInfo+rPage+Right'*2 if best or 50%',32)* iRowBytes= iBandH div (2:4),resolution* iDevBytes = iBandV * iRowBytes;;This calculates the print bands vertical resolution;* iBandV= landscape(32,hprint+prInfo+rPage+Bottom'*2 if best or 50%')				lda #f1				and hprint+prstl+wDev				bne Port5						;branch if portrait				lda hprint+prInfo+rPage+Bottom  ;get bottom				pha				lda #f3							;see if 50%				and hprint+prstl+wDev				bne testbest 					;branch if not 50%				pla				asl a				bra Land5testbest	;				lda #f0							;see if BEST				and hprint+prstl+wDev				beq notbest						;branch if not BEST				pla				asl a				bra Land5notbest ;				pla				bra Land5Port5			lda bandheightLand5	;				sta Hprint+PrXinfo+iBandV		;set the print bands vert. res.;;This calculates the print bands horizontal resolution;* iBandH= landscape(hprint+prInfo+rPage+Right'*2 if best or 50%',32)				lda #f1				and hprint+prstl+wDev				beq Land6						;branch if landscape				lda hprint+prInfo+rPage+Right	;get right				pha				lda #f3							;see if 50%				and hprint+prstl+wDev				bne testbest2					;branch if not best				pla;;;;;;;;;;;;;;;;;;;;;;;;;;;				asl a;;;;;;;;;;;;;;;;;;;;;;;;;;;				bra Port6testbest2	;				lda #f0							;see if BEST				and hprint+prstl+wDev				beq notbest2 					;branch if not BEST				pla				asl a				bra Port6notbest2	;				pla				bra Port6Land6			lda bandheightPort6	;				sta Hprint+PrXinfo+iBandH		;set the print bands Horz. res.;;This calculates the print bands bytes/row;* iRowBytes= iBandH div (2:4),resolution				lda Hprint+PrXinfo+iBandH				lsr a				ldx resolution				beq done				lsr adone			sta Hprint+PrXinfo+iRowBytes	 ;set the bytes/row;;This calculates the total number of bytes (bytes per row times number of bands);* iDevBytes = iBandV * iRowBytes				PushLong #0				lda Hprint+PrXinfo+iBandV				pha				lda Hprint+PrXinfo+iRowBytes				pha				_Multiply				pla				sta Hprint+PrXinfo+iDevBytes	 ;set the total no. of bytes				pla				beq DidCBandSize				 ; if'n its more than a bank,				lsr bandheight					 ; 1/2 it & keep trying...				brl CalcBandSize				DidCBandSize	rts				ENDP			;	 JobDialog			;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		JobDialog;;  PURPOSE:	 Does most of the work for "_PrJobDialog";;  PASSED:		(None);;  RETURNED:	(None);;------------------------------------------------------------------------------;------------------------------------------------------------------------------* buttonstate for JobDialog* +0	best* +2*1 faster* +2*2 Draft* +2*3 all pages* +2*4 from pages* +2*5 paper auto* +2*6 paper hand* +2*7 value for From* +2*8 Value for To* +2*9 value for Copies* +2*10 color/bw* +2*11 darkerJobDialog		PROC	EXPORT;;Get the pointer to the current grafport;				PushLong #0				_getport;;Get the master SCB;				pha				_GetMasterSCB			;get the SCB				pla				sta DeadLoc				;save it;;Calculate the dialog boxes width;				lda StyleRect+6				sec				sbc StyleRect+2				sta Stylewidth;;This calculates the dialog boxes LEFT and RIGHT (depending on 320 or 640 mode)				lda deadloc				;get saved SCB				and #$80 				;look at mode ($0=320, $80=640)				beq loc320				lda #640 				;get 640				bne loc640loc320	;				lda #320 				;get 320loc640	;				sec				sbc StyleWidth				lsr a				sta StyleRect+2			;adjust job dialogs LEFT				sta JobDTemplate+2		;DAN H. adjust template				clc				adc StyleWidth				sta StyleRect+6			;adjust job dialogs RIGHT				sta JobDTemplate+6		;DAN H. adjust template;;This inits. the button item states;				ldy #2*6 				;init. buttonstate index				ldx #6*24				;init. JDRB template indexIBitemState ;				stz JDRB0,x				;init. state to off				lda buttonstate,y		;get button state				bpl IsOff1				lda #1				sta JDRB0,x				;set state to onIsOff1	;				txa						;get y-index				sec				sbc #24					;move to next item template				tax				dey				dey				bpl IBitemState;Do COLOR check box differently				stz JDRB10				;init. to off				lda buttonstate+2*10 	;get buttonstate for color				bpl over10				;branch if off				lda #$ffff				;set to selected				sta JDRB10over10	;				stz JDRB11				;init. to off				lda buttonstate+2*11 	;get buttonstate for color				bpl over11				;branch if off				lda #$ffff				;set to selected				sta JDRB11over11	;;;This starts the modal dialog;				PushLong #0				Pushptr JobDTemplate 		;The dialogs template				_GetNewModalDialog			;creates a new modal dialog				pla				sta pScreenport			;save the dialogs handle				pla				sta pScreenport+2;;Set the dialog as the current port and set the origin to zero;				pushlong pscreenport				_Setport				pushlong #0				_setOrigin;; draw the upper line;				pushlong l1				_moveto				pushlong l2				_lineto;* let's draw the inactive strings (printers name/ports name);				PushLong namepos 		;move to where to put printer name				_moveto				PushLong #0				_PmGetPrinterName		;get the printer types name				_DrawString				;draw it				PushPtr SlashStr				_DrawString				;draw a "/"				PushLong #0				_PmGetPortName			;get the ports name				_DrawString				;draw it;------------------------------------------------------------------------------;This draws the inactive strings using tables;------------------------------------------------------------------------------				lda JIstrnum 			;get number of strings to draw				dea				asl a				asl a				tax						;use as an indexstrloop 		phx						;save index				lda JIposlist+2,x		;get position to draw at				pha				lda JIposlist,x				pha				_moveto					;move to the position				plx				phx				lda	JIstrlist+2,x		;get address of text to draw				pha				lda	JIstrlist,x				pha				_drawstring				;draw the text				plx				dex				dex				dex				dex				bpl strloop				;loop for all strings in table;------------------------------------------------------------------------------;; This is the modal dialog loop;;------------------------------------------------------------------------------loopModal	;				PushWord #0				PushLong #JobFilter+$80000000	;use filter proc. and standard				_modalDialog				pla				beq loopModal			;loop until a response from user				cmp #15					;see if valid item selected				bge loopModal			;branch if invalid;;Convert item selected and vector to appropriate routine to handle it;				asl a					;convert itme to index				tax				jmp (Action-2,x) 		;vector to routine to handle itemAction	;				DC.W	S_OkEvent	;1				DC.W	S_Cancelevent	;2 (Cancel button)				DC.W	S_Qual	;3				DC.W	S_Qual	;4				DC.W	S_Qual	;5				DC.W	S_Page	;6 (ALL radio button)				DC.W	S_Page	;7 (FROM radio button)				DC.W	S_Copie ;8				DC.W	S_Copie ;9				DC.W	S_Copies	;10				DC.W	S_To	;11 (TO line edit box)				DC.W	S_From	;12 (FROM line edit box)				DC.W	S_Color ;13 (Color check box)				DC.W	S_Darker	;14 (Darker check box);;We vector here on OK button;S_okEvent	;				pushword #0				Pushlong pScreenPort				Pushword #13				_GetDItemValue				pla				sta buttonstate+2*10								pushword #0				Pushlong pScreenPort				Pushword #14				_GetDItemValue				pla				sta buttonstate+2*11				PushLong pscreenport				PushWord #10				PushPtr CopieFinalValue				_GetIText				pushword #0				pushptr CopieFinalValue+1				lda CopieFinalValue				and #$07				pha				pushword #0				_Dec2int				pla				sta Buttonstate+2*9				lda buttonstate+2*3		; check if all is on, if so, do not				bmi nopageupdate 		; update 'from' & 'to' in buttonstate				PushLong pscreenport				PushWord #12				PushPtr FromFinalValue				_GetIText				lda FromFinalValue				and #7				beq nofrom				pushword #0				pushptr FromFinalValue+1				lda FromFinalValue				and #$07				pha				pushword #0				_Dec2int				pla				sta Buttonstate+2*7nofrom	;				PushLong pscreenport				PushWord #11				PushPtr ToFinalValue				_GetIText				lda ToFinalValue				and #$07				beq nopageupdate				pushword #0				pushptr ToFinalValue+1				lda ToFinalValue				and #$07				pha				pushword #0				_Dec2int				pla				sta Buttonstate+2*8nopageupdate	;				lda #$ffff				sta IfCancelled				brl fin;;We vector here on CANCEL button;S_CancelEvent	;				lda #0				sta IfCancelled			;set if cancelled				brl fin;;We vector here on a print quality radio button selection;S_Qual	;				sec				sbc #6				tax				lda buttonState,x		Give me the item				bmi PaperDone				phx* clear the current one				ldx #0searchmore		lda buttonState,x				bmi clearit				inx				inx				cpx #3*2				bne searchmore				bra PaperDoneclearit 		lda #0				sta buttonState,x				txa				lsr a				clc				adc #3				tax				pushword #0				Pushlong pScreenPort				phx				_SetDItemValue* Mark the new one				plx				phx				lda #$FFFF				sta buttonstate,x				pla				lsr a				clc				adc #3				tax				pushword #1				Pushlong pScreenPort				phx				_SetDItemValuePaperDone		brl LoopModal;;We vector here on page button;S_Page	;				tay				sec				sbc #6				tax				lda buttonState,x		Give me the item				bmi PaperDone				cpx #2*3 				* button n 4				beq doallS_Page2 ;				cpy #16					;value has been doubled by now				bge ToBox				;"To or From" clicked, dont select text				Pushlong pScreenPort				PushWord #12 			;id of From edit item box				PushWord #0				;start				PushWord #4				;stop				_SelectIText 			;select the FROM edit item box* do from to.ToBox			pushword #1				Pushlong pScreenPort				Pushword #7				_SetDItemValue			;ON with FROM radio button				pushword #0				Pushlong pScreenPort				Pushword #6				_SetDItemValue			;OFF with ALL radio button				lda #0				ldx #2*3				sta buttonstate,x				inx				inx				dea				sta buttonstate,x				brl LoopModaldoAll	;				pushword #0				Pushlong pScreenPort				Pushword #7				_SetDItemValue				pushword #1				Pushlong pScreenPort				Pushword #6				_SetDItemValue				lda #$ffff				ldx #2*3				sta buttonstate,x				inx				inx				ina				sta buttonstate,xCopieDone		brl LoopModal;;We vector here on a paper feed radio button (AUTOMATIC, HAND FEED)S_Copie ;				sec				sbc #6				tax				lda buttonState,x		Give me the item				bmi CopieDone				cpx #2*5 				* button n 6				beq doAuto;We get here when its a HAND FEED				pushword #1				Pushlong pScreenPort				Pushword #9				_SetDItemValue				pushword #0				Pushlong pScreenPort				Pushword #8				_SetDItemValue				lda #0				ldx #2*5				sta buttonstate,x				inx				inx				dea				sta buttonstate,x				brl LoopModal;We arrive here when its an AUTOMATICdoAuto	;				pushword #1				Pushlong pScreenPort				Pushword #8				_SetDItemValue				pushword #0				Pushlong pScreenPort				Pushword #9				_SetDItemValue				lda #$ffff				ldx #2*5				sta buttonstate,x				inx				inx				ina				sta buttonstate,x				brl LoopModal;;We vector here on COLOR check box selection;S_Color ;				pushword #0				Pushlong pScreenPort				Pushword #13				_GetDItemValue				pla				eor #$ffff				pha				Pushlong pScreenPort				Pushword #13				_SetDItemValue				Brl LoopModal				S_Darker ;				pushword #0				Pushlong pScreenPort				Pushword #14				_GetDItemValue				pla				eor #$ffff				pha				Pushlong pScreenPort				Pushword #14				_SetDItemValue				Brl LoopModal;;We vector here on a COPIES edit item;S_Copies	;				brl LoopModal;;We vector here on a FROM or TWO edit item selection;S_To	;S_From	;				tay				lda #14				brl S_Page2;;We go here when the user is done and has selected either OK or CANCEL;				IMPORT DraftModeQualityfin 							PushWord #0				PushWord #0				PushPtr EventRecord				_getNextEvent				pla				lda evtmods				and #$0900				sta DraftModeQuality				pushlong pscreenport				_CloseDialog				_setport				lda IfCancelled				rts	ENDP						;	 JobFilter			;------------------------------------------------------------------------------;;  NAME:		JobFilter;;  PURPOSE:	 _PrJobDialog's filter procedure.;;  PASSED:		Result					WORD, (space for result);				TheDialog				LONG, pointer to the dialog's grafport;				Event					LONG, pointer to the event;				ItemHit					LONG, pointer to the item hit;;  RETURNED:	IgnoreFlag				WORD, boolean, TRUE if event is to be;											  ignored, FALSE if calling routine;											  should handle event.;;------------------------------------------------------------------------------	Export	Jobfilter	Jobfilter		PROCinButtDwn		equ 1KeyDown 		equ 3AutoKey 		equ 5ItemHit 		equ 7Event			equ ItemHit+4TheDialog		equ Event+4Result			equ TheDialog+4TabKey			equ 9ReturnKey		equ 13deleteKey		equ 127				phd				phb				phk				plb				tsc				tcd				lda #0				sta result				;init. result to true;;Copy the event record;				ldy #14copyEvent		lda [Event],y				sta EventRecord,y				dey				dey				bpl CopyEvent				lda ZeroPage				tcd						;get zero page				lda EvtWhat				;see what type of event				cmp #KeyDown 			;do KeyDown events				beq dokey				cmp #AutoKey 			;do AutoKey events				beq dokey				brl notDown				;all other events pass thru.;;We get here when we have either a KeyDown or AutoKey events;Dokey	;				lda evtmsg				cmp #TabKey				;do tab key				beq KeyAllowed				cmp #returnKey			;do return key				beq KeyAllowed				cmp #DeleteKey			;do delete key				beq KeyAllowed				cmp #$30				blt notallowed				cmp #$3a				bge notallowed				bra KeyAllowed;;We get here when we get an event that we don't want;notallowed	;				lda #-1				sta result,s 			;set results for falseKeyAllowed	;notDown ;				plb				pld				lda 0,s				sta 12,s				lda 2,s				sta 14,s				pla				pla				pla				pla				pla				pla				rtl	ENDP						;	 StyleDialog			;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		StyleDialog;;  PURPOSE:	 Does most of the work for "_PrStlDialog";;  PASSED:		(None);;  RETURNED:	(A-reg.)=0 OK, =$ffff CANCEL;;------------------------------------------------------------------------------;------------------------------------------------------------------------------* buttonstate for Style* +0	US Letter* +2*1	US Legal* +2*2	A4 Letter* +2*3	International Fanfold* +2*4	Reserved for Computer Paper* +2*5	Reserved for Tall Adjusted* +2*6	Reserved for 50% reduction* +2*7	No Gaps Between Pages* +2*8	Portrait* +2*9	Landscape	Export	StyleDialog StyleDialog	 PROC;;Get the pointer to the current grafport;				pushlong #0				_getport 				;get the current port;;Get the master SCB;				pha				_GetMasterSCB			;get the SCB				pla				sta DeadLoc				;save SCB;;Calculate the dialogs boxs width;				lda StyleRect+6				sec				sbc StyleRect+2				sta Stylewidth			;save width of dialog box;;This calculates the dialog boxes LEFT and RIGHT (depending on 320 or 640 mode);				lda deadloc				;get saved SCB				and #$80 				;look at mode (0=320, 1=640)				sta landsc_p				sta portrait_p				beq loc320				;branch if 320 mode				lda #640 				;get 640				bne loc640loc320	;				lda #320 				;get 320loc640	;				sec				sbc StyleWidth				lsr a				sta StyleRect+2			;adjust style dialogs LEFT				clc				adc StyleWidth				sta StyleRect+6			;adjust style dialogs RIGHT;;This sets the appropriate pixel width for the portrait/landscape image;* update the bitmap for 320/640				lda deadloc				;get save SCB				and #$80 				;look at mode bit				beq w320 				;branch if 320				lda pixel640 			;get the pixel width for 640				bne www320			lda pixel320 			;get the pixel width for 320ww				sta pixelwidth			;set the pixel width				sta portrait_p+14		;set the portriat				sta landsc_p+14			;set the landscape				sta portrait_r+6 		;set the portriat rectangle				sta landsc_r+6			;set the landscape rectangle				clc				adc dstbitr1+2				sta dstbitr1+6;;Adjust the left and right of the destination rectangle?;				lda pixelwidth				clc				adc #4				adc dstbitf1+2				sta dstbitf1+6;;????????????;				lda pixelwidth				clc				adc dstbitr2+2				sta dstbitr2+6				lda pixelwidth				clc				adc #4				adc dstbitf2+2				sta dstbitf2+6;;This starts the modal dialog;				PushLong #0				Pushptr StyleRect		;stylerect defines the dialog box				Pushword #1				PushLong #0				_NewModalDialog			;get a new modal dialog				pla				sta pScreenport			;save the dialog boxes handle				pla				sta pScreenport+2;;Set the dialog as the current port and set the origin to 0;				pushlong pScreenport				_Setport 				;set the current port to the dialog				pushlong #0				_setOrigin				;set the origin to zero;* draw the upper line;				pushlong l1				_moveto				pushlong l2				_lineto;*let's draw the inactive strings (printers name/ports name);				PushLong namepos 		;move to where to put printer name				_moveto				PushLong #0				_PmGetPrinterName		;get the printer types name				_DrawString				;draw it				PushPtr SlashStr				_DrawString				;draw a "/" char.				PushLong #0				_PmGetPortName			;get the ports name				_DrawString				;draw it;------------------------------------------------------------------------------;This draws the inactive strings using tables;------------------------------------------------------------------------------				lda Istrnum				;get number of strings to draw				dea				asl a				asl a				tax						;use as an indexstrloop 		phx						;save index				lda Iposlist+2,x 		;get position to draw at				pha				lda Iposlist,x				pha				_moveto					;move to position				plx				phx				lda	Istrlist+2,x		;get address of text to draw				pha				lda	Istrlist,x				pha				_drawstring				;draw the text				plx				dex						;adjust index to next string				dex				dex				dex				bpl strloop				;loop for all strings in table;* create the OK Item;				PushLong pScreenPort				Pushword #1				;OK button (default for CR)				Pushptr OKrect				Pushword #ButtonItem				Pushptr okstr				PushWord #0				PushWord #0				PushLong #0				_newDItem;;Create the CANCEL button;				PushLong pScreenPort				Pushword #2				cancel				Pushptr cancelrect				Pushword #ButtonItem				Pushptr cancelstr				PushWord #0				PushWord #0				PushLong #0				_newDItem;;* create the radio items;				lda #0Radioloop		pha				asl a				asl a				tax						;X-reg. points to correct item in list				PushLong pScreenport 	;dialogs port				lda 5,s					;get the current item count off stack				clc				adc #3					;start at 3 (1 is ok, 2 is cancel)				pha						;push the Id				lda ArectList+2,x		;push the items bounds rectangle				pha				lda ArectList,x				pha				cpx #7*4 				;special case out type of item				blt rad				pushword #CheckItem		;we get here for a check item				bra comrad ;				pushword #radioItem		;we get here for a radio itemcom ;				lda AstrList+2,x 		;push the items descriptor				pha				lda AstrList,x				pha				PushWord #0				;Items value				cpx #5*4 				; If done with paper radio button				blt Family0				; then change family # to 1 for				PushWord #1				; VSize radio buttons				bra NextFamily0 		PushWord #0				;Items flagNext			PushLong #0				;Items color				_newDItem				;Create the new item				pla						;get the saved counter				cmp #3				bne nojump				;do first four items				inc a					;skip 50% reductionnojump	;				inc a					;goto NO GAPS				cmp AStrNum				bne Radioloop;;* draw the bitmaps for portrait/landscape;				pushlong #0				_getport				pla				sta PP_portrait+4				sta PP_Landsc+4				pla				sta PP_portrait+6				sta PP_Landsc+6				Pushptr PP_portrait				_paintPixels 			;paint portrait				Pushptr PP_Landsc				_paintPixels 			;paint landscape				pushptr dstbitf1				_framerect				;frame portrait				pushptr dstbitf2				_framerect				;frame landscape;;Now determine invert the current selected mode for portriat/landscape;				lda buttonstate+2*8		;get portraits button state				bpl startLands			;branch if not selected;;we get here if portriat;				Pushptr dstbitf1				_invertRect				;invert the portrait image				pushptr dstbitf1				_framerect				;frame the portrait image				bra startport;;We get here if landscape;startLands	;				Pushptr dstbitf2				_invertRect				;invert the landscape image				pushptr dstbitf2				_framerect				;frame the landscape image;;This gets the pointers to the control items;startPort	;				lda #1GetptrLoop		pha				tay				pushlong #0				pushlong pScreenPort				Phy				_GetControlDItem				lda 5,s				asl a				asl a				tax				pla				sta ptrList,x			;save the pointer in list				pla				sta ptrList+2,x				pla				ina				cmp #11+1				bne GetptrLoop;;This activates the radio buttons;				lda #3looop			pha				asl a				tax				lda buttonstate-6,x				bpl forgetthisone				pla				pha				asl a				asl a				tax				ldy #1				jsr SetButtonValueforgetthisone  pla				ina				cmp #8				bne looop				; items 8 - 11 are not as normal				lda buttonstate+2*10 	; Normal Vsize				bpl Onto9				; Not selected				ldx #8*4 				; item #8 is the oddest				ldy #1					; ON				jsr SetButtonValueOnto9			lda #9					; Items 9 - 11loop1			pha						; offset to buttonstate are				asl a					; different than that of 3 - 7				tax				lda buttonstate-8,x				bpl SkipIt				pla				pha				asl a				asl a				tax				ldy #1				jsr SetbuttonValueSkipIt			pla				ina				cmp #12				bne loop1;------------------------------------------------------------------------------;;This is the modal dialog loop;;------------------------------------------------------------------------------loopModal	;					PushWord #0				PushLong #StyleFilter+$80000000 ;handles portrait/lands. images				_modalDialog				pla				beq loopModal			;loop until a response				cmp #12					;see if valid item				bge loopModal			;branch if not;;Now vector to correct routine to handle the item;				asl a					;convert item number to index				tax				jmp (Action-2,x) 		;vector to routine to handle itemAction	;				DC.W	S_OkEvent			1				DC.W	S_Cancelevent		2				DC.W	S_Paper 			3 - US Letter				DC.W	S_Paper 			4 - US Legal				DC.W	S_Paper 			5 - A4 Letter				DC.W	S_Paper 			6 - International fanfold				DC.W	S_Paper 			7 - Reserved for computer paper				DC.W	S_Vsize 			8 - Normal VSize				DC.W	S_Vsize 			9 - Condensed VSize				DC.W	S_Spe				10 - 50%				DC.W	S_Spe				11 - No Gap;;We vector here on OK button;S_okEvent	;				lda #$ffff				sta IfCancelled			;clear if cancled flag				brl fin;;We vector here on CANCEL button;S_CancelEvent	;				lda #0				sta IfCancelled			;set if cancled flag				brl fin;;We vector here on a paper radio button selection;S_paper ;				sec				sbc #6				tax				lda buttonState,x		Give me the item				bmi PaperDone				phx* clear the current one				ldx #0searchmore		lda buttonState,x				bmi clearit				inx				inx				cpx #5*2				bne searchmore				bra PaperDoneclearit 		lda #0				sta buttonState,x				txa				lsr a				clc				adc #3				asl a				asl a				tax				ldy #0				jsr SetButtonValue* Mark the new one				plx				phx				lda #$FFFF				sta buttonstate,x				pla				lsr a				clc				adc #3				asl a				asl a				tax				ldy #1				jsr SetButtonValuePaperDone		brl LoopModal;; We vector here on a special size selection;S_VSize 		cmp #16					; is it 2 x 8?				beq SetNormal			; yes, user picked normal				lda #0					; user picked condensed - 9				sta buttonstate+2*10 	; normal off				dec a				sta buttonstate+2*5		; condensed on				ldx #9*4 				; offset for condensed				ldy #1					; ctrl value in y, we want ON now				jsr SetButtonValue				ldx #8*4 				; offset for normal				ldy #0					; now we want OFF				jsr SetButtonValue				brl LoopModalSetNormal	;				lda #0					; user picked normal - 8				sta buttonstate+2*5		; condensed on				dec a				sta buttonstate+2*10 	; normal off				ldx #9*4 				; offset for condensed				ldy #0					; ctrl value in y, we want OFF now				jsr SetButtonValue				ldx #8*4 				; offset for normal				ldy #1					; now we want ON				jsr SetButtonValue				brl LoopModalS_Spe	;				pha				sec				sbc #8				tax				lda buttonState,x		Give me the item				eor #$ffff				sta buttonstate,x				pla				asl a				tax				phx				pushword #0				lda PtrList+2,x				pha				lda PtrList,x				pha				_GetCtlValue				pla				plx				and #1				eor #1				tay				jsr SetbuttonValue				brl LoopModal;;We go here when the user has selected OK or CANCEL;fin 			pushlong pscreenport				_CloseDialog 			;close the dialog box				_setport 				;set back to the previous port				lda IfCancelled			;get the OK/CANCEL flag				rts												EJECT;------------------------------------------------------------------------------;; NAME: 		SetButtonValue;; PURPOSE:		Sets the control value to the value passed in Y-reg.;; PASSED:		(Y-reg.) 				0 = clear, 1= set;				(X-reg.) 				offset to the table of handles;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	SetButtonValueSetButtonValue 				phy				lda PtrList+2,x			; get handle to control				pha				lda PtrList,x				pha				_SetCtlValue 			; set it				rts				ENDP						;	 StyleFilter			;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		StyleFilter;;  PURPOSE:	 Filter procedure for "StyleDialog" to detect when a button down;				event has occured on one of the portrait/landscape picture;				bitmaps.;;  PASSED:		Result					WORD, (space for result);				TheDialog				LONG, pointer to the dialog's grafport;				Event					LONG, pointer to the event;				ItemHit					LONG, pointer to the item hit;;  RETURNED:	IgnoreFlag				WORD, boolean, TRUE if event is to be;											  ignored, FALSE if calling routine;											  should handle event.;;------------------------------------------------------------------------------;------------------------------------------------------------------------------Stylefilter	 	PROC	EXPORTinButtDwn		equ 1ItemHit 		equ 7Event			equ ItemHit+4TheDialog		equ Event+4Result			equ TheDialog+4;Save registers and setup environment				phd				phb				phk				plb				tsc				tcd				lda #0				sta result				;init result to true;Copy Event record				ldy #14copyEvent		lda [Event],y				sta EventRecord,y				dey				dey				bpl CopyEvent				lda ZeroPage				tcd;Now see what kind of event it was				lda EvtWhat				;get kind of event				cmp #inButtDwn			;see if it was a button down				beq down				brl notDown				;exit if not;;We get here when we have a button down event;Down	;;Now see if it was in one of the bitmap images				PushLong pScreenPort				_setPort				PushWord #0				PushWord #0				_setOrigin				pushptr EvtWhere				_globaltolocal				pha				pushptr EvtWhere				Pushptr dstbitf1				_ptInrect				;see if it is in the portrait bitmap				pla				beq NotIn1				;branch if not;;We get here if it was a button down event in the portrait bitmap image;				ldx #2*8				lda buttonstate,x		;get the current state				bpl invertthem			;branch if changed				brl notdown				;branch if no change;;We now test for in the landscape bitmap image;NotIn1	;				pha						;for result				pushptr EvtWhere				Pushptr dstbitf2				_ptInrect				pla						;get result				beq NotDown				;branch if not in landscape bitmap;;We get here if it was a button down event in the landscape bitmap image;				ldx #2*9				lda buttonstate,x		;look at the current state				bpl invertthem			;branch if changed				brl notdown				;branch if no change;;We get here when we need to change the portrait/landscape images;invertThem	;				ldx #2*8				lda buttonstate,x		;get the current portrait state				eor #$ffff				sta buttonstate,x		;invert it				inx				inx				lda buttonstate,x		;get the current landscape state				eor #$ffff				sta buttonstate,x		;invert it				Pushptr dstbitf1				_invertRect				;invert portrait image				pushptr dstbitf1				_framerect				;frame portrait image				Pushptr dstbitf2				_invertRect				;invert landscape image				pushptr dstbitf2				_framerect				;frame landscape image;;We get here when we are done or it wasn't a button down event;notDown ;				plb				pld				lda 0,s				sta 12,s				lda 2,s				sta 14,s				pla				pla				pla				pla				pla				pla				rtl				ENDP							EJECT;	 InfoDialogs			;------------------------------------------------------------------------------;------------------------------------------------------------------------------;; INFORMATION DIALOG ROUTINES;;------------------------------------------------------------------------------;------------------------------------------------------------------------------InfoDialogs	 	PROC	EXPORT;StatText		equ 15;ButtonItem		equ 10;------------------------------------------------------------------------------;;  NAME:		OpenInfoPrepare;;  PURPOSE:	 Brings up window which indicates what is about to happen.;				 IMMEDIATE MODE: "Printing in Draft mode ...";				 DEFERRED MODE:  "Preparing Data ...";;  PASSED:		NONE;;  RETURNED:	NONE;;------------------------------------------------------------------------------				EXPORT	OpenInfoPrepare OpenInfoPrepare 				PushLong #0				_getport 				;get current port and save it				pha				_GetMasterSCB			; check mode from SCB				pla				and #$80 				;see which mode				beq loc320				;branch if 320 mode;;We get here if its 640 mode;				lda infowidth640				sta StyleWidth			;set the style width for 640				lda #640 				;get 640				bne loc640				;branch;;We get here if its 320 mode;loc320	;				lda infowidth320				sta StyleWidth			;set the style width for 320				lda #320 				;get 320;;Remember: (A-reg. is 320 or 640 depending on mode);loc640	;				sec				sbc StyleWidth				lsr a				sta InfoRect+2			;set left				clc				adc StyleWidth				sta InfoRect+6			;set right				PushLong #0				PushPtr InfoWindow				_NewWindow				;bring up a new window				pla				sta infoDPort			;save it				pla				sta infoDPort+2				pushlong infoDPort				_setPort 				;set it as current port				Pushlong InfoStrPos		;move to strings starting position				_moveto				lda method				;get method (immediate, deferred)				bpl draftStr 			;branch if immediate;------------------------------------------------------------------------------; Deferred Mode;------------------------------------------------------------------------------				pushptr InfoStrPrep		;get string "Preparing Data ..."				bra DrawIt;------------------------------------------------------------------------------; Immediate Mode;------------------------------------------------------------------------------draftStr	;				pushptr InfoStrDraft 	;get string "Printing in Draft mode ..."DrawIt			_drawString				;draw the string in the window				_setPort 				;restore the old port				rts								Eject;------------------------------------------------------------------------------;;  NAME:		CloseInfo;;  PURPOSE:	 Closes the info window.;;  PASSED:		NONE;;  RETURNED:	NONE;;------------------------------------------------------------------------------				EXPORT	CloseInfo	CloseInfo				PushLong infoDPort				_closeWindow				rts				ENDP												Eject;------------------------------------------------------------------------------;;  NAME:		OpenInfoPrinting;;  PURPOSE:	 Prepares and draws the opening info window;;  PASSED:		NONE;;  RETURNED:	NONE;;------------------------------------------------------------------------------OpenInfoPrinting PROC	Export;StatText		equ 15;ButtonItem		equ 10ByteOffset		equ	5		; since bitOffset is 40ColorRibbon 	equ $0080SheetFeeder		equ $0040PaperOut		equ $0020CoverOpen 		equ $0010OffLine			equ $0008ShtFdrEmpty		equ $0044PaperJam		equ $0004PrinterFault	equ $0002HeadMoving		equ $0001PrinterBusy		equ $8000				pha				_GetMasterSCB			; check mode				pla				and #$80				beq loc320				;branch if 320 mode;We arrive here if its 640 mode				lda infowidth640				sta StyleWidth			;set the width				lda #640				bra loc640;We arrive here if its 320 modeloc320	;				lda infowidth320				sta StyleWidth			;set the width				lda #320loc640	;				sec				sbc StyleWidth				lsr a				sta InfoRect+2			;set left				clc				adc StyleWidth				sta InfoRect+6			;set right				PushLong #0				PushPtr InfoWindow				_NewWindow				;bring up the window				pla				sta infoDPort				pla				sta infoDPort+2				lda #PrintProcess		; go draw the string				ldx #^PrintProcess				jsr ShowString								jsr GetStatus								rts				EJECT;------------------------------------------------------------------------------;;  NAME:		GetStatus;;  PURPOSE:	 Checks for new status and displays the approapriate status message.;;  PASSED:		NONE;;  RETURNED:	NONE;;  status buffer structure:;	bytes 0-3 : system stuff;	byte 4    : length byte of string;	byte 5    : status bits;				0: color				$0080;				1: sheetfeeder			$0040;				2: out of paper			$0020   ;				3: cover open			$0010;				4: printer off line		$0008;				5: paper jam			$0004;				6: printer fault		$0002;				7: print head is moving	$0001;	byte 6      : more status bits;				0: printer is busy		$8000;; Special note:		ShtFdrEmpty	equ $0044; If a sheetfeeder is installed, it send back "paper jam" when it is out of paper; not the usual "out of paper" error. ;;------------------------------------------------------------------------------				EXPORT	GetStatus	GetStatus								lda NoShowMessage		; do we need to do a status?				beq @1				brl ExitShowStatus		; non zero says no				@1				Jsr StatusPrinter		;see if its time to status device				bcc doit				rtsdoit				ldx #byteOffset			; pick up the status bytes				lda InfoStrBuffer,x				tay						; save for further use				and #PaperOut			; mask out other bits				beq PaperNotOutPaperOutMsg		dec PStatus				lda #PaperOutStr		; set up for the appropriate				ldx #^PaperOutStr		; string				bra ShowString			; go and display itPaperNotOut				tya				and #CoverOpen				beq CoverNotOpen				dec PStatus				lda #CoverOpenStr				ldx #^CoverOpenStr				bra ShowStringCoverNotOpen				tya				and #PaperJam				beq PaperNotJam				tya				and #ShtFdrEmpty				cmp #PaperJam				bne PaperOutMsg				dec PStatus				lda #PaperJamStr				ldx #^PaperJamStr				bra ShowStringPaperNotJam				tya				and #OffLine				beq NoProblem				dec PStatus				lda #OffLineStr				ldx #^OffLineStr				bra ShowString				NoProblem		stz PStatus				lda #PrintProcess				ldx #^PrintProcess				EXPORT	ShowString	ShowString				sta StringAddr			; store address in local variable				stx StringAddr+2				PushLong #0				_getport 				;get current port				PushLong infoDPort				_setPort 				;set to info. dialog port				PushPtr EraseInfoRect				_eraseRect				;erase whats already there				Pushlong InfoStrPos				_moveto					;move to where to draw text				PushLong StringAddr				_drawString				;draw the text from InfoStrBuffer				Pushlong CancelStrPos	;Message telling user how to cancel.				_moveto					;				PushLong #CancelStrPrint ; ÑMSL 1/13/89				_drawString				_setPort 				;restore the port				ExitShowStatus	rtsStringAddr		DS.B 4;------------------------------------------------------------------------------;;  NAME:		StatusPrinter;;  PURPOSE:	 Gets the status from the device;;  PASSED:		NONE;;  RETURNED:	(Carry Flag) CLEAR= device was statused, SET=device not statused?;;------------------------------------------------------------------------------				EXPORT	StatusPrinter StatusPrinter	;				PushLong #0;				_TickCount				;get the system tick count;				plx;				pla;				cmp newdate+2;				beq testlower;				blt ExitStatus;testLower		txa;				cmp NewDate;				blt ExitStatus;				PushLong #0;				_TickCount;				pla;				clc;				adc #60*5;				sta NewDate;				pla;				adc #0;				sta NewDate+2				;;We get here when its time to restatus the device;				ldx #4				lda #0					; zero out the length and byte 5				sta InfoStrBuffer,x				LoopStatus		PushPtr InfoStrBuffer				_PrDevStatus 			;get the status of the device								ldx #5				lda InfoStrBuffer,x		; the printer tends to randomly				and #$00FF				; return $FF				cmp #$00FF				beq LoopStatus								clc						;clear carry				RtsExitStatus					sec						;set carry				RtsNewDate 		DS.B 4				ENDP			;	 PrPicFile			******************************							** PrPicFile 				**							** Current Rev: Nov. 1987	**							******************************;------------------------------------------------------------------------------** NAME: 		PrPicFile** PURPOSE:		To print a picture file** PASSED:		Users Print Record	  LONG		Handle to print record*				PortPtr				  LONG		Pointer to graf port*				PRStatus 			  LONG		Pointer to status record** RETURNED:	 NONE** NOTE:PortPtr cannot be same one returned by OpenDOC if we* allocated it ourselves.** PortPtr can be zero.*******************************************************************PrPicFile		PROC	EXPORT				DefineStackOrigD			word 0OrigB			byte 0rtl1			block 3rtl2			block 3UsersStatusPtr	long 0UsersPortPtr	long 0UsersPrintRecH	long 0* we need to get memory for everything.** If the application gave us pPrPort, we will use it,* otherwise we will use our.;				brk 42				**PROFILE;				pha;				tool _GetTick,out=(>StartTime:l);				pla				pha				lda >iPrErr				;see if any errors				beq Continue 			;branch if no errors				cmp #PortNotOn			;see if port was not on				bne Continue				plx				jmp Exit12Continue	;				pla				phd				tcd				phb			 			;save bank reg				phk				plb			 			;use our bank;--------------------------------------------------------------;; Look at the error code again.  If it is zero we go and print.; if it is none zero, we do not allocate anything for printing; and we dispose of things already allocated.;				lda iPrErr				beq GoAheadAndMakeMyDay				jmp PortDoneGoAheadAndMakeMyDay ;				lda method				bmi spoolPrt				brl NoErrorExit			; in draft printing we do nothing.spoolprt	;				jsr OpenInfoPrinting 	; put up dialog;------------------------------------------------------------;; Bring inputs to zero page.;				lda UsersStatusPtr,s				sta PZ_PrStatus				lda UsersStatusPtr+2,s				sta PZ_PrStatus+2				lda UsersPrintRecH,s				sta PZ_hPrint				lda UsersPrintRecH+2,s				sta PZ_hPrint+2				lda UsersPortPtr,s				sta PZ_pPrPort				lda UsersPortPtr+2,s				sta PZ_pPrPort+2 ;------------------------------------------------------------;; Look at port pointer.  If it is nil, get our own.;				lda #false				sta ourport				lda PZ_pPrPort				ora PZ_pPrPort+2				bne userPort				lda #true				sta ourport				lda #PortSize				ldx #%1000000000011000	; locked and dont cross bank				jsr OurGetHandle 				bcc @1				sta iPrErr				brl NoPort								@1				sta PZ_pPrPort				stx PZ_pPrPort+2				lda [PZ_pPrPort]				tax				ldy #2				lda [PZ_pPrPort],y				sta PZ_pPrPort+2				stx PZ_pPrPortuserPort	;				pei	PZ_pPrPort+2				pei	PZ_pPrPort				_OpenPort;------------------------------------------------------------;; Now look at status record pointer;				lda #false				sta ourStatus				lda PZ_PrStatus				ora PZ_PrStatus+2				bne userStatus				lda #OurStatusRecord				sta PZ_PrStatus				lda #^OurStatusRecord				sta PZ_PrStatus+2				lda #true				sta ourStatusUserStatus	;;------------------------------------------------------------;; Initialize the status record;				ldy #StatRecSize-2		; first zero it				lda #0ZeroLoop		sta [PZ_PrStatus],y				dey				dey				bpl ZeroLoop 				lda PZ_PrStatus			; put pointer to port in status rec				ldy #pPrPort				sta [PZ_PrStatus],y				iny				iny				lda PZ_PrStatus+2				sta [PZ_PrStatus],y				lda PZ_hPrint			; put handle to print record				ldy #shPrint 			; into status record.				sta [PZ_PrStatus],y				iny				iny				lda PZ_hPrint+2				sta [PZ_PrStatus],y				;------------------------------------------------------------;; Transfer the print record to the internal print record.;				PushLong PZ_HPrint				PushLong #HPrint				PushLong #TPrintSize				_HandToPtr;------------------------------------------------------------;; Get memory for the print buffer.  Mangled for speed.  ÑMSL;;------------------------------------------------------------;; First, get a 64K buffer to be safe with quickdraw.	ÑMSL;; Test for the pathological case.	If we can't get 64K for quickdraw and; 40K for ourselves (104K contiguous) chances are good that we'll crash during; printing.;; So, after we find our 104K, we give it back, then reserve the 64K for QD.; Finally, we start trying to find our buffer, starting at 60K.; This absotively, posilutely insures that we will have at least a 20K buffer if; we try to print, and we should be able to just squeeze by in the worst case...;; Admittedly, it is possible.;; OK, OK... or *not* contiguous!				bra DoBufCalc;				pha;				pha;				pea 1;				pea $A000;				PushWord UserID			your ID;				pea $C000;				pea 0;				pea 0;				_NewHandle				result on the stack!!!;				bcc DoBufCalc;				sta iPrErr				;				pushlong #LowMemMsg;				jsl ShowErr;				pla						Clean up stack.;				pla;				brl DoClosePort				NoBandMem		_DisposeHandle			Clean up stack.				bra NoMemMsgNoBandNoDispose	pla				pla				NoMemMsg		lda #$0201				sta iPrErr				pushlong #LowMemMsg							jsl ShowErr								brl DoClosePortDoBufCalc		;				_DisposeHandle			; it was there, ... yea...				pha						; Lock down 64K saved for QD.				pha				pea 1				pea 0				PushWord UserID			your ID				pea $C000				pea 0				pea 0				_NewHandle				result on the stack!!!				bcs NoBandNoDispose											lda #$C0				; try for a 60K buffer (max) first.				sta bandheight				jsr CalcBandSize				lda hprint+prXInfo+iDevBytes				ldx #%1000000000011000	; locked and dont cross bank				jsr OurGetHandle				bcc GotBandBuf							lda #$100				; Now try 128=40K, 64=20K, 32=10K				sta bandheight			PrBufCalcLoop	lsr bandheight				lda bandheight				cmp #$20				blt NoBandMem			; if it gets less than height of 32 (10K buffer), give up.										; things are *probably* hopeless...				jsr CalcBandSize				lda hprint+prXInfo+iDevBytes				ldx #%1000000000011000	; locked and dont cross bank				jsr OurGetHandle				bcs PrBufCalcLoop				GotBandBuf		sta hprbuf				stx hprbuf+2				lda [hprbuf]				sta pPrBuf				ldy #2				lda [hprbuf],y				sta pPrBuf+2				_DisposeHandle			Clean up stack (old 64K buf for QD). ÑMSL;------------------------------------------------------------;; lit la valeur dans le buffer de la picture.; (initialize the page number field of status record?); [Read the picture buffer value]				lda	ipagenum				ldy	#itotpages				sta	[PZ_PrStatus],y				jsr	PrPrintit				parameters are shared in zero page;------------------------------------------------------------;; maintenant libere les buffers si ce sont les notres; Or (now free the buffers that we own.);                          [if they are ours]				pushlong hprbuf				_disposehandle;------------------------------------------------------------;; Close the port.;DoClosePort		pushLong PZ_pPrPort				_closePort				lda ourport				cmp #true				bne portdone				pha				pha				PushLong PZ_pPrPort				_FindHandle				_disposehandleNoPort			jsr CloseInfo			; get rid of window dialogPortdone	;;----------------------------------------------------------;; Kill each of the pictures in the piclist, using ifstpage; ilstpage as start and end points.;				lda [hPicList]			; first deref the pic list				sta pPiclist				ldy #2				lda [hPicList],y				sta pPicList+2				ldx #0					; start at 0KillNextPic	 	cpx iPageNum 			; check against total pages				bcs KillPicList			; no more if >= pagenum				txa				asl a					; mult by 4				asl a				tay						; use as index into table				lda [pPicList],y				sta hnewPic				iny				iny				lda [pPicList],y				sta hNewPic+2				phx						; save counter				PushLong hNewPic 		; Dispose of this picture				_KillPicture				plx						; get X back				inx						; bump count				bra KillNextPic;------------------------------------------------------------------;; Now we can get rid of the picList itself;KillPicList	 PushLong hPicList				_DisposeHandle				PushLong CursorAd				_SetCursorNoErrorExit ;;				tool _GetTick,out=(>EndTime:l)			**PROFILE;				sublong >EndTime,>StartTime,>EndTime;				brk 42								lda	iPrErr				this will be the normal exit				plb				pld				jmp	exit12				ENDP				EJECT			;------------------------------------------------------------------------------** NAME: 		PrPixelMap** PURPOSE:		Prints out the pixel map** PASSED:		SrcLocPtr				LONG, ptr to source LocInfo*				SrcRectPtr				LONG, ptr to source rect*				ColorFlag				WORD, 0 = B/W, else Color** RETUNED:		NONE*;------------------------------------------------------------------------------PrPixelMap		PROC	EXPORT				DefineStackOrigD			word 0OrigB			byte 0rtl1			block 3rtl2			block 3ColorFlag		word 0SrcRectPtr		long 0SrcLocPtr		long 0				pha						; save value of d				pha				_DevIsItSafe				pla				bne Yes				lda #PortNotOn				sta >iPrErr				plx				jmp Exit8Yes ;				pla;------------------------------------------------------------;; save the registers and set direct page and data bank;				phd				tcd				phb				phk				plb;------------------------------------------------------------;; Get the current port's pointer and leave it on the stack; for restoring just before returning.;				pha				pha				_GetPort;------------------------------------------------------------;; Get the current cursor record's address and turn on the watch cursor.;				PushLong #0	; space for the address				_GetCursorAdr				pla				sta CursorAd				pla				sta CursorAd+2				_WaitCursor;------------------------------------------------------------;; Clear the error code and disallow status display;				stz iPrErr				; zero error								lda #True				sta NoShowMessage;------------------------------------------------------------;; Get new handle for print record. This is necessary because; StartLLD uses the values in the print record to set up; parameter such as page rectangle, color and quality for; the printer.;				lda #TPrintSize			; size of handle				ldx #%1000000000011000	; attributes				jsr OurGetHandle				bcc @1				sta iPrErr				brl NoPrintRec@1				sta PrintRecord				stx PrintRecord+2				PushLong PrintRecord				_PrDefault;------------------------------------------------------------;; Check if the application asked for color. If so, set bit; 5 of wdev in prStl of the print record.;				lda ColorFlag+4,s				beq BlackWhite				lda hprint+prStl+wDev				ora #f5				sta hprint+prStl+wDevBlackWhite	;;------------------------------------------------------------;; Get a handle for a grafport.;				lda #PortSize			; size of handle				ldx #%1000000000011000	; attributes				jsr OurGetHandle				bcc @1				sta iPrErr				brl NoPort@1				sta temp1				stx temp1+2				lda [Temp1]				sta PZ_pPrPort				ldy #2				lda [Temp1],y				sta PZ_pPrPort+2 ;------------------------------------------------------------;; Open the grafport.;				pei PZ_pPrPort+2				pei PZ_pPrPort				_OpenPort;-----------------------------------------------------------;; Start up the low level driver;				jsr startLLD				bcc Continue			; error checking added								sta iPrErr				; by Suki 5/25/88				brl ErrorExit;------------------------------------------------------------;; Get source bitmap information off the stack into local area;Continue				lda SrcLocPtr+4,s				sta temp1				; temp1 has Ptr to SrcLoc				lda SrcLocPtr+2+4,s				sta temp1+2				ldy #14MoveLoc 		lda [temp1],y				sta LocalLoc,y				dey				dey				bpl MoveLoc				lda temp1				clc				adc #8				sta LocalBoundsPtr		; this ptr used for intersection call				lda temp1+2				adc #0				sta LocalBoundsPtr+2				lda SrcRectPtr+4,s				sta temp2				; temp2 is ptr to source rect				lda SrcRectPtr+2+4,s				sta temp2+2				PushWord #0				; Result				PushLong LocalBoundsPtr				PushLong temp2				PushLong #LocalRect		; intesected rect goes here				_SectRect				pla				beq NoIntersection		; if false, no intersection;---------------------------------------------------------------;; Look at the source rect.	If its upper/left corner is 0,0; then no adjustment is necessary.	If it is not 0,0, we must; adjust the pointer to the pixel map so that it points to; the first pixel in the source rect.;; Note that this scheme does not work with source rects that; do not have the first pixel to draw as the first pixel in; a byte.;				lda		LocalRect				sec				sbc		LocalLoc+8				beq		NoAdjustmentY				pha						; space for result				pha				pha						; Top of src rect				PushWord LocalLoc+6		; width				_Multiply				pla				clc				adc LocalLoc+2				sta LocalLoc+2				pla				adc LocalLoc+4				sta LocalLoc+4NoAdjustmentY	;				lda LocalRect+2				sec				sbc LocalLoc+10				beq NoAdjustmentX				lsr a				bit LocalLoc-1				bpl ModeWas320				lsr aModeWas320		clc				adc LocalLoc+2				sta LocalLoc+2				bcc NoCarryHere				inc LocalLoc+4NoCarryHere ;NoAdjustmentX	;				lda LocalRect				sta LocalLoc+8				lda LocalRect+2				sta LocalLoc+10				lda LocalRect+4				sta LocalLoc+12				lda LocalRect+6				sta LocalLoc+14;------------------------------------------------------------;; Call LLDBitMap using the adjusted (if necessary) values in; LocalLoc and LocalRect.;				PushLong #LocalLoc				PushLong #LocalRect				PushWord UserID				lda hprint+prstl+wdev				and #f7				jsl LLDBitMap				jsl NewPage					; spit out paper when we're done;------------------------------------------------------------;; Close the grafport.;NoIntersection	;;------------------------------------------------------------;; We need to shut down low level driver.;				pushword UserID				jsl LLDShutDownErrorExit				pei PZ_pPrPort+2				pei PZ_pPrPort				_ClosePort;------------------------------------------------------------;; Get rid of the memory we allocated for grafport and print; record.;				pha						; first find the handle to				pha						; memory that port is in.				pei PZ_pPrPort+2				pei PZ_pPrPort				_FindHandle				_DisposeHandle			; then dispose it.NoPort				PushLong PrintRecord				_DisposeHandleNoPrintRec;------------------------------------------------------------;; Turn off the watch cursor.				PushLong CursorAd				_SetCursor;------------------------------------------------------------;; Restore the user's last current port, the pointer to it was; left on the stack at the beginning of this routine.;				_SetPort;------------------------------------------------------------;; We are done.;				lda iPrErr				plb				pld				jmp Exit10PrintRecord 	DS.B 4LocalBoundsPtr	DS.B 4LocalLoc		DS.B 16LocalRect		DS.B 8				ENDP				EJECT			;	 PrPrintIt;------------------------------------------------------------------------------** NAME: 		PrPrintIt** PURPOSE:		Prints one document (an internal routine called by PrPicFile.)*				(All parameters are passed via zero page and in memory.)** PASSED:		NONE** RETURNED:	 NONE*;------------------------------------------------------------------------------PrPrintit		PROC	EXPORT;----------------------------------------------------------;; We look at the idle proc in the print record.; If it is NIL then we put a pointer to our IDLE proc; in its place.;				lda	hPrint+PrJob+pIdleProc				ora	hPrint+PrJob+pIdleProc+2				bne	useridle				lda	#<PrAbortCheck				sta	hPrint+PrJob+pIdleProc				lda	#^PrAbortCheck				sta	hPrint+PrJob+pIdleProc+2useridle	;;----------------------------------------------------------;; Start up the low level driver.;				jsr startLLD						bcc Continue			; error checking added								sta iPrErr				; by Suki 5/25/88				brl Exit				;-----------------------------------------------------------;; Gather and show status of printer;Continue		jsr GetStatus								jsl CallIdleProc 		; does not come back if quits;-------------------------------------------------------------------;; Set up the initial conditions for the mode;				stz BandModeNum				lda deadloc2				and #$80				sta newSCB				sta oldSCB;----------------------------------------------------------;; Set the imaging flag to false in the status record.;				lda	#false				ldy	#fImaging				sta	[PZ_PrStatus],y;----------------------------------------------------------;; Put total copies into the status record.;				lda	hPrint+PrJob+iCopies				ldy	#iTotCopies				sta	[PZ_PrStatus],y;----------------------------------------------------------;; Calculate the number of bands it will take to print; one page.  This number is calculated by taking the; number of vertical lines on the page, adding the band; height, subtracting one and dividing this total; by the band height.;;	NumBands = (NumLines + BandHeight - 1 ) div BandHeight;; The number of lines depends on whether or not we are; in portrait or landscape mode.  In portrait mode, the; number of lines is the bottom of rpage.  In landscape; mode, the number of lines is the right of rpage.;; For some reason, the mode also plays a role in here.; In best mode the height is twice that of the rectangle; shown above.;;----------------------------------------------------------;; User choose landscape.;;	 ---------------------------------------------;	|	  | 	|	  | 	|	  | 	|	  |	|;	|	  | 	|	  | 	|	  | 	|	  |	|;	|	  | 	|	  | 	|	  | 	|	  |	|;	|	  | 	|	  | 	|	  | 	|	  |	|;	|	  | 	|	  | 	|	  | 	|	  |	|;	|	  | 	|	  | 	|	  | 	|	  |	|;	|	  | 	|	  | 	|	  | 	|	  |	|;	|	  | 	|	  | 	|	  | 	|	  |	|;	 ---------------------------------------------;	  Bands ... 								Partial Band;----------------------------------------------------------;; User selected portrait.;;	 ---------------------------------;	|								  |;	|								  |  Band;	|								  |;	 ---------------------------------;	|								  |;	|								  |  Band;	|								  |;	 ---------------------------------;	|								  |;	|								  |  Band;	|								  |;	 ---------------------------------;	|								  |;	|								  |  Band;	|								  |;	 ---------------------------------;	|								  |  Partial Band;	 ---------------------------------;;				pha						; Space udivide for result				pha				lda hprint+prStl+wDev	; look at portrait vs landscape mode				and #f1				bne use_v				; its portrait mode								lda hprint+prInfo+rpage+right	; **HACK**		ÑMSL 10/15/88				pha						; get it out of the normal page rect!												lda hprint+PrXInfo+ibandH				bra GotBandSizeuse_v			lda hprint+prInfo+rpage+bottom	; **HACK**		ÑMSL 10/15/88				pha						; get it out of the normal page rect!								lda hprint+PrXInfo+ibandVGotBandSize	 	pha				lda hprint+prStl+wDev	; test if 50% first				and #f3					;				beq normal				lda hprint+prStl+wDev	; now look at best vs faster mode				and #f0					;				beq normal				lda 3,s					; for best mode we double size				asl a				sta 3,snormal	;				lda 3,s				sta LinesPerPage 		; store total # per page				clc				adc 1,s				dec a				sta 3,s				_Udivide				pla				plx				sta	hPrint+PrXinfo+iBands		; and store result in print rec				ldy	#itotbands					; and in the status record.				sta	[PZ_PrStatus],y;----------------------------------------------------------;; on joue un peu aussi a mettre au point les qualites d'impression; en triturant wDev avec f0 f1 f2 f3 f4 ...;; mise a jour de CiDev a faire;;----------------------------------------------------------;; Set the curcopy field in the status record to one.;				lda	#1				ldy	#icurcopy				sta	[PZ_PrStatus],y;----------------------------------------------------------;; Start the outer loop for copies.;newCopy ;;----------------------------------------------------------;; Set the value of current page in the status record.; ( demarre une nouvelle page );				lda	#1				ldy	#icurpage				sta	[PZ_PrStatus],y;----------------------------------------------------------;; Start the new page loop;XnewPage;-----------------------------------------------------------;; Gather and show status of printer;				jsr GetStatus								jsl CallIdleProc				ldy #iCurPage				lda [PZ_PrStatus],y				jsr CalcPageBandNum				lda PageBandnum				sta BandModeNum;----------------------------------------------------------;; Get the handle to the picture associated with the current; page.;				lda [hPicList]			; first deref the pic list				sta pPiclist				ldy #2				lda [hPicList],y				sta pPicList+2				ldy #iCurpage			; now get the current page number				lda [PZ_PrStatus],y				dec a					; dec by one and mult by 4				asl a				asl a				tay						; use as index into table				lda [pPicList],y				sta hnewPic				iny				iny				lda [pPicList],y				sta hNewPic+2;----------------------------------------------------------;; Set the dirty flag in the status record to false.;				lda	#false				ldy	#fPgDirty				sta	[PZ_PrStatus],y;----------------------------------------------------------;; Check the paper feed type, if user chose manual feed,; put up the alert to insert the next sheet of paper;				lda	hprint+PrStl+Feed				cmp	#feedcut				bne	NoAsk				; automatic feed				jsr	InsertPaperAlert	; put up alert for manual feed				cpx	#2					; item hit is returned in X reg				bne	ReDraw				; 2 is ID of Cancel				brl	EndOfPrintingReDraw			lda #PrintProcess				ldx #^PrintProcess				jsr ShowString			; redraws "Printing in Progress..."NoASK	;;------------------------------------------------------------;; Call the idle proc again.;				jsl CallIdleProc;----------------------------------------------------------;; Calculate the first band rect. The top and left of this; band is top and left of rPage, bottom is top plus iBandH,; and right is left plus iBandV. iBandH and iBandV is pre-; calculated in CiXmetrics based on portrait or landscape.;* Top				lda	hPrint+PrInfoPT+rPage+Top				sta	rBand+Top* Bottom				clc				adc	hPrint+PrXInfo+iBandV				sta	rBand+Bottom* left				lda	hPrint+PrInfoPT+rPage+Left				sta	rBand+Left* right				clc				adc	hPrint+PrXInfo+iBandH				sta	rBand+Right				lda hprint+PrStl+Wdev	; test is we are in 50% landscape				and #f3				bne nocorrection				lda hprint+PrStl+Wdev				and #f1				bne nocorrection				lsr rBand+top			;should be 0 however				lsr rBand+Bottom 		;to be consistent with CiMetricsnocorrection	;;----------------------------------------------------------;; Now we really setup the band loop and get to it.;; Set current band to one in status record.;				lda	#1				ldy	#iCurBand				sta	[PZ_PrStatus],y				lda	LinesPerPage				sta	LinesLeftOnPage 	; initialize # of line to be printed								sta	Page_remain				jsr	CalcModeRemain;----------------------------------------------------------;; New Band Loop;newMode ;newBand ;;------------------------------------------------------------;; This seems to be the only place inside the printing loop; that we call idle proc.  Why do we bother with the; dirty flag and imaging flag if there is no way idle proc; can see them?;				jsl CallIdleProc;----------------------------------------------------------;; Set imaging and dirty page flags in status record.;				lda	#True				ldy	#fImaging				sta	[PZ_PrStatus],y				ldy	#fPgDirty				sta	[PZ_PrStatus],y;----------------------------------------------------------;; Open the band port.;				PushLong #BandPort				_OpenPort				;------------------------------------------------------------;; Start adjusting the fields in the loc info.;				lda deadLoc2				and #$80				sta BandLoc				lda pPrBuf				sta BandLoc+2				lda pPrBuf+2				sta BandLoc+4				lda hPrint+PrXInfo+iRowBytes				sta BandLoc+6;----------------------------------------------------------;; Look at the number of lines left on the page.; If it is less than the size of a band, we must; reduce the size of the band rect.;; We use the variable LinesLeftOnPage to tell us how; many lines are left on the page.	It was intialized; above when we calculated the number of bands.;; So even if we do not adjust the band rect, we; update LinesLeftOnPage for next time through the; loop.;				lda	hPrint+prStl+wDev				and	#f1				bne	trans0				; Portrait; landscape				lda	LinesLeftOnPage 			; look at num lines remaining				cmp	hprint+prXinfo+ibandH		; compare to band height				bge	sub_1						; its bigger so no adjustment				lda	LinesLeftOnPage 			; Use LinesLeftOnPage to adjust				clc								; the right of the band rect				adc	rBand+left				sta	rBand+rightSub_1			lda	LinesLeftOnPage 			; now we adjust LinesLeftOnPage				sec								; by subtracting the number of				sbc	hprint+prXInfo+ibandH		; lines we will print for				sta	LinesLeftOnPage 			; this band.				bra	trans; Portrait		trans0			lda	LinesLeftOnPage 			; look at num lines remaining				cmp	hprint+prXinfo+ibandV		; compare to band width				blt	sub_2					 ; its bigger so no adjustment				lda	hprint+prXinfo+ibandV		; compare to band widthSub_2			clc								; the bottom of the band rect.				adc	rBand+top				sta	rBand+bottom				lda	LinesLeftOnPage 			; now we adjust LinesLeftOnPage				sec								; by subtracting the number				sbc	hprint+prXInfo+ibandV		; of lines we will print				sta	LinesLeftOnPage 			; for this band.trans	;;----------------------------------------------------------;; Prepare the sizing rect based on the mode: best or faster;				MoveRect  hPrint+PrInfoPT+rPage,SizingRect				lda hprint+prStl+wdev	; check if 50% is on first				and #f3					; cuz we don't care about the				beq NormalSize			; resolution at this point				lda hprint+prStl+wdev	; if not, then we look at				and #f0					; whether Better Text or Color				beq NormalSize				asl SizingRect+4				asl SizingRect+6NormalSize	;;----------------------------------------------------------;; Copy the band rect to the bounds rect of the LocInfo.;				ldx	#6tbandrect		lda	rband,x				sta	BandLoc+8,x				dex				dex				bpl tbandrect;----------------------------------------------------------;; Set various and interesting fields in the band; graf port.;				PushPtr BandLoc			; Set the loc info				_SetportLoc;----------------------------------------------------------;; Set the PortRect to the band rect too.;				PushLong #rBand				_setportrect;----------------------------------------------------------;; Set the cliprgn and visrgn to the sizing rect.;				PushLong #SizingRect 	; set clip rgn to				_cliprect				pushlong #0				; and the vis rect!				_getcliphandle				_setvisrgn;----------------------------------------------------------;; Fill the band rect with white.;				PushLong #rBand			; fill the band with white.				PushLong #White				_FillRect;----------------------------------------------------------;; Draw the picture;;				tool _GetTick,out=(>TmpTime:l)		**PROFILE								PushLong hNewPic				PushLong #SizingRect				_drawpicture				;				tool _GetTick,out=(>EndTime:l)		**PROFILE;				sublong >EndTime,>TmpTime,>TmpTime;				addlong >TmpTime,>DrawTime,>DrawTime;-----------------------------------------------------------;; Gather and show status of printer;				jsr GetStatus								jsl CallIdleProc;----------------------------------------------------------;; Print it.;				pushptr bandport				PushLong #rBand				pushword UserID				lda hprint+prstl+wdev				and #f7				jsl LLDBitmap								;-----------------------------------------------------------;; Gather and show status of printer;;				jsr GetStatus				;				jsl CallIdleProc;----------------------------------------------------------;; Close the band port.;				PushPtr BandPort				_ClosePort;----------------------------------------------------------;; Clear the imaging flag.;				lda	#false				ldy	#fImaging				sta	[PZ_PrStatus],y;----------------------------------------------------------;; Calculate the next band position.  Different for; portrait vs landscape.;				lda	hPrint+prStl+wDev				and	#f1				bne	addv; Landscape				lda	rBand+left				clc				adc	hPrint+PrXInfo+iBandH				sta	rBand+left				lda	rBand+right				clc				adc	hPrint+PrXInfo+iBandH				sta	rBand+right				bra	Added; PortraitaddV	;				lda	rBand+Bottom				sta	rBand+Topadded	;;----------------------------------------------------------;; See if we are done.;				ldy	#iCurband			; bump cur band and put back				lda	[PZ_PrStatus],y				inc	a				sta	[PZ_PrStatus],y;			 dec  a 				  ; dec by one;			 ldy  #iTotBands		  ; and compare to total bands;			 cmp  [PZ_PrStatus],y;			 bcs  noMoreBands		  ; greater or equal and we are done.				lda linesleftonpage				beq nomoreBands				bmi nomoreBands				brl NewBand				; else new bandnomoreBands ;				jsr detectnewmode				bcc alldone				brl newmodealldone ;;----------------------------------------------------------;; Check if printing with gap or no gap, don't send form feed; if no gap is chosen				lda hPrint+prStl+wDev				and #f6				beq NoFormFeed			; 0 is no gap				jsl newpage;----------------------------------------------------------;; Bump page count;NoFormFeed		ldy	#iCurPage			; bump curpage				lda	[PZ_PrStatus],y				inc	a				sta	[PZ_PrStatus],y 	; and put back				dec	a				ldy	#iTotPages			; look at total pages				cmp	[PZ_PrStatus],y 	; compare to curpage				bcs	NoMorePages				brl	XnewPageNoMorePages ;;----------------------------------------------------------;; Bump copy count.;				ldy	#iCurCopy				lda	[PZ_PrStatus],y				inc	a				sta	[PZ_PrStatus],y				dec	a				ldy	#iTotCopies				cmp	[PZ_PrStatus],y				bcs	NoMoreCopies				brl	newCopynomoreCopies	;;----------------------------------------------------------;; This is where we go if idle proc gets tells us to quit.;				EXPORT	EndOfPrintingEndOfPrinting				pushword UserID				jsl LLDShutDownExit			rts				Export	hNewPalettehNewPalette		DC.L	paletteDatapaletteData		DS.B	$20Page_Remain		DS.B	2BandModeNum		DS.B	2nextbottom		DS.B	2newSCB			DS.B	2oldSCB			DS.B	2PageBandNum		DS.B	2				EXPORT	CurLLDMode	CurLLDMode				DS.B 2				EJECT;------------------------------------------------------------------------------;; NAME: 		CalcModeRemain;; PURPOSE:		Calculate the mode that remains;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------*= set up a new band remain for the current mode.* update also the page remain by the difference.				EXPORT CalcModeRemainCalcModeRemain					lda newscb				;get the new scan control byte				eor #$0f				sta oldScb				;update as the old one				jsr detectnewmode		;see if its a new mode				rts;------------------------------------------------------------------------------;; NAME: 		DetectNewMode;; PURPOSE:		Detects if a mode change occurs and sets things up appropriately;; PASSED:		NONE;; RETURNED:	 (Carry)					CLEAR, no change or done;										SET, change;;------------------------------------------------------------------------------detectnewmode	;; si BandModeNum= num de la list; ou pas de list; ou landscape; alors clc; sinon setup the new values and return sec.				lda hprint+prStl+wDev				and #f1				beq EscapeDone; ok it is portrait 				lda Page_remain				beq EscapeDone; test if there is a SCBList				lda hPrint+PrXInfo+SCBList				sta Temp1				lda hPrint+PrXInfo+SCBList+2				sta Temp1+2				ora Temp1				beq EscapeDone				lda BandModeNum				cmp [Temp1]				blt goodenoughEscapeDone		clc				rtsEscapeDone1		pla				clc				rtsgoodenough	;				pha				pha				pha				lda #$24 				;each entry is $24				pha				_multiply				ply				pla				iny						;pass over the length				iny				lda [Temp1],y				sta nextbottom				iny				iny				lda [Temp1],y				phy				tax				xba				and #$ff				ldy	#icurpage				cmp	[PZ_PrStatus],y				bne	EscapeDone1				txa				and #$ff				sta newSCB; read palette.				ply				iny				iny				ldx #0looppall		lda [Temp1],y				sta palettedata,x				iny				iny				inx				inx				cpx #$20				bne looppall; compare with old scb and update width and lld mode				lda newscb				eor oldSCB				and #$80				beq setPalette; we changed mode (320-640); update LLD				lda CurLLDMode				ora #1					;set 640				ldx NewSCB				cpx #$80				bge ok640				and #$fffeok640			pha				pushword UserID				jsl LldSetQuality		;set the mode; update the Width.				lda NewScb				cmp #$80				bge do640; now 320				lsr hPrint+PrXInfo+iBandH				bra setpalettedo640			asl hPrint+PrXInfo+iBandHsetpalette	;				Pushlong hNewPalette				Pushword #0				Pushword UserId				jsl lldsetcolor; ok now calculate the new BandRemain.				inc BandModeNum; test if double sized, so double new bottom.				lda hprint+prStl+wDev				and #f0				beq easy1				asl nextbottomeasy1	;				lda nextbottom				sec				sbc rband+top				beq goAgain				bge more1goAgain 		brl detectnewmodemore1			cmp Page_Remain				blt more2				lda Page_Remainmore2			sta linesleftonpage				lda Page_Remain				sec				sbc linesleftonpage				sta Page_Remain; update old SCB				lda newSCB				sta oldSCB				sec				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		CalcPageBandNum;; PURPOSE:		Calculates the number of page bands;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------CalcPageBandNum ;				pha				stz PageBandNum				;default is failed				lda hPrint+PrXInfo+SCBList				sta Temp1				lda hPrint+PrXInfo+SCBList+2				sta Temp1+2				ora Temp1				beq Loose; on va parcourir la list et s'arreter sur la premiere valeur; correspondant a cette page.				lda [temp1]				bne winloose			pla				rtswin ;				tax				lda Temp1				clc				adc #2				sta Temp1				bcc noInc2				inc Temp1+2noInc2	;				txaloop	;				pha				ldy #2				lda [temp1],y				xba				and #$ff				cmp 3,s				blt more				beq found				pla				pla				rts						;page num too bigfound			pla				pla				rtsmore	;				lda Temp1				clc				adc #$24				sta Temp1				bcc noInc				inc Temp1+2noInc			inc PageBandNum				pla				dea				bne loop				pla				rts				ENDP				EJECT;------------------------------------------------------------------------------** NAME: 		StartLLD** PURPOSE:		Shared routine to startup the low level routines.** PASSED:		NONE** RETURNED:	 NONE*;------------------------------------------------------------------------------startLLD		PROC	EXPORT;;First calculate zero page area for low level routines.;				tdc						;give lld our zero page				clc				adc #$100				;add $100 for next zero page;NOTE: low level zero page is $100 above current zero page				pha				pushword UserID				jsl LLDStartup			;startup low level routines;-----------------------------------------------------------;; Added error checking code. Suki Lee  May 25, 1988;				bcc @1				brl ErrorExit				@1				jsr GetStatus			; what state is printer in?* set paper rect for the LLD				stz LLD_PaperRect		;zero it				stz LLD_PaperRect+2				PushLong #0				PushLong #0				lda hPrint+PrStl+iPageV				pha				lda #6				pha				_multiply				pla				plx				pha				lda #5				pha				_Udivide				pla				sta LLD_PaperRect+4				pla				PushLong #0				PushLong #0				lda hPrint+PrStl+CRwidth				pha				lda #4				pha				_multiply				pla				plx				pha				lda #3				pha				_Udivide				pla				sta LLD_PaperRect+6		;equals CRwidth*4/3				pla;;Set the low level Page Rectangle;				pushptr LLD_PaperRect				pushword UserID				jsl LLDSetPageRect* set quality for the printer				pushword #%1000000000000001		 high color				lda hprint+prStl+wdev			;see if 2x zoom				and #f3				beq hires						;branch if 2x				lda hprint+prStl+wdev			;see if high resolution				and #f0				beq size2						;branch if not high resolutionhires			pla				pushword #%1000000000000011		 high ressize2	;				lda	hPrint+prStl+wDev			;see if portrait				and	#f1				bne	portrait2					;branch if portrait				pla				ora #$4000						landscape				phaportrait2	;;------------------------------------------------------------------------;; Check if Condensed vertically;				lda hprint+prstl+wdev				and #f2				bne Vsizing				; yes				pla				ora #$2000				phaVsizing ;				lda deadloc2				and #$80				bne lld640				pla				and #$fffe				mode320 for lld				phalld640	;;-----------------------------------------------------------;; Check the printer info string for presence of color ribbon. The format of; this string for the ImageWriter II is: IW10CF ;                                  where IW = ImageWriter II;                                        10 = carriage width;								          C = if color ribbon installed;  								          F = if sheet feeder installed;; string format for the ImageWriter LQ is: LQ1CFEnP;                                  where LQ = ImageWriter LQ;                                         1 = 15" carriage width;								          C = if color ribbon installed;  								          F = if sheet feeder installed, no envelope;										  E = if sheet feeder w/envelope installed;										  n = # of sheet feeders;										  P = if in pull tractor mode;; The string is terminated by a carriage return; Note: An ImageWriter I will not respond to the query.;				ldx #8LoopZero		lda #0					; makes sure the string is clean				sta PtrType,x				dex				dex				bpl loopZero								PushPtr PtrType				jsl CheckPrinter		; go get its type				lda PtrType				; no reponse --> IW I				beq BW				ldx #4					; assume Imagewriter II for now				cmp #$514C				; see if it's an LQ				bne LWII				ldx #3					; it's an LQLWII			lda PtrType,x							and #$00FF				cmp #$0043				; letter C?				bne BW				lda	hPrint+prStl+wDev	;see if color/bw				and	#f5				bne	Color				;branch if colorBW				pla				and #$7fff				;is b/w				phaColor	;				lda 1,s					;get mode				sta curLLDMode			;save for CurLLDMode				pushword UserID				jsl LldSetMode			;set low level mode				Pushlong hpalette				Pushword #0				Pushword UserId				jsl lldsetcolor			;set the color				lda #0ErrorExit		rts				Export	hpalettehpalette		DC.L	$e19e00				Export	PtrTypePtrType			DS.B	10				ENDP				EJECT;------------------------------------------------------------------------------** NAME: 		PrAbortCheck** PURPOSE:		This is the routine that is the default idel proc. if the user*				doesn't specifiy one in the print record.** PASSED:		NONE** RETURNED:	 NONE*;------------------------------------------------------------------------------PrAbortCheck	PROC 	EXPORT					should be in scc68kmore	;				PushWord #0				PushWord #$0408			KeyDown				PushPtr EventRecord				_getNextEvent				pla				beq bye				lda evtmsg				cmp #$2E				bne more				lda evtmods				and #$0100				beq more				lda #iPrAbort								sta iPrErrbye 			rtl				ENDP;------------------------------------------------------------------------------** NAME: 		CallIdleProc** PURPOSE:* This routine calls the idle proc given in the print record.* Upon return, it checks iPrErr.  If it is not zero we do not* return to calling routine.** PASSED:		NONE** RETURNED:	 NONE*;------------------------------------------------------------------------------CallIdleProc	PROC	EXPORT				jsl CallIt				;actually call the idle proc routine				lda iPrErr				beq Done				;--------------------------------------------------------------;; If user wanted to quit we should eject current page if something; has been printed on it already.;				ldy #fPgDirty				lda [PZ_PrStatus],y				beq dontEject			; if not dirty, don't eject				jsl NewPagedontEject		phb						; 3 bytes on stack this makes 4				plx						; now pull off 4				plx				brl EndOfPrintingDone			rtl				EJECT;------------------------------------------------------------------------------;; NAME: 		CallIt;; PURPOSE:		This routine sets up the stack so that it will rtl to the;				idle proc (which was specified in the print record, or the;				default one).;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT CallitCallIt	;				lda hPrint+PrJob+pIdleProc+1	 ;get the idel proc. addr.				pha								;push onto the stack				phb				lda hPrint+PrJob+pIdleProc				dec a				sta 1,s							;push the rest of the addr.				rtl								;rtl to the idle proc. routine				ENDP;------------------------------------------------------------------------------** NAME: 		InsertPaperAlert** PURPOSE:		Alert Box for manual feed; to let user know the next sheet of*				paper should be inserted.** PASSED:		NONE** RETURNED:	 NONE*;------------------------------------------------------------------------------InsertPaperAlert PROC	EXPORT				PushLong CursorAd				_SetCursor			 ; restore cursor back to arrow				pha						; make room for result				_GetMasterSCB				pla				pha						; make room for result of alert call				and #$80 				; check mode				beq mode320				; 320 mode				pushlong #alerttemp640	; use 640 mode template				bra GoOnmode320 		pushlong #alerttemp320	; use 320 mode templateGoOn			pushlong #$0000				_Alert				;------------------------------------------------------------;; Get the current cursor record's address and turn on the watch cursor.;				PushLong #0	; space for the address				_GetCursorAdr				pla				sta CursorAd				pla				sta CursorAd+2				_WaitCursor				; set to watch again				plx						; get the item hit off stack				rts				ENDP;--------------------------------------------------------------;;				ShowErr(msg);								ShowErr			PROC	EXPORT				input msgptr:l				begin +b				_SysBeep				_SysBeep								PushLong #0				_getport 				;get current port				PushLong infoDPort				_setPort 				;set to info. dialog port				PushPtr EraseInfoRect				_eraseRect				;erase whats already there				Pushlong InfoStrPos				_moveto					;move to where to draw text				PushLong msgptr				_drawString				;draw the text from InfoStrBuffer				_setPort 				;restore the port				;				Wait for a while to let the user see it.								lda #$1FFFloop1			ldx #$00FFloop2			dex				bne loop2				dea				bne loop1								return				ENDP