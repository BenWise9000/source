		ENTRY DerefColor	ENTRY HookProc	ENTRY LLDExit4	ENTRY LLDExit2	ENTRY LLDExit10	ENTRY LLDExit8	ENTRY ScreenShoot	ENTRY LLDExit6	ENTRY FormFeed	ENTRY LLDExit0	ENTRY ResetPrinter	ENTRY SendRC;	ENTRY PrintCheck	ENTRY MovePen	ENTRY SetColor	ENTRY SetColorT	ENTRY GetColorT	ENTRY Pattern	ENTRY SpeDens	ENTRY VSizing	ENTRY DrvrBitMap	ENTRY ContLine	ENTRY DrvrRect	ENTRY LandStock	ENTRY HightLand	ENTRY FlagT	ENTRY FlagB	ENTRY CurrentLine	ENTRY ContLine	ENTRY VSizing	ENTRY CurrentDef	ENTRY FlagBlack	ENTRY SendBuff	ENTRY SendRCLF	ENTRY LittleSkip	ENTRY WasImage	ENTRY WasImage1	ENTRY WasImage2	ENTRY MakeLine	ENTRY MakeBlankLine	ENTRY FinalPat	ENTRY BitMapShoot	ENTRY SendSingleCar	ENTRY SendBPrep	ENTRY WriteStr	ENTRY StrCmp		ENTRY HeightLine01				ENTRY EndTime,DrawTime,PortTime,TmpTime,StartTime				include 'm16.msl'				; LLD.MAIN0;------------------------------------------------------------------------------;; Low Level Tables and Equates;;------------------------------------------------------------------------------HandleReal		EQU	  $F4PointerReal		EQU	  $F8LLDSystem		PROC	EXPORT				EXPORT	MyPID		MyPID			DC.W	0	42				EXPORT	MyWAP		MyWAP			DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0				DC.B	0					ENDP; LLD.MAIN1;;  Main LLD.;* Zero page equates (While in Low Level Driver) (Allocated at users +$100)HandleDrvr		EQU	  $00MemoryDrvr		EQU	  $04Quality 		EQU	  $06HandleColor	 EQU	  $08HandleScreen	EQU	  $0CPtrBitMap		EQU	  $10PtrColor		EQU	  $14HandleIO		EQU	  $18PtrBlack		EQU	  $20PtrRed			EQU	  $24PtrBlue 		EQU	  $28PtrYellow		EQU	  $2CPtrLocal		EQU	  $30PenPosH 		EQU	  $34PenPosV 		EQU	  $36NewPenPosH		EQU	  $38NewPenPosV		EQU	  $3ALock			EQU	  $3EPageRectPtr	 EQU	  $40PageRect		EQU	  $44PtrInfo 		EQU	  $4CStock			EQU	  $50Stock2			EQU	  $52PtrID			EQU	  $54;Recharge		gequ	$58Go				EQU	  $5CStatus			EQU	  $66;FlagRecharge	gequ	$74BackColor		EQU	  $76PtrRect 		EQU	  $96;BackFlag		gequ	$9AMyStack 		EQU	  $9CRealStack		EQU	  $9ESaveStack		EQU	  $A0JobPrint		EQU	  $A2StockWStr		EQU	  $A4StockWTxt		EQU	  $A8PageRectL		EQU	  $AAStack			EQU	  $AESaveStack2		EQU	  $F0MyId			EQU	  $F2Owner			EQU	  $F4HandleID		EQU	  $F8Error			EQU	  $F6DarkerMode		EQU	  $FA;; MyWap equates;NbUser			EQU	  $0EPID 			EQU	  $1EPenPosVW		EQU	  $18IDBack			EQU	  $1aGraphP			EQU	  $1cIDWap			EQU	  $16Killer			EQU	  $24PMID			EQU	  $0012					EJECT				Export	Cidrvr		Cidrvr			PROC;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDStartUp;;  PURPOSE:	 Starts up the low level routines;;  PASSED:		WORD 					Zero Page;				WORD 					User ID;;  RETURNED:	(A-reg.) 				=0, No Errors;										=$1308: error in establishing connection ;												with the printer (Suki 5/25/88);										=$1321, LLDStartup already made;										=Memory Mgr. Errors returned unchanged;										NOTE: 'Error' retains error value;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT	LLDStartUp	LLDStartUp		jsl xLLDStartUp				rtl;-----------------------------------------------				EXPORT	xLLDStartUp xLLDStartUp	;* Stack: 1: Rtls*		 7: ID*		 9: ZeroPage				phb						;save users bank				phk						;get this programs bank				plb						;set bank to programs bank;-----------------------------------------------------------;; commented out the following branch since it is not taken in ; normal conditions, and if taken, the stack is not cleaned up ; properly.   Suki Lee 6/24/88;;Now see if this is initial time;				lda MyWap+$16			;get ID;				bne JustStartUp			;branch if not first time** Here zero page is needed*				PushWord #0				_MMStartUP				;make sure memory manager is started				pla				sta		MyPID				sta		MyWap+$16		;save ID in MyWapok1 ;				phd						;save D-reg.; Stack: 1: Direct zero page;		 3: Plb;		 4: Rtls;		 10: ID;		 12: ZeroPage				lda		12,s 			;get passed direct page				tcd						;use passed direct page;;This initlizes the zero page values;ok6 ;				ldx		#3				lda		#0				ldy		#$18LoopInitWap		sta		MyWap,y			;init. MyWap table				iny				iny				dex				bne		LoopInitWap				pld						;Put user zero-page				plb						;Put user data bank register;;Just startup (no initialization stuff);JustStartUp ;				phd				lda		11,s 			;One allowed zero-page !				tcd				sta		MyWap			;Save zero page addess* Stack: 1: ZeroPage application*		 3: Rtls*		 9: ID*		 11: ZeroPage* Now the startup begins* Clear this new zero-page				ldx		#$F6				lda		#0loop			sta		<0,x				dex				dex				bpl		loop				lda		MyWap+IDWap		;get Waps ID				sta		MyID 			;put in zero page* Stack: 1: ZeroPage application*		 3: Rtls*		 9: ID*		 11: ZeroPage;* Allocate memory for IOBuffer;				PushLong #0				PushLong #$2800				PushWord <MyID				PushWord #%0000000000000000 No locked, no fixed, PurgeLvl0				PushLong #0				_NewHandle				bcc		OkIoBuff 		;branch if no erros				brl		ErrorOpenOkIoBuff		pla						;save Handle for IO at 'HandleIO'				sta		<HandleIO				pla				sta		<HandleIO+2;* Allocate memory for Color Table;				PushLong #0				PushLong #$200				PushWord <MyID				PushWord #%0000000000000000 No locked, no fixed, PurgeLvl0				PushLong #0				_NewHandle				bcc		Lab1 			;branch if no errors				brl		ErrorOpenlab1	;				pla						;save handle for color table				sta		<HandleColor				pla				sta		<HandleColor+2* Init some default value				jsr		DerefColor		;deref. the color table to <PtrColor				phb						;save B-reg.				phk						;get programs bank				plb						;set data bank to programs bank;;Initilize the color table (16 palettes x 16 tables);				ldy		#0				stz		ComptCol 		;init. which tableLoopColor2		ldx		#0				;for each paletteLoopColor		lda		InitColor,x				sta		[<PtrColor],y				iny				iny				inx				inx				cpx		#$20				bne		LoopColor				inc		comptcol				lda		Comptcol				cmp		#16				;for sixteen palette tables				bne		LoopColor2				PushLong <HandleColor				_HUnLock 				;unlock it;;Init. the Page Rectangles (Portrait and Landscape);				stz		<PageRectL		0 pixel at left margin landscape				stz		<PageRect		0 pixel at top margin				stz		<PageRect+2		0 pixel at left margin				lda		#1280			1280 pixels at right margin				sta		<PageRect+6				lda		#1584			1584 pixels at bottom margin				sta		<PageRectL+2				lda		#1584			1584 pixels at bottom margin				sta		<PageRect+4;Init. the background color table				ldx		#$1E 			Init BackGround Color				lda		#$10LoopBackC		sta		<BackColor,x				dex				dex				bpl		LoopBackC				lda		#$8000			Init Mode				sta		<JobPrint				lda		10,s				sta		<Owner				lda		#0				sta		MyWap+PID				sta		MyWap+PID+2				sta		MyWap+PID+4;Copy the hook procedures for (SSC) Super Serial Card to zero page at '<Go'				ldx		#20				Put all hooks to SSC in zero pageloopHook		lda		HookProc,x				sta		<Go,x				dex				dex				bpl		LoopHook				;-----------------------------------------------------------;; Added call to open port and reset printer.;; (Suki Lee 1 Mar 88);			    lda #0				pha				pha				pha				pha				_PrDevOpen				;-----------------------------------------------------------;; Added error checking code. Suki Lee  May 25, 1988;				bcc AllsWell			; no problems												lda 9,s					; application's ID				jsr ShutDown			; dispose handles already allocated								lda #PntrConFailed				bra Exit				AllsWell;¥¥	Don't play with asynch stuff unless we're printing to AppleTalk;	ÑÑ MSL 10/12/89				spacelong				_PMGetPortName		; old macro.  It's now called Ô_PrGetPortDvrNameÕ				pushlong #AppleTalk				jsl StrCmp				bcs @didAppleTalk				lda #1				sta >itsAppleTalk				;¥¥	New code from Suki, 10/9/89		ÑÑMSL				stz ReadingDone				stz ReadingLength							PushWord #0			; space for actual length				Pushptr MyCompletion				PushWord #10		; the response to self ID is no more than 10 bytes				Pushptr ReadBuffer				_PrDevAsyncRead				pla					; this value is invalid at this									; point in time since this is an									; async read call;¥¥					@didAppleTalk	jsr ResetPrinter								lda		#0				;indicate no errors on returnExit			plb								pld				brl		LLdExit4AppleTalk		STR		'APPLETALK'				EXPORT itsAppleTalkitsAppleTalk	DS.W	1;------------------------------------------------------------------------------* Error on StartUp, We simulate a ShutDown to finish;-----------------------------------------------------------------------------* Stack: 1: HandleIO*		 5: ZeroPage application*		 7: Rtls*		 13: ID*		 15: ZeroPageErrorOpen	;				ply				ply								sta		<Error			Take ID for ShutDown				lda		9,s				jsr		ShutDown* Stack: 1: ZeroPage application*		 3: Rtls*		 9: ID*		 11: ZeroPageNowKill 		lda		13,s 			Setup stack as for a real ShutDown				sta		15,s				lda		11,s				sta		13,s				lda		9,s				sta		11,s				lda		7,s				sta		9,s				lda		5,s				sta		7,s				lda		3,s				sta		5,s				lda		1,s				sta		3,s				pla* Stack: 1: ZeroPage application*		 3: Rtls*		 9: ID				brl		KillLLD;¥¥ New code from Suki, 10/9/89		ÑÑMSL;--------------------------------------------------------------;; Completion routine for PAPRead which saves error returned; and sets done flag;	EXPORT MyCompletionMyCompletion		;       				sta >ReadError				txa				sta >ReadingLength	; actual length read							lda #True				sta >ReadingDone							rtl				EXPORT ReadErrorReadError		DS.B 2				EXPORT ReadingDoneReadingDone		DS.B 2				EXPORT ReadingLengthReadingLength	DS.B 2				EXPORT ReadBufferReadBuffer		DS.B 10;¥¥	Export	ComptColComptCol	DC.W	0	;Counter used in init. of color tables	Export	InitColorInitColor	DC.W	$0000	;Initial color palette values	DC.W	$0F00	DC.W	$00F0	DC.W	$000F	DC.W	$0088	DC.W	$0808	DC.W	$0066	DC.W	$0555	DC.W	$0AAA	DC.W	$0F80	DC.W	$08F8	DC.W	$0F88	DC.W	$0FF0	DC.W	$0F0F	DC.W	$00FF	DC.W	$0FFF				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDShutDown;;  PURPOSE:	 Shuts down the low level stuff;;  PASSED:		WORD 					User ID;;  RETURNED:	(A-reg.) 				=zero, No errors;										=$1108, Locked User;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT	LLDShutDown LLDShutDown	 	jsl xLLDShutDown				rtl;-----------------------------------------------				EXPORT	xLLDShutDownxLLDShutDown	phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it				Bit		Lock 			;Check if locked User				bmi		ShutLock				lda		9,s				;User ID				jsr		ShutDown 		;ShutDown the user;;We arrive here when we need to kill a low level call;* Stack: 1: ZeroPage application*		 3: Rtls*		 9: IDKillLLD ;* Now return to MicroLLD				_PrDevClose				stz MyWap+$16			;flag for next entry (done for now)				pld				lda #0				brl LLDexit2* Error for ShutDownShutLock	;				lda		#$1108			Error: Locked UserSErrID	;				pld				brl		LLdExit2 			Error: Unknown user;------------------------------------------------------------------------------;;  NAME:		ShutDown;;  PURPOSE:	 Subroutine which aids in shutting down low level routines;;  PASSED:		(A-reg.) 				User ID;;  RETURNED:	NONE;;------------------------------------------------------------------------------* Real Shutdown. Entry: A ID*						D User zeroPageShutDown	;				sta		<Stock				PushLong <HandleIO				_DisPoseHandle			;dispose of the IO buffer				PushLong <HandleColor				_DisposeHandle			;dispose of the color table				sec				rts				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDBitMap;;  PURPOSE:	 Prints Bit Maps;;  PASSED:		A-reg					­0, Darker mode;				LONG 					Pointer to the BitMap;				LONG 					Pointer to the Rectangle;				WORD 					UserID;;  RETURNED:	(A-reg.) 				=0, No Errors;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT	LLDBitMap	LLDBitMap		jsl xLLDBitMap				rtl;-----------------------------------------------				EXPORT	xLLDBitMap	xLLDBitMap		phd						;Take user's ZeroPage				pha				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it				pullword <DarkerMode* Stack: 1: Application direct page*		 3: rtls*		 9: ID*		 11: ptr rect*		 15: Ptr BitMap				jsr		InitPrinting;Get the pointer to the bit map				lda		15,s				sta		<PtrBitMap				lda		17,s				sta		<PtrBitMap+2;Get the rectangle				lda		13,s				sta		<PtrRect+2				lda		11,s				sta		<PtrRect				jsr		BitMapShoot		;print the bit map				lda		#0ErrId1			pld				brl		LLdExit10				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDText (alias TextStreaming);;  PURPOSE:	 Prints text.;;  PASSED:		LONG 					Pointer to the text to be printed;				WORD 					Length (no. of bytes) of the text;				WORD 					UserID;;  RETURNED:	(A-reg.) 				=0, No Errors;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT	LLDText 	LLDText 		jsl xLLDText				rtl;-----------------------------------------------				EXPORT	xLLDTextxLLDText 		phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it* Stack: 1: Application direct page*		 3: rtls*		 9: ID*		 11: length*		 13: Ptr Text;-----------------------------------------------------------;; comment out on Mar 25, 1988. There's no use for this check since the next; two statements has been commented out.;;				lda		MyWap+$1c;				cmp		#2;				beq		LL1;-----------------------------------------------------------;; commented out on 1 Mar 88; Suki Lee;				lda		#2;				jsr		InitSSCLL1 ;;				lda		11,s;				bne		BText;				bra 	EndText 		; filter out foreign chars;BText			jsr 	BackText;***********************************added by luc for foreign chars.***********FiltreText	;				lda		11,s				bne		@1				brl		EndText				@1				phd				tsc				tcd				lda		[15] 			; zero page and stack are same				pld						; at this point				pha				lda		15,s				clc				adc		#1				sta		15,s				bcc		easyInc				lda		17,s				ina				sta		17,sEasyInc ;				lda		13,s				dea				sta		13,s				pla				and		#$ff				cmp		#$0d			; All characters whose ASCII code is less				beq		easyCar			; than $20 is ignores except for $0A (line 				cmp		#$0a			; feed), $0C(formfeed), and $0D (carriage				beq		easyCar			; return)				cmp		#$0c				beq		easyCar				cmp		#$20				blt		FiltreText				cmp		#$80			; $80 and up contains special characters 				bge		Specialcar		; that we will filtereasyCar 		Jsr		SendSingleCar	; otherwise, send it as normal character				brl		FiltreText				Specialcar	;				pha				lda		SpeCarTable		; start from the botoom of the table				asl		a				; and check to see if this character				tax						; deserves special handling				plaLoopSpe 		cmp		SpeCarTable,x				beq		FounditSpe		; if it is, then go off and do it				dex				dex				bne		LoopSpe				brl		FiltreTextFounditSpe		txa				asl a				taxLoopExchg	;				lda		#0				sep		#$20				longa off				lda		ExchgCar,x		; substitute with the character from				rep #$20				; the table				longa on				and #$FFFF				beq		DoneSpe			; 0 indicates it's done				phx				Jsr		SendSingleCar				plx				inx				bra		LoopExchgDoneSpe 		brl		FiltreTextEndText 		lda		<Error				pld				brl		LLdExit8				Export	ExchgCarExchgCar		DC.B	$00				DC.B	$00				DC.B	$00				DC.B	$00				DC.B	'a'			; a circumflex				DC.B	$08				DC.B	$5e				DC.B	$00				DC.B	'a'			; a acute				DC.B	$08				DC.B	$27				DC.B	$00				DC.B	'a'			; a grave				DC.B	$08				DC.B	$60				DC.B	$00				DC.B	'a'			; a dieresis				DC.B	$08				DC.B	$7e				DC.B	$00				DC.B	$5C			; c cedilla				DC.B	$00				DC.B	$00				DC.B	$00				DC.B	'e'			; e circumflex				DC.B	$08				DC.B	$5e				DC.B	$00				DC.B	'e'			; e acute				DC.B	$08				DC.B	$27				DC.B	$00				DC.B	'e'			; e grave				DC.B	$08				DC.B	$60				DC.B	$00				DC.B	'e'			; e dieresis				DC.B	$08				DC.B	$7e				DC.B	$00				DC.B	'i'			; i circumflex				DC.B	$08				DC.B	$5e				DC.B	$00				DC.B	'i'			; i acute				DC.B	$08				DC.B	$27				DC.B	$00				DC.B	'i'			; i grave				DC.B	$08				DC.B	$60				DC.B	$00				DC.B	'i'			; i dieresis				DC.B	$08				DC.B	$7e				DC.B	$00				DC.B	'o'			; o circumflex				DC.B	$08				DC.B	$5e				DC.B	$00				DC.B	'o'			; o acute				DC.B	$08				DC.B	$27				DC.B	$00				DC.B	'o'			; o grave				DC.B	$08				DC.B	$60				DC.B	$00				DC.B	'o'			; o dieresis				DC.B	$08				DC.B	$7e				DC.B	$00				DC.B	'u'			; u circumflex				DC.B	$08				DC.B	$5e				DC.B	$00				DC.B	'u'			; u acute				DC.B	$08				DC.B	$27				DC.B	$00				DC.B	'u'			; u grave				DC.B	$08				DC.B	$60				DC.B	$00				DC.B	'u'			; u dieresis				DC.B	$08				DC.B	$7e				DC.B	$00				Export	SpeCarTableSpeCarTable 	DC.W	21				DC.W	$89 ; a circonflex				DC.W	$87 ; a Aigu				DC.W	$88 ; a grave				DC.W	$8a ; a trema				DC.W	$8D ; c cedilla				DC.W	$90 ; e circonflex				DC.W	$8e ; e Aigu				DC.W	$8f ; e grave				DC.W	$91 ; e trema				DC.W	$94 ; i circonflex				DC.W	$92 ; i Aigu				DC.W	$93 ; i grave				DC.W	$95 ; i trema				DC.W	$99 ; o circonflex				DC.W	$97 ; o Aigu				DC.W	$98 ; o grave				DC.W	$9a ; o trema				DC.W	$9e ; u circonflex				DC.W	$9c ; u Aigu				DC.W	$9d ; u grave				DC.W	$9f ; u trema				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDHardCopy;;  PURPOSE:	 Prints whats on the screen;;  PASSED:		NONE;;  RETURNED:	(A-reg.) 				=0, No errors;										=Memory Mgr. errors returned unaltered;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT	LLDHardCopy LLDHardCopy	 	jsl xLLDHardCopy				rtl;-----------------------------------------------				EXPORT	xLLDHardCopyxLLDHardCopy	phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it				jsr		InitPrinting 	;initilize things for printing				jsr		ScreenShoot		;print the screenErrId3			pld				brl		LLdExit6;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		NewPage;;  PURPOSE:	 Causes a new page (page eject) to occur.;;  PASSED:		NONE;;  RETURNED:	NONE;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT	NewPage 	NewPage 		jsl xNewPage				rtl;-----------------------------------------------				EXPORT	xNewPage	xNewPage		phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it;-----------------------------------------------------------;; Changed to use reset the printer by Suki and Steve; 1 Mar 88;;				lda		#3;				jsr		InitSSC;				jsr 	ResetPrinter												jsr		FormFeed 		;do a form feedErrId14 		pld				brl		LLdExit0				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDControl (alias Control);;  PURPOSE:	 Performs low level print commands;;  PASSED:		WORD 					PrinterControlValue;										=1 (reset printer);										=2 (cause form feed);										=3 (cause line feed);;  RETURNED:	(A-reg.) 				=0, No errors;										=$1209, Invalid PrinterControlValue;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT	LLDControl	LLDControl		jsl xLLDControl				rtl;-----------------------------------------------				EXPORT	xLLDControl xLLDControl	 	phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it				lda		9,s				;get control value				cmp		#1				bne		Lab70;We arrive here if PrinterControlValue=1 (RESET PRINTER);-----------------------------------------------------------;;-----------------------------------------------------------;; Removed by Suki and Steve since it is redundant ; 1 Mar 88;;				lda		#3;				jsr		InitSSC				jsr		ResetPrinter 	;send reset printer command				bra		ErrId70Lab70			cmp		#2				bne		Lab71;We arrive here if PrinterControlValue=2 (FORM FEED)				jsl		NewPage					New Page				bra		ErrId70Lab71			cmp		#3				bne		lab72;We arrive here if PrinterControlValue=3 (LINE FEED);-----------------------------------------------------------;; Changed to use reset the printer by Suki and Steve; 1 Mar 88;;				lda		#3;				jsr		InitSSC				jsr 	ResetPrinter				jsr		SendRC			;send a line feed				bra		ErrId70lab72			lda		#$1209ErrId70 		pld				brl		LLdExit2;------------------------------------------------------------------------------;;  NAME:		InitPrinting;;  PURPOSE:	 Initializes things for printing;;  PASSED:		NONE;;  RETURNED:	NONE;;------------------------------------------------------------------------------InitPrinting	;						Check if new Init or Zap Needed;-----------------------------------------------------------;; 5 lines removed by Suki Lee; 1 mar 88;;				lda #3;				jsr InitSSC;				jsr		PrintCheck;				lda		#1;				jsr		InitSSC				lda		<JobPrint				sta		<Quality 		;set the quality				bpl		EndInit			;branch if Black and White				lda		MyWap+PID				beq		EndInit			Printer is off or unknown. Do nothing				lda		MyWap+PID+4		Check if printer has a color ribbon				bmi		EndInit			Color ribbon found				lda		#$7fff				and		<Quality				sta		<QualityEndInit ;				rts				EJECT								;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:        CheckPrinter;;  PURPOSE:  To check out which type of	printer;;  PASSED:      LONG	Pointer to Info string;;  RETURNED:    (A-reg.)	=0, No Errors;;	¥¥¥ Entire routine replaced 10/9/89 with Suki's version.  ÑÑMSL;       Éreworked 10/12/89 to deal correctly with direct-connect.;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT CheckPrinterCheckPrinter	jsl xCheckPrinter				rtl;-----------------------------------------------				EXPORT xCheckPrinterxCheckPrinter	phd	;Take user's ZeroPage				lda MyWap	;get saved LLD zero	page addr.				tcd	;use it							lda 9,s	; get the buffer pointer off the stack				sta <PtrInfo				lda 11,s				sta <PtrInfo+2SendIDComm		PushLong #P_SelfID				jsr WriteStr				bcc @1				brl ErrorExit@1								lda itsAppleTalk				bne doItAsync				pha						; space for actual read count				lda <PtrInfo+2			; pointer to passed buffer				pha				lda <PtrInfo				pha				lda #10					; request 10 bytes				pha				LoopWait2		jsr GetStatus				lda PStatus				bne LoopWait2				_PrDevRead				pla				bra ErrorExit	doItAsync		PushLong #0	; set initial value for the 5 second timer				_GetTick				pla				sta Timer					pla	; ignore high wordLoopWait1				jsr GetStatus		; need to check if the printer is offline				jsl prAbortCheck		; and if the user cancels				lda iPrErr			; user cancelled				bne ErrorExit		; let's split now				lda PStatus			; printer not responding				bne LoopWait1		; wait til user corrects problem, or cancelsLoopRead		lda ReadingDone		; wait until async read completes				bmi GotIt								PushLong #0			; check if 5 seconds has passed since				_GetTick			; the self ID command is sent				pla				plx					; we need not deal with high word				sec				sbc Timer			; subtract starting	value				bcs NoBorrow		; if borrow is needed, a wrap had 				adc #$FFFF			; occurred. We'll add $10000 to get				adc #1				; the positive value and compare to 	NoBorrow		cmp #300			; 5 secs (60 ticks/sec * 5 sec = 300)				blt LoopRead							bra SendIDComm		; No response after 5 seconds, go resent the									; the command, as recommand by Tim HarringtonGotIt			lda ReadError		; check error				bne ErrorExit		; exit now if there	is one;----------------------------------------------------------------;; Moves the data returned in the read buffer into the buffer; passed by the caller.				PushPtr ReadBuffer				lda <PtrInfo+2				pha				lda <PtrInfo				pha				PushWord #0				; high byte of long	word is always 0				PushWord ReadingLength	; since the length is 512 max				_BlockMoveErrorExit		pld				brl LLdExit4							Export P_SelfIDP_SelfID		DC.B 2					;Command to ask for	printers self ID				DC.B $1b,$3FTimer			DS.B 2								;				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDSetQuality			(alias LLDSetMode);;  PURPOSE:	 to set the printing quality at JOBPRINT (called by StartLLD);;  PASSED:		WORD 					QUALITY;				WORD 					UserID;;  RETURNED:	(A-reg.) 				=0, No Errors;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT	LLDSetQualityLLDSetQuality				EXPORT	LLDSetMode	LLDSetMode		jsl xLLDSetQuality				rtl;-----------------------------------------------				EXPORT	xLLDSetQualityxLLDSetQuality	phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it		;	*** MSL	Ñ 3/17/89		;	*** Have to do this after the printer has been ID'd		;		in order to avoid confusing the printer on AppleTalk		;		Why? I don't know.  But we _do_ want the automatic LF's on line		;		wrap in Draft mode, so...		;		;		So, this isn't the right place to do it, but it has to be		;		in a place w/ the DP set correctly.  <Sigh>		;				PushLong #WrapIt		;force linefeed when lines wrap (draft)				jsr WriteStr				lda DraftModeQuality				beq @didmode				bit #$0800				beq @ckCorr				PushLong #NLQMode				jsr WriteStr				bra @didmode@ckCorr			bit #$0100				beq @didmode				PushLong #CorrMode				jsr WriteStr@didmode* Stack: 1: Direct Page Application*		 3: rtls*		 9: ID user*		 11: Quality				lda		11,s 			;get quality				sta		<JobPrint				lda		#0ErrId4			pld				brl		LLdExit4				Export	DraftModeQualityDraftModeQuality DS.W	1WrapIt			DC.B	4,27,68,32,0		NLQMode			DC.B	2,27,$4DCorrMode		DC.B	2,27,$6D				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDSetPenPos;;  PURPOSE:	 Sets the printer head position;;  PASSED:		WORD 					Pens Horzontal Position;				WORD 					Pens Vertical Position;				WORD 					User ID;;  RETURNED:	(A-reg.) 				=0, No Errors;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT	LLDSetPenPosLLDSetPenPos	jsl xLLDSetPenPos				rtl;-----------------------------------------------				EXPORT	xLLDSetPenPosxLLDSetPenPos	phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it* Stack: 1: Direct Page Application*		 3: rtls*		 9: User Id*		 11: NewPenPosV*		 13: NewPenPosH				lda		11,s 			;get the pens vertical position				sta		<NewPenPosV				lda		13,s 			;get the pens horizontal position				sta		<NewPenPosH				jsr		MovePen			;move the print head to location				Lda		#0ErrID6			pld				brl		LLdExit6				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDSetColor;;  PURPOSE:	 To set one color palette in the color palette table;;  PASSED:		LONG 					Pointer to color palette values;				WORD 					Which color palette in color table;				WORD 					User ID;;  RETURNED:	(A-reg.) 				=0, No Errors;;------------------------------------------------------------------------------;------------------------------------------------------------------------------;-----------------------------------------------				EXPORT	LLDSetColor LLDSetColor	 	jsl xLLDSetColor				rtl;-----------------------------------------------	EXPORT	xLLDSetColorxLLDSetColor	phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it* Stack: 1: Direct Page*		 3: Rtls*		 9: ID*		 11: Color palette in color table*		 13: Ptr to color palette				jsr		SetColor				lda		#0ErrID17 		pld				brl		LLdExit8				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDSetTColor;;  PURPOSE:	 Sets the color palette table (whole table);;  PASSED:		LONG 					Pointer the new color palette table;				WORD 					User ID;;  RETURNED:	(A-reg.) 				=0, No Errors;;------------------------------------------------------------------------------;------------------------------------------------------------------------------				EXPORT	LLDSetTColorLLDSetTColor;-----------------------------------------------				jsl xLLDSetTColor				rtl;-----------------------------------------------				EXPORT	xLLDSetTColorxLLDSetTColor 	phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it* Stack: 1: Direct Page*		 3: Rtls*		 9: ID*		 11: Ptr to color palette				jsr		SetColorT		;set the color palette table				lda		#0ErrID20 		pld				brl		LLdExit6;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDGetTColor;;  PURPOSE:	 Copies the color pallete table to the specified location;;  PASSED:		LONG 					Pointer to where to store color table;				WORD 					User ID;;  RETURNED:	(A-reg.) 				=0, No Errors;;------------------------------------------------------------------------------;------------------------------------------------------------------------------				EXPORT	LLDGetTColorLLDGetTColor;-----------------------------------------------				jsl xLLDGetTColor				rtl;-----------------------------------------------				EXPORT	xLLDGetTColorxLLDGetTColor 				phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it* Stack: 1: Direct Page*		 3: Rtls*		 9: ID*		 11: Ptr to color palette				jsr		GetColorT		;get the color pallete				lda		#0ErrID21 		pld				brl		LLdExit6				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;;  NAME:		LLDSetPageRect;;  PURPOSE:	 Sets the page rectangle;;  PASSED:		LONG 					Pointer to page rectangle;				WORD 					User ID;;  RETURNED:	(A-reg.) 				=0, No Errors;;------------------------------------------------------------------------------;------------------------------------------------------------------------------** Page Rect*				EXPORT	LLDSetPageRectLLDSetPageRect;-----------------------------------------------				jsl xLLDSetPageRect				rtl;-----------------------------------------------				EXPORT	xLLDSetPageRect xLLDSetPageRect				phd						;Take user's ZeroPage				lda		MyWap			;get saved LLD zero page addr.				tcd						;use it* Stack: 1: Direct Page Application*		 3: rtls*		 9: ID user*		 11: PageRect				lda		11,s 			;get the pointer to the page rect.				sta		<PtrInfo				lda		13,s				sta		<PtrInfo+2		;get the rest of the pointer;Now copy the page rectangle				ldy		#6LoopSetPage	 lda		[<PtrInfo],y				tyx				sta		<PageRect,x				dey				dey				bpl		LoopSetPage				lda		<PageRect+2		 Calc Landscape ratio				sta		<PageRectL				lda		<PageRect+6				sta		<PageRectL+2				lda		#0ErrID10 		pld				brl		LLdExit6				ENDP				; LLD.HardCopy				EJECT******************************							** Lld.HardCopy				**							** Current Rev: Nov. 1987	**	 Hard Copy				**							******************************HardCopy		PROC	EXPORT;------------------------------------------------------------------------------;; NAME: 		ScreenShoot;; PURPOSE:		To print the screen;; PASSED:		WORD 					Type Flag;										 =0 Whole screen;										^=0 Top only;				WORD 					Background Flag (NOT USED);				WORD 					User ID;; RETURNED:;;------------------------------------------------------------------------------				EXPORT	ScreenShoot 						;Make a screencopyScreenShoot	 	phb				phk				plb				lda		#200				sta		BottomScreen 	;set bottom of screen to 200				stz		ContLine 		;init. counter				stz		RectScreen+2 	;set left to zero				lda		#640				sta		RectScreen+6 	;set right to 640				lda		#200				sta		RectScreen+4 	;set bottom to 200				stz		RectScreen		;set top to zero; Stack: 1 : plb;		 2 : rts;		 4 : User Zero page;		 6 : rtls;		 12 : ID;		 14 : Background flag;		 16 : Type flag;; Take TopWindow if needed;				lda		16,s				beq		NoTop			;branch if not top only				PushLong #0				PushLong #0				The Front Window				_FrontWindow				_GetStructRgn			  Vis region of TopWindow				lda		1,s				sta		<PtrLocal		;save the regions handle				lda		3,s				sta		<PtrLocal+2;; ============================================; ===  WARNING FORBIDDEN BUT NEEDED ACTION ===; ============================================;  This region is a rectangle. I need to dereference the region;		  Rectangle Region: 0A 00 Top Left Bottom Right;				PushLong <PtrLocal				_HLock					;lock the region				ldy		#2				lda		[<PtrLocal]				tax				lda		[<PtrLocal],y				stx		<PtrLocal		;now we have the pointer				sta		<PtrLocal+2				lda		[<PtrLocal],y				sta		ContLine				iny				iny				lda		[<PtrLocal],y				sta		RectScreen+2				iny				iny				lda		[<PtrLocal],y				sta		BottomScreen				iny				iny				lda		[<PtrLocal],y				sta		RectScreen+6				_HUnLock 				;now unlock the regionNoTop	;;; First we must save ColorTable of the user; We ask for a handle for this purpose;				PushLong #0				Ask for handle for saving color table				PushLong #$0200				PushWord MyPID				PushWord #%0000000000011100 Purge level0. Not locked, not fixed				PushLong #0				_NewHandle;;  If a memory manager error occurs, we get out;				bcc		NoError34				brl		ColorError;;  Take the handle, and dereference it;NoError34	;				pla						;first save the handle				sta		SaveHColorT				pla				sta		SaveHColorT+2				jsr		DefColorTable	;dereference SaveHColorT to <PtrLocal;;  We save user table color and we put screen color table;				PushLong <PtrLocal				PushWord <Owner			 User ID				jsl LLDGetTColor				PushLong SaveHColorT				_HUnLock 				;Unlock it;;;;;;;;;;;;;;;;PushLong #$E19E00		;On met la palette de couleur ecran				pea $00E1				; (PushLong #$E19E00)				pea $9E00				PushWord <Owner			;User ID				jsl LLDSetTColorDirect	;;;  Init hardcopy. Save <JobPrint, and init PortLoc;				_HideCursor				jsr		Init 			;initialize things;;  Put actual Screen address in PortLoc ($E1/2000);				lda		#$E1 			Screen Address				sta		ScrLoc+4				lda		#$2000				sta		BeginScreen;;  Main loop for printing;loopdirect	;;;  Ask the first change in the SCB table;				jsr		CheckSCB 		Make a BitMap Loc;;  Can't make a landscape screen shoot with changing SCB;				bcs		ErrorLand;;  Do actual printing of a zone;				PushLong #ScrLoc				PushLong #RectScreen				PushWord <Owner				lda <DarkerMode				jsl LLDBitMap			;print it;; Test if end of printing;				lda		ContLine 		;get current line we are on				cmp		BottomScreen 	;Test for end of screen				bne		loopDirect		;loop until at bottom;; Close all handles. Restore user's color table, <Quality;				jsr		CloseHard		Close all handle				_ShowCursor				;display the cursor;;  Leave without errors;				lda		#0				plb				rtsErrPr			dc.b 0,$C0				;brk		$C0;; We attempted to do landscape printing with a changing SCB;ErrorLand	;				jsr		CloseHard		Close all handle;------------------------------------------------------------------------------; NOTE: $1213;------------------------------------------------------------------------------				lda		#$1213			Hardcopy in landscape impossible				plb				rts;------------------------------------------------------------------------------;  We arrive here with with an error on _NewHandle for Handle color;------------------------------------------------------------------------------ColorError	;						Error on HandleColor				plx				plx				plb				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		CloseHard;; PURPOSE:		Shuts down things used by 'ScreenShoot';; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------CloseHard	;;; Restore the users saved color table;				jsr		DefColorTable	;derefernce SaveHColorT to PtrLocal				PushLong <PtrLocal				PushWord <Owner				jsl LLDSetTColor 		;restore users color table				PushLong SaveHColorT				_DisposeHandle			;dispose of it;;  Restore <JobPrint;				lda		SaveQuality				sta		<JobPrint				rts;------------------------------------------------------------------------------;; NAME: 		Init;; PURPOSE:		Saves the Quality and inits the Srcloc values;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------; Save <JobprintInit	;				lda		<JobPrint				sta		SaveQuality		;Save the quility;;  Init SrcLoc values;				stz		ScrLoc+8 		Boundsrect Top				stz		ScrLoc+10		Boundsrect Left				stz		ScrLoc			SCB				lda		#$a0				sta		ScrLoc+6 		length of a line in bytes				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		CheckSCB;; PURPOSE:		Check SCB (Scan Control Block) until the first change;; PASSED:		NONE;; RETURNED:	 (Carry Bit)				=0, If portrait mode or unchanged SCB's;										=1, If landscape and changing SCB's;;------------------------------------------------------------------------------CheckSCB	;;; Calc beginning of bitmap (current line times $a0);				PushLong #0				PushWord Contline		;current line				PushWord #$A0				_Multiply				pla						;get result of multiply				clc				adc		BeginScreen		;add in the beginning of screen				sta		ScrLoc+2				pla;;  Look at the first SCB;				PushWord #0				PushWord ContLine				_GetSCB					;gets the SCB for that line				lda		1,s				and		#$000F			;look only at color table no.				sta		ScrLoc			;save it for now				stz		ContRect 		;init counter;;  main loop for checking for changing SCB's;LoopCheck	;				inc		ContRect				inc		ContLine 		;look at current line				lda		ContLine				cmp		BottomScreen				beq		EndCheck 		;branch if its at screens bottom				PushWord #0				PushWord ContLine				_GetSCB					;get SCB of current line				pla				and		#$000F			;look only at color table bits				cmp		ScrLoc			;see if different from first SCB's				beq		LoopCheck		;branch if same;; We arrive here if at bottom or different SCB color table reference was found;EndCheck	;				pla						;get the first SCB that was checked				and		#$008F			;look only at color table and mode bits				sta		ScrLoc				lda		ContRect				sta		ScrLoc+12		;save the line we ended with (bottom)				lda		<JobPrint		;assume 320 mode				and		#$FFFE			;so AND out bit for 320 mode				sta		<JobPrint				ldx		#320 			;assume 320 mode				lda		ScrLoc				and		#$00F0				beq		OkMode			;branch if 320 mode;We arrive here if its 640 mode				ldx		#640				inc		<JobPrint		;turn on 640 mode bitOkMode			stx		ScrLoc+14		;save mode (320 or 640)				lda		<JobPrint				and		#$4000			;look at landscape/portrait bit				beq		Xclc 			;branch if portrait (SCB doesn't matter)				lda		ContLine 		;get line we stopped with				cmp		BottomScreen 	;see if its bottom of screen				beq		Xclc 			;branch if hit bottom				sec						;else flag changing SCB				rts;We arrive here when we are in portrait mode or unchanging SCB'sXclc			clc				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		DefColorTable;; PURPOSE:		Dereferences SaveHColorT (color table) to <PtrLocal;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------DefColorTable	;				PushLong SaveHColorT 	;lock the handle				_HLock				lda		SaveHColorT		;store handle to zero page temporary				sta		<NewPenPosH				lda		SaveHColorT+2				sta		<NewPenPosH+2				ldy		#2				;now dereference to <PtrLocal				lda		[<NewPenPosH]				sta		<PtrLocal				lda		[<NewPenPosH],y				sta		<PtrLocal+2				rts				EJECT;------------------------------------------------------------------------------; Tables;------------------------------------------------------------------------------SaveHColorT		DS.B	  4 				;saved handle to the color tableSaveScreen		DS.B	  4ScrLoc			DS.B	  16SaveQuality		DS.B	  2 				;saved QualityContLine		DS.B	  2 				;current lineContRect		DS.B	  2BeginScreen		DS.B	  2 				;beginning of screenBottomScreen	DS.B	  2 				;bottom of screenRectScreen		DS.B	  8				ENDP; LLD.BitMap******************************							** CiDrvr: Printer Driver IW **	bitmapDrvr				**							** Current Rev: Nov. 1987	**							******************************* quality:		8000 => B/W vs Color*				4000 => landscape vs portrait*				2000 => vertical sizing*				0002 => Hires vs Highcolor*				0001 => 640 vs 320* From quality we set up other variables:* spedens:		0		if portrait or 320	*				4000	 if landscape 640 lores*				8000	 if landscape 640 hires  (144dpi)* vsizing		8000	 if portrait and vsizing* currentDef:  	4		if highcolor and spedens=0*				8		otherBitMapDrvr		PROC	EXPORT;------------------------------------------------------------------------------;; NAME: 		BitMapShoot;; PURPOSE:		Performs the actual printing of a bitmap image;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	BitMapShoot BitMapShoot				jsr		Pattern			;setup the initial print patterns				phb						;Activate local Data Bank Register				phk				plb				stz		SpeDens			;init. variables				stz		Vsizing				lda		<Quality 		;look at quality				and		#$6002				cmp		#$2002				bne		noVsizing		;branch if no vert. sizing				sec				ror		Vsizing			;set vertical sizing high bitnoVSizing	;				lda		<Quality				and		#$4000			;look at landscape vs portriat				beq		NoProblem		;branch if portrait				lda		<Quality				and		#$0003				cmp		#$1				beq		Problem1				cmp		#3				bne		NoProblem				lda		#$8000				sta		SpeDens			Landscape Quality 4 					bra		NoProblemProblem1		lda		#$4000			LandScape Quality 2				sta		SpeDens;Now copy the bitmap definition to DrvrBitMapNoProblem		ldy		#14				;Copy BitMap definitionLoop1			lda		[<PtrBitMap],y				sta		DrvrBitMap,y				dey				dey				bpl		loop1				stz		ContLine 		;init. current print buffer line* I Check if Printed Rect was inside BoundsRect with QuickDraw* With all LLD calling QuickDraw must be activate unless HardCopy.* HardCopy make an internal calling to Print BitMap, then I sure that Printed* was inside BoundsRect.				lda		<PtrBitMap				clc				adc		#8				sta		<PtrLocal				lda		<PtrBitMap+2				adc		#0				sta		<PtrLocal+2				PushWord #0				Check if BoundsRect is empty				PushLong <PtrLocal				_EmptyRect				ldx		#$1113			No possible intersection				pla				beq		ErrorBit				PushWord #0				Check if Printed Rect is empty				PushLong <PtrRect				_EmptyRect				ldx		#$1114			No possible intersection				pla				beq		ErrorBit				PushWord #0				PushLong <PtrLocal		Calculate the Intersection between				PushLong <PtrRect		Printed Rect and BoundsRect and				PushLong #DrvrRect		the result is the real Printed Rect				_SectRect				ldx		#$1115			No intersection				pla				bne		L4ErrorBit		stx		<Error				plb				rtsl4				ldy		#2				;Make a translation of originloop13			lda		DrvrBitMap+12,y	;Top,Left of BoundsRect became 0,0				sec						;and all other coord. are calculated again				sbc		DrvrBitMap+8,y	;with this new origin				sta		DrvrBitMap+12,y				lda		DrvrRect,y				sec				sbc		DrvrBitMap+8,y				sta		DrvrRect,y				lda		DrvrRect+4,y				sec				sbc		DrvrBitMap+8,y				sta		DrvrRect+4,y				dey				dey				bpl		loop13				stz		DrvrBitMap+8 	Tb became 0				stz		DrvrBitMap+10	Lb became 0				lda		<Quality 		;look at landscape vs portriat				and		#$4000				beq		L41				;branch if portriat;------------------------------------------------------------------------------* Landscape printing. We translate printed rect and boundsrect into other* direction. Tb and Lb are needed to be equal 0;------------------------------------------------------------------------------				lda		DrvrBitMap+12	Tb <- Tb				ldy		DrvrBitMap+14	Lb <- Lb				sta		DrvrBitMap+14	Bb <- Rb				sty		DrvrBitMap+12	Rb <- Bb				lda		DrvrRect+2		Tr <- Lr				sta		LandStock		Lr <- Bb-Br				lda		DrvrRect+6		Br <- Rr				sta		LandStock+2		Rr <- Bb-Tr				lda		DrvrRect+4				sta		HightLand				lda		DrvrBitMap+14				sec				sbc		DrvrRect+4				sta		DrvrRect+2				lda		DrvrBitMap+14				sec				sbc		DrvrRect				sta		DrvrRect+6				lda		LandStock				sta		DrvrRect				lda		LandStock+2				sta		DrvrRect+4* If Printed Rect's and BoundsRect's Top and Bottom are not equal, there are* some blank lines at the beginning and at the end of the picture* If Printable paper is smaller than Printed Rect we must shrink Printed Rect				lda		<Quality				and		#$1				tax				lda		<PageRectL		Left margin landscape				sta		<PageRectPtr				lda		<PageRectL+2 	Right margin landscape				sta		<PageRectPtr+2				bra		Shrink;------------------------------------------------------------------------------; PORTRAIT;------------------------------------------------------------------------------L41 ;				lda		<PageRect+2		Left margin portrait				sta		<PageRectPtr 	Left margin in pixel				lda		<PageRect+6		Right margin portrait				sta		<PageRectPtr+2	Right margin in pixelShrink	;				lda		<Quality				and		#$3				tax				lda		DrvrRect+6				jsr		CalcPoPi				adc		<PageRectPtr				cmp		<PageRectPtr+2				bcc		NoShrink				lda		<PageRectPtr+2				jsr		CalcPiPo				sta		DrvrRect+6NoShrink	;* If landscape with vertical sizing, then  multiply DrvrRect+6 by 2				lda		<quality				and		#$6000				cmp		#$6000				bne		noAsl				asl		DrvrRect+6		;times twonoasl	;				lda		DrvrRect				beq		Equal1				sta		FlagT			Number of lines to skip at the topEqual1			lda		DrvrBitMap+12				sec				sbc		DrvrRect+4				beq		L3				sta		FlagB			Number of lines to skip at the bottomL3	;						The Good rect is in DrvrRect 				stz		CurrentLine				lda		FlagT				sta		ContLine 		Nb BitMap lines to skip at the top				lda		<Quality 		ResVert=8 if single horizontal line				ldx		#8				ResVest=4 if double horizontal line				and		#$0002				bne		L1				bit		SpeDens			Quality 2 landscape				bvs		L1				lda		spedens				ora		Vsizing				bmi		willdo				lda		<quality;Special case out 320 vertical condensed				cmp		#$6000			;see if landscape 320 (vert. condensed)				beq		willdo				cmp		#$E000			;see if color landscape 320 (vert. cnd)				beq		willdo				and		#$2000				bne		L1willdo	;				ldx		#4				Quality 1 and 2;				asl 	FlagT			 Twice more sheet lines to skip at the top;				asl 	FlagB			 idem at bottomL1				stx		CurrentDef				bit		Vsizing				bmi		Double				bit		SpeDens				bpl		NoDoubleDouble	;				asl		CurrentDef		Special vertical density;------------------------------------------------------------------------------;; This is the actual print loop;				1. Skip no. of lines from top;				2. Make a buffer;				3. Print a buffer;				4. (loop for all buffers for screen);				5. Skip no. of lines at bottom;------------------------------------------------------------------------------NoDouble		ldx		FlagT			Skip lines at the top				jsr		SkipXLine				jsr		SendBPrep		;Send prep. stuff				lda		#1				sta		FlagBlack		;force first time to clear buffersSuite			jsr		MakeBuff 		;make Buffer. Done if carry is setLoop3			php						;Save Carry				jsr		SendBuff 		;send the buffer to the printer				plp						;restore carry				bcs		EOF2 			;branch if done with rect.				jsr		SendRCLF 		;perform a carriage return, line feed				brl		SuiteEOF2			jsr		SkipBLine		;skip lines left at bottom				plb				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		CalcPiPo;; PURPOSE:		Calculates a printer pixel to a point on the screen;; PASSED:		(X-reg.);; RETURNED:	 (A-reg.);;------------------------------------------------------------------------------				EXPORT	CalcPiPo							Translate Pixel Printer en PointCalcPiPo		bit		SpeDens				bmi		divise2				bvs		Divise4				cpx		#3				beq		NoCalcPiPo				cpx		#0				beq		Divise4				bra		Divise2Divise4 		lsr		aDivise2 		lsr		aNoCalcPiPo		rts;------------------------------------------------------------------------------;; NAME: 		CalcPoPi;; PURPOSE:		Calculates a point on the screen to a pixel;; PASSED:		(X-reg.);; RETURNED:	 (A-reg.);;------------------------------------------------------------------------------				EXPORT	CalcPoPi							Translate Point Screen en PixelCalcPoPi		bit		Spedens				bmi		popimult2				bvs		PopiMult4				cpx		#3				beq		NoCalcPoPi				cpx		#0				beq		PoPiMult4				bra		PoPiMult2PoPiMult4		asl		aPoPiMult2		asl		aNoCalcPoPi		rts				EJECT;------------------------------------------------------------------------------;; NAME: 		SkipBLine;; PURPOSE:		Skip lines left at the bottom of the page;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------SkipBLine	;				bit		SpeDens				bmi		SkipBSpe				bit		Vsizing				bmi		SkipBSpe				lda		CurrentDef		;get current no. pixel lines per print				cmp		#$8				beq		l5				asl		DrvrRect+4l5				lda		DrvrRect+4				and		#$0007				bne		OkModulo				lda		#8OkModulo		clc				adc		FlagB				tax				jsr		SkipXLine		;skip no. of lines as per (X) reg.				rts;------------------------------------------------------------------------------;; NAME: 		SkipXLine;; PURPOSE:		To cause the printer to skip (X) number of lines down the page.;; PASSED:		(X-reg.) 				No. of lines to skip;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	SkipXLine	SkipXLine		bit		SpeDens				bmi		SkipXSpe				bit		Vsizing				bmi		SkipXSpe				phx				txa				lsr		a				lsr		a				lsr		a				beq		NoBlock			Nb block of 8 lines to skip				cmp #1				bne nobeeper				pha;;;;;;;;;;;;;;;;;;;;;;;;;;;;;				ldx #$2c03;				jsl $e10000				;beeeeeeeeeeeeeeeeeep;;;;;;;;;;;;;;;;;;;;;;;;;;;;				planobeeper	;				cmp #0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SPEED Enhancement;;;;;;;;;;;;;;;;;;;;;MLFLoop ;				beq NoBlock				;branch if zero 8 lines left				cmp #4					;see if more than 4 lines				bcc LoopSkip2			;branch if 4 or less LF's				pha								PushLong #MultiLFC		;do multiple line feeds (4 of them)				jsr writestr								pla				sec				sbc #4					;inc. lines left by 4				bra MLFLoopLoopSkip2	;				taxLoopSkip		phx				jsr		SendRCLF 		Skip no of times 8 lines				plx				dex				bne		LoopSkipNoBlock 		pla				and		#$0007				beq		EndSkip				asl		a				jsr		LittleSkip		;skip no. of single lines leftEndSkip 		rts	Export	MultiLFCMultiLFC	DC.B	8,$1B,$54,$39,$36	; set to 96/144th inch distance			DC.B	$0D,$0A				; CRLF			DC.B	$1B,$41				; reset to 24/144th			;MultiLFC	DC.B	$02,$1f,$34 ;Mulitple line feeds (4);------------------------------------------------------------------------------; PURPOSE:		Skips bottom lines for special.;------------------------------------------------------------------------------SkipBSpe	;				lda		DrvrRect+4				and		#$000f				bne		OkModS				lda		#$0010OkModS			clc				adc		FlagB				tax;------------------------------------------------------------------------------; PURPOSE:		Skip number of lines as specified in (X-reg.). (Special);------------------------------------------------------------------------------SkipXSpe	;				phx				txa				lsr		a				lsr		a				lsr		a				lsr		a				beq		NoBlockS 		Nb block of 8 lines to skip				taxLoopSkipS		phx				jsr		SendRCLF 		Skip X time 8 lines				plx				dex				bne		LoopSkipSNoBlockS		pla				and		#$000f				beq		EndSkipS 		;branch if no single lines left				jsr		LittleSkip		;skip single lines that are leftEndSkipS		rts				EJECT;------------------------------------------------------------------------------;; NAME: 		MakeBuff;; PURPOSE:		Makes the actual print buffers which are to be printed;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------MakeBuff	;				phb						;Activate local Data Bank register				phk				plb				jsr		DefIoHandle				stz		WasImage 		;clear image flags				stz		WasImage1				stz		WasImage2;-----------------------------------------------------------------------------;; This clears the buffers with zeros;;-----------------------------------------------------------------------------				ldy #$27fe				;assume color				bit Quality				;see if color				bmi NotSpClr 			;branch if color				ldy #$500				;its black and white				bit Vsizing				bmi IsSpClr				;branch if not special				bit SpeDens				bpl NotSpClrIsSpClr ;				ldy #$a00NotSpClr	;				lda FlagBlack				beq LoopMakeP			;branch if buffer already clearBWClean ;				lda #$0				stz FlagBlack			;flag as clear;;This does the clearing of the actual print buffer;clean			sta [PtrYellow],y				dey				dey				bpl clean;;Each pass thru is for a print line;;NOTE: There are two phases.  The first phase is scan time for all white and;		the second phase is imaging (if scan time found something to image.)LoopMakeP	;				stz		ImageTime		;init. to scan time				lda		ContLine 		;save line were on				sta		ContSave				lda		DrvrBitMap+2 	;save pointer to bitmap				sta		BMSave				lda		DrvrBitMap+4				sta		BMSave+2LoopMake		jsr		MakeLine				lda		WasImage 		;see if an image was found				beq		Cont1			;branch if still scanning				lda		ImageTime				bne		Cont1			;branch if already imaging time;We arrive here when we make the transition to imaging timeTrans2Im	;				lda		ContSave 		;get save line				sta		ContLine 		;reset to start				lda		BMSave				sta		DrvrBitMap+2				lda		BMSave+2				sta		DrvrBitMap+4				stz		CurrentLine		;reset current line in buffer				inc		ImageTime		;set to scan time				bra		LoopMake 		;start over imagingCont1	;				bit		Vsizing				bmi		DoSpeBuff				bit		SpeDens			;branch if special density				bpl		NoSpeBuff		;branch if normal;We get here if its specialDoSpeBuff	;;				lda		WasImage;				ora		WasImage1		;or in flag;				sta		WasImage1;				lda		WasImage2		;get second flag;				sta		WasImage				inc		Contline				jsr		IncCurrentline				jsr		DefIOHSpe				jsr		MakeLine				lda		WasImage 		;see if an image was found				beq		Cont2			;branch if still scanning				lda		ImageTime				beq		Trans2Im 		;branch if found dataCont2	;;				lda		WasImage;				ora		WasImage2		;or in flag;				sta		WasImage2		;save flag;				lda		WasImage1		;restore first flag;				sta		WasImage				jsr		DefIOHandleNoSpeBuff		inc		ContLine				lda		ContLine				cmp		DrvrRect+4		;Bottom of printed rect				beq		NoSpeBuff21				jsr		IncCurrentLine				bcc		LoopMake 	  ;add blank lines				plb						;Dessactivate local Data Bank register				clc						;Not End of File				rtsContSave		DS.B	  2 				;place to save ContLineImageTime		DS.B	  2 				;0=Scanning, not zero=ImagingBMSave			DS.B	  4 				;Bitmap save area;------------------------------------------------------------------------------;; NAME: 		LoopMakeBlank;; PURPOSE:		Makes a blank line;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------LoopMakeBlank  jsr		MakeBlankLine				bit		Vsizing				bmi		DoSpeBuff2				bit		SpeDens				bpl		NoSpeBuff2DoSpeBuff2	;				inc		Contline				jsr		IncCurrentline				jsr		DefIOHSpe				jsr		MakeBlankLine				jsr		DefIOHandleNoSpeBuff2		inc		ContLineNoSpeBuff21		jsr		IncCurrentLine				bcc		LoopMakeBlank				plb						; Dessactivate local Data Bank register				rts;------------------------------------------------------------------------------;; NAME: 		DefIoHandle;; PURPOSE:		Dereferences the IoHandle and calculates the address' for the;				different color buffers.;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	DefIoHandle DefIoHandle	 	ldy		#2				lda		[<HandleIo]				sta		PtrYellow		;Set as start of Yellow buffer				lda		[<HandleIo],y				sta		PtrYellow+2				sta		PtrRed+2				sta		PtrBlack+2				sta		PtrBlue+2SpeIObis		lda		PtrYellow				clc				adc		#$a00			;add $a00 to arrive at PtrRed				sta		PtrRed				bcc		NoCarryR				inc		PtrRed+2NoCarryR		lda		PtrYellow				clc				adc		#$1400			;add $1400 to arrive at PtrBlue				sta		PtrBlue				bcc		NoCarryB				inc		PtrBlue+2NoCarryB		lda		PtrYellow				clc				adc		#$1e00			;add $1e00 to arrive at PtrBlack				sta		PtrBlack				bcc		NoCarryN				inc		PtrBlack+2NoCarryN		rts;------------------------------------------------------------------------------;; NAME: 		DefIoHSpe;; PURPOSE:		Dereferences the Io handle and calculates the address' for the;				different color buffers. (Special H.);; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	DefIoHSpe	DefIoHSpe		ldy		#2				lda		[<HandleIo]				sta		PtrYellow				lda		[<HandleIo],y				sta		PtrYellow+2				sta		PtrRed+2				sta		PtrBlack+2				sta		PtrBlue+2				lda		PtrYellow				clc				adc		#$500				sta		PtrYellow				bcc		SpeIObis 				inc		PtrYellow+2				bra		SpeIObis;------------------------------------------------------------------------------;; NAME: 		IncCurrentLine;; PURPOSE:		Increments the current line;; PASSED:		NONE;; RETURNED:	 Carry bit;;------------------------------------------------------------------------------IncCurrentline	;				inc		CurrentLine		;inc. current line in print buffer				lda		CurrentLine				cmp		CurrentDef		;compare with lines per print buffer				bcc		IncOut				stz		CurrentLine		;reset current line in print bufferIncOut			rts	ENDPDataBitMap		PROC	EXPORT				Export	CurrentLineCurrentLine 	DC.W	0	;The current line				Export	CurrentDefCurrentDef		DC.W	0				Export	ContLineContLine		DC.W	0				Export	BackBack			DC.W	0				Export	FlagTFlagT			DC.W	0	;Flag of Top				Export	FlagBFlagB			DC.W	0	;Flag of Bottom				Export	CurrentPointCurrentPoint	DC.W	0	;The current Point*										Nb of pixel per line				Export	DrvrBitMapDrvrBitMap		DS.B	16				Export	DrvrRectDrvrRect		DS.B	8				Export	HightLandHightLand		DC.W	0				Export	LandStockLandStock		DC.W	0				DC.W	0				Export	SpeDensSpeDens 		DC.W	0				Export	VsizingVsizing 		DC.W	0				ENDP; LLD.Backgrnd;------------------------------------------------------------------------------;; Primative routines to assist in talking to the port driver;;------------------------------------------------------------------------------******************************							** The Low-Level Driver		**							** Current Rev: Nov. 1987	**							******************************BackGround		PROC	EXPORT;------------------------------------------------------------------------------;; NAME: 		WriteStr (Short Subroutine);; PURPOSE:		To write a string of text to the printer. (calls PrDevWrite;				which will actually send each character to the port.);; PASSED:		LONG 							POINTER, to string to be printed;; RETURNED:	 (NONE);;------------------------------------------------------------------------------				EXPORT	WriteStr	WriteStr		plx				stx		<PtrColor		;save return addressNoBack9 		pla						;get pointer				sta <PtrLocal			;save pointer to string at PtrLocal				clc				adc #01					;to point to first byte of actual text				sta S_Buffer 			;for PrDevWrite				pla						;get rest of pointer				adc #00				sta <PtrLocal+2				sta S_Buffer+2			;for PrDevWrite;Now get strings length byte				lda [PtrLocal]			;get number of bytes in string				and #$00ff				;only want 8-bit no. of bytes				sta S_Length				Jsr PrDevWrite			;call to do the actual transfer								ldx		<PtrColor		;restore return address				phx								cmp #1				rts;------------------------------------------------------------------------------;------------------------------------------------------------------------------;; NAME: 		WriteTxt;; PURPOSE:		To write a buffer of text;; PASSED:		LONG 					POINTER, to text;				WORD 					Offset from start of text (0 if none);				WORD 					Number of character to print;; RETURNED:	 (None);;------------------------------------------------------------------------------				EXPORT	WriteTxt	WriteTxt		plx				stx		<PtrColor		;save return addr.NoBack8 		plx						;get length				stx s_Length				pla						;get offset				clc				adc 1,s					;add offset to start of text addr.				sta s_Buffer 			;for PrDevWrite				pla						;get first part of addr. off				pla						;get second part of addr. off				adc #0				sta s_Buffer+2				Jsr PrDevWrite			;output it				ldx		<PtrColor				phx						;restore return addr.								cmp #1				rts				;------------------------------------------------------------------------------;; NAME: 		PrDevWrite;; PURPOSE:		To write a string of text to the printer.;; PASSED:		WORD 					Length of string;				LONG 					POINTER, to string;				LONG 					POINTER, to completion routine;; RETURNED:	 (NONE);;------------------------------------------------------------------------------				EXPORT	PrDevWrite	PrDevWrite		;;This is the loop which will send each character to the port driver;;; Suki Lee  July 11, 1988; This loop was rewritten to be more efficient on code space;;				tool _GetTick,out=(>TmpTime:l)	**PROFILELoop	;				ldx #$00F0				; assume a full buffer for now				lda s_Length			; get current strings length				bne @1									brl done 				; branch if nothing left in the buffer@1				cmp #$00F0 				; see if more than $f0 characters				bge FullBuff	 				ldx s_Length			; if not, send all that's leftFullBuff		stx WriteLength				PushPtr CompleteWrite				PushLong s_buffer		;strings pointer addr.				Pushword WriteLength				_PrDevWrite				bcc AllsWell				LoopWait						jsr GetStatus				lda PStatus				bne LoopWait								AllsWell		lda s_Length 			; adjust buffer length by the amount				sec						; we just sent				sbc WriteLength				sta s_Length				lda s_buffer 			; increment buffer pointer accordingly 				clc										adc WriteLength				sta s_buffer				bcs @1				brl Loop@1				inc s_buffer+2			;if to next bank, inc. bank				brl LoopDone			;				tool _GetTick,out=(>EndTime:l)		**PROFILE;				sublong >EndTime,>TmpTime,>TmpTime;				addlong >TmpTime,>PortTime,>PortTime								lda #0					; all's coolErrorExit		cmp #1				rts;--------------------------------------------------------------;; Completion routine for PAPWrite which	does nothing since we won't; return from port driver till the write is done.;CompleteWrite	rtl												Export s_Lengths_Length		DS.B 2						;temporary for strings length				Export s_Buffers_Buffer		DS.B 4						;temporary pointer to strings textWriteError		DS.B 2WriteLength		DS.B 2				ENDP; LLD.Color******************************							** CiDrvr: Printer Driver IW **	Color Drvr				**							** Current Rev: Nov. 1987	**							******************************;------------------------------------------------------------------------------;; NAME: 		SetColor;; PURPOSE:		Copies to the location specified by the pointer, the color;				palette table which is specified by the passed SCB byte.;				(Called by LLDSetColor);; PASSED:		LONG 					Pointer to color palette;				WORD 					SCB (which defines palette table);				WORD 					User ID;; RETURNED:	 NONE;;------------------------------------------------------------------------------ColorDrvr		PROC	EXPORT				EXPORT	SetColor	SetColor* Stack: 1: rts*		 3: Direct page*		 5: rtls*		 11: ID*		 13: Color palette*		 15: Ptr to color palette				jsr		DerefColor		;dereference color table				lda		13,s 			;get SCB value				and		#$000F			;look only at color table bits				xba						;times $20 to correct palette table				lsr		a				lsr		a				lsr		a				clc				adc		<PtrColor		;add to start of table				sta		<PtrColor				lda		<PtrColor+2				adc		#0				sta		<PtrColor+2				lda		17,s				pha				lda		17,s				pha				PushLong <PtrColor				PushLong #$20			;$20 bytes (16 palettes * 2 bytes per)				_BlockMove				;move the color palettes to <PtrColor				PushLong <HandleColor	;unlock the handle				_HUnLock				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		SetColorT;; PURPOSE:		Copies the users specified color table to the systems.;				(Called by LLDSetTColor);; PASSED:		(See stack definition below);; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	SetColorT	SetColorT* Stack: 1: rts*		 3: Direct page*		 5: rtls*		 11: ID*		 13: Ptr to color palette				jsr		DerefColor		;deref. color tables to <PtrColor				lda		15,s 			;get users Color palette table ptr.				pha				lda		15,s				pha				PushLong <PtrColor				PushLong #$200				_BlockMove				;copy in the user color table				PushLong <HandleColor				_HUnLock 				;unlock the color handle				rts;------------------------------------------------------------------------------;; NAME: 		GetColorT;; PURPOSE:		Copies the system color table to the users specified address.;				(Called by LLDGetTColor);; PASSED:		(See stack definition below);; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	GetColorT	GetColorT* Stack: 1: rts*		 3: Direct page*		 5: rtls*		 11: ID*		 13: Ptr to color palette				jsr		DerefColor		;deref. systems color table to <PtrColor				PushLong <PtrColor		;system color table ptr.				lda		19,s 			;users color table ptr				pha				lda		19,s				pha				PushLong #$200			;16 tables times $20 bytes				_BlockMove				PushLong <HandleColor				_HUnLock 				;Unlock the color table handle				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		DerefColor;; PURPOSE:		Locks the systems color table handle and dereferences it to;				<PtrColor.;; PASSED:		NONE;; RETURNED:	 NONE;; NOTE: <HandleColor must contain the handle to the system color table.;;------------------------------------------------------------------------------				EXPORT	DerefColor	DerefColor				PushLong <HandleColor				_HLock					;lock the system color table handle				ldy		#2				;deref. to <PtrColor				lda		[<HandleColor]				sta		<PtrColor				lda		[<HandleColor],y				sta		<PtrColor+2				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		Pattern;; PURPOSE:		Builds the actual color print patterns;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	Pattern 	Pattern				jsr		derefColor		;dereference <HandleColor to <PtrColor				lda		[<PtrBitMap] 	;get palette table no.				and		#$000F			Color Table				asl		a				*2				asl		a				*4				asl		a				*8				asl		a				*16				asl		a				*32				clc				adc		<PtrColor		;add to start of palette table				sta		<PtrColor		Pointer to current palette				lda		#0				adc		<PtrColor+2				sta		<PtrColor+2		; now Points to current palette				phb						;Activate current Data Bank register				phk				plb				ldy		#$000FMainloop		phy				lda		[<PtrBitMap] 	;get the  for this line				and		#$000F			;look only at Color Table value				asl		a				;times 2 (word entries in color table)				tax				tya				cmp		<BackColor,x 	;see if				bne		GoCalc				stz		YellowPrt		;init. all color pointers to zero				stz		RedPrt				stz		BluePrt				stz		BlackPrt				bra		EndCalcGoCalc			jsr		Encode			Code Color AlgorithmEndCalc 		ply				phy				jsr		MakePattern		Make a pattern				ply				dey				bpl		Mainloop				plb						;Deactivate current data bank register				PushLong <HandleColor				_HUnLock 				;unlock the color handle				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		Encode;; PURPOSE:		Color translation algorithm;; PASSED:		(Y-reg.) 				= Current Color Index (byte index);; RETURNED:	 NONE;;------------------------------------------------------------------------------*										Current Data Bank Register is on*										Y= Current ColorEncode	;				tya				asl		a				;convert to word index				tay				lda		[<PtrColor],y	;Get color palette value;Now cut the palette value into 3 basic colors				sta		Stock1			;save color palette value for now;Get BLUE component				and		#$000F			Blue vector				sta		BlueScr			;save blue componenet in "BlueScr";Get GREEN component				lda		Stock1				lsr		a				lsr		a				lsr		a				lsr		a				sta		Stock1				and		#$000F			Green vector				sta		GreenScr 		;save green componenet in "GreenScr";Now get RED componenet				lda		Stock1				and		#$00F0				lsr		a				lsr		a				lsr		a				lsr		a				sta		RedScr			;save red componenet** Intermediate step (find minimum of RGB)** RGB=Min (I,J,K)				lda		GreenScr				cmp		BlueScr				bcc		Jump1			Green < Blue				lda		BlueScr				cmp		RedScr				bcc		PutRGB			Blue < Red, GreenJump2			lda		RedScr				bra		PutRGB			Red < Blue, GreenJump1			cmp		RedScr				bcs		jump2			Red < Green, Blue*										Green < Blue, Green;We now know which is the minimum valuePutRGB			sta		RGB				;save minimum in "RGB";Now subtract the minimum from each of the color componenets and save at temps.				sec				lda		GreenScr				sbc		RGB				sta		TempGreen		;green temp.				lda		BlueScr				sbc		RGB				sta		TempBlue 		;blue temp.				lda		RedScr				sbc		RGB				sta		TempRed			;red temp.;;Now see if Green was the minimum value;*										Calc BG, RG, BR				lda		TempGreen				bne		jump3			;branch if not minimum*										BG and RG = 0				sta		RG				;RG (Red Green) is zero				sta		BG				;BG (Blue Green) is zero;;Now see which of the temps is smallest				lda		TempBlue				cmp		TempRed				bcc		PutBR			TempBlue < TempRed				lda		TempRed			TempRed  < TempBluePutBR			sta		BR				bra		Jump4;;Now see if RED was the minimum color;Jump3			lda		TempRed				bne		jump5			BG and BR = 0*										BR and RG = 0				sta		RG				sta		BR				lda		TempBlue				cmp		TempGreen				bcc		PutBG			TempBlue < TempGreen				lda		TempGreen		TempGreen< TempBluePutBG			sta		BG				bra		Jump4;;Then it must of been BLUE that was the minimum valueJump5			lda		#0				sta		BG				;Blue Green=0				sta		BR				;Blue Red = 0				lda		TempRed				cmp		TempGreen				bcc		PutRG			TempRed  < TempGreen				lda		TempGreen		TempGreen< TempRedPutRG			sta		RG*										Calc R, B, GJump4			lda		RedScr				sec				sbc		RG				sbc		BR				sbc		RGB				sta		R				;RED				lda		GreenScr				sec				sbc		BG				sbc		RG				sbc		RGB				sta		G				;GREEN				lda		BlueScr				sec				sbc		BG				sbc		BR				sbc		RGB				sta		B				;BLUE** Perform Matrix multiplication to convert RGB to CMY*				lda		#0				sta		Cont1				sta		Cont3loop4			sta		Cont2				lda		#$3cloop2			ldx		Cont1				ldy		Matrix,x				beq		nul				ldx		Cont2loop3			sec				sbc		RGB,x				dey				bne		loop3nul 			inc		Cont1				inc		Cont1				inc		Cont2				inc		Cont2				ldx		Cont2				cpx		#14				bne		loop2				ldy		Cont3				lsr		a				lsr		a				sta		YellowPrt,y				lda		#0				inc		Cont3				inc		Cont3				ldy		Cont3				cpy		#6				bne		loop4				lda		YellowPrt				clc				adc		RedPrt				adc		BluePrt				PushWord #0				;Quotient area				PushWord #0				;Remainder area				pha						;Numerator				PushWord #3				;Denominator				_UDivide				pla						;Quotient				sta		BlackPrt 		;black				pla						;Remainder (not used)				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		MakePattern;; PURPOSE:		Makes the print dot pattern for one given quality/color.;; PASSED:		(Y-reg.) 				Current color index (byte index);; RETURNED:	 NONE;;------------------------------------------------------------------------------MakePattern ;				tya						;get color index				asl		a				;times 2				asl		a				;times 4				asl		a				;times 8				pha				;-----------------------------------------------------------;; Quality values: 0 = 320 normal (better color);                 1 = 640 normal (better color);                 2 = 320 high res (better text);                 3 = 640 high res (better text);				lda		<Quality 		;get quality				and		#$0003			;(look at Highres/HighColor,640/320)				beq		quality0 		;branch if 320 normal				cmp		#1				;see if 640 normal				bne		l0				brl		quality1 		;branch for 640 normall0				cmp		#3				bne		quality2 		;branch if 320 highres				brl		quality3 		;branch if 640 highresQuality2	;						Quality 2 (320 highres)				bit		<quality				bpl		BW2				;branch if black and white;Do YELLOW level				lda		YellowPrt		Yellow pattern				asl		a				asl		a				asl		a				asl		a				and		#$0080				xba				ply				sta		FinalPat,y;Do RED level				lda		RedPrt			Red pattern				asl		a				asl		a				asl		a				asl		a				and		#$0080				xba				sta		FinalPat+2,y;Do BLUE level				lda		BluePrt			Blue pattern				asl		a				asl		a				asl		a				asl		a				and		#$0080				xba				sta		FinalPat+4,y				rts;------------------------------------------------------------------------------;; 320 highres Black & White;;------------------------------------------------------------------------------BW2 			lda		BlackPrt				asl a				asl a				asl a				asl a				and #$80				xba				ply				sta		FinalPat,y				rts;------------------------------------------------------------------------------;; 320 Normal;;------------------------------------------------------------------------------Quality0	;				bit		<quality 		;look at color bit				bpl		BW0				;brach if black & white				ply;Yellow Level				lda		YellowPrt		Yellow level				asl		a				tax				lda		Level7,x 		0-6 level				asl		a				tax				lda		Pat32,x			Pattern 3*2				sta		FinalPat,y;Red Level				lda		RedPrt			Red level				asl		a				tax				lda		Level7,x 		0-6 level				asl		a				tax*				lda		Pat32+18,x		Pattern 3*2				lda		Pat32,x		 Pattern 3*2				sta		FinalPat+2,y;Blue Level				lda		BluePrt			Blue level				asl		a				tax				lda		Level7,x 		0-6 level				asl		a				tax*				lda		Pat32+36,x		Pattern 3*2				lda		Pat32,x		 Pattern 3*2				sta		FinalPat+4,y				rts;------------------------------------------------------------------------------;;  320 Normal Black & White;;------------------------------------------------------------------------------Bw0 			lda		BlackPrt				asl		a				tay				lda		Level7,y 		0-6 level				asl		a				tay				lda		Pat32,y			Pattern 3*2				ply				sta		FinalPat,y				rts;------------------------------------------------------------------------------;; 640 Normal;;------------------------------------------------------------------------------Quality1	;				bit		<quality 		;look at color bit				bpl		BW1				;branch if black & white				ply;Yellow level				lda		YellowPrt		Yellow level				asl		a				tax				lda		Level5,x 		0-4 level				asl		a				tax				lda		Pat22,x			Pattern 2*2				sta		FinalPat,y;Red level				lda		RedPrt			Red level				asl		a				tax				lda		Level5,x 		0-4 level				asl		a				tax				lda		Pat22,x			Pattern 2*2				sta		FinalPat+2,y;Blue level				lda		BluePrt			Blue level				asl		a				tax				lda		Level5,x 		0-4 level				asl		a				tax				lda		Pat22,x			Pattern 2*2				sta		FinalPat+4,y				rts;------------------------------------------------------------------------------;; 640 Normal black & white;;------------------------------------------------------------------------------Bw1 			lda		BlackPrt				asl		a				tay				lda		Level5,y 		0-4 level				asl		a				tay				lda		Pat22,y			Pattern 2*2				ply				sta		FinalPat,y				rts;------------------------------------------------------------------------------;; 640 Highres;;------------------------------------------------------------------------------Quality3	;				bit		<quality 		;look at color bit				bpl		BW3				;branch if black & white				ply;Yellow level				lda		YellowPrt		Yellow level				asl		a				tax				lda		Level3,x 		0-2 level				asl		a				tax				lda		Pat12,x			Pattern 1*2				sta		FinalPat,y;Red level				lda		RedPrt			Red level				asl		a				tax				lda		Level3,x 		0-2 level				asl		a				tax				lda		Pat12,x			Pattern 1*2				sta		FinalPat+2,y;Blue level				lda		BluePrt			Blue level				asl		a				tax				lda		Level3,x 		0-2 level				asl		a				tax				lda		Pat12,x			Pattern 1*2				sta		FinalPat+4,y				rts;------------------------------------------------------------------------------;; 640 Highres black & white;;------------------------------------------------------------------------------Bw3 			lda		BlackPrt				asl		a				tay				lda		Level3,y 		0-2 level				asl		a				tay				lda		Pat12,y			Pattern 1*2				ply				sta		FinalPat,y				rts				EJECT;------------------------------------------------------------------------------;; PATTERNS & DATA TABLES;;------------------------------------------------------------------------------Pat32	;	DC.W	$0000	;Yellow level 0	DC.W	$8000	;Yellow level 1	DC.W	$8040	;Yellow level 2	DC.W	$80c0	;Yellow level 3	DC.W	$c060	;Yellow level 4	DC.W	$e0c0	;Yellow level 5	DC.W	$e070	;Yellow level 6	DC.W	$f070	;Yellow level 7	DC.W	$f0f0	;Yellow level 8*				dc		i'$0000' 		;Red level 0		One kind of pattern*				dc		i'$4000' 		;Red level 1		to have good*				dc		i'$4020' 		;Red level 2		grey level*				dc		i'$4060' 		;Red level 3*				dc		i'$6030' 		;Red level 4*				dc		i'$7060' 		;Red level 5*				dc		i'$70b0' 		;Red level 6*				dc		i'$f0b0' 		;Red level 7*				dc		i'$f0f0' 		;Red level 8*				dc		i'$0000' 		;Blue level 0*				dc		i'$1000' 		;Blue level 1*				dc		i'$2010' 		;Blue level 2*				dc		i'$2030' 		;Blue level 3*				dc		i'$3090' 		;Blue level 4*				dc		i'$30b0' 		;Blue level 5*				dc		i'$b0d0' 		;Blue level 6*				dc		i'$f0d0' 		;Blue level 7*				dc		i'$f0f0' 		;Blue level 8	Export	Pat22Pat22			DC.W	$0000	Yellow level 0				DC.W	$8000	Yellow level 1				DC.W	$9040	Yellow level 2				DC.W	$e080	Yellow level 3				DC.W	$f0c0	Yellow level 4*				dc		i'$0000' 		Red level 0*				dc		i'$4000' 		Red level 1*				dc		i'$6080' 		Red level 2*				dc		i'$d040' 		Red level 3*				dc		i'$f0c0' 		Red level 4*				dc		i'$0000' 		Blue level 0*				dc		i'$8000' 		Blue level 1*				dc		i'$9040' 		Blue level 2*				dc		i'$e080' 		Blue level 3*				dc		i'$f0c0' 		Blue level 4				Export	Pat12Pat12			DC.W	$0000	Yellow level 0				DC.W	$8000	Yellow level 1				DC.W	$C000	Yellow level 2*				dc		i'$0000' 		Red level 0*				dc		i'$4000' 		Red level 1*				dc		i'$C000' 		Red level 2*				dc		i'$0000' 		Blue level 0*				dc		i'$8000' 		Blue level 1*				dc		i'$C000' 		Blue level 2				Export	Level7Level7			DC.W	0,0,1,1,2,3,3,4,4,5,6,6,7,7,8,8				Export	Level3Level3			DC.W	0,0,0,0,0,1,1,1,1,1,2,2,2,2,2,2				Export	Level5Level5			DC.W	0,0,0,1,1,1,2,2,2,3,3,3,3,4,4,4				Export	MatrixMatrix			DC.W	4,0,4,3,4,0,4				DC.W	4,4,2,1,4,0,0				DC.W	4,4,2,4,0,4,4GreenScr		brk		00				;Screen green (K)BlueScr 		brk		00				;Screen blue  (J)RedScr			brk		00				;Screen red	(I)RGB 			brk		00RG				brk		00BR				brk		00BG				brk		00R				brk		00G				brk		00B				brk		00YellowPrt		brk		00				;Printer Yellow (y)BluePrt 		brk		00				;Printer Blue	(b)RedPrt			brk		00				;Printer Red	(r)BlackPrt		brk		00TempBlue		brk		00				;Also Color0  (It's the last oneTempRed 		brk		00				;then no conflit with Temp...)TempGreen		brk		00Stock1			brk		00Cont1			brk		00Cont2			brk		00Cont3			brk		00Cont			brk		00	ENDP				EXPORT	FinalPat	FinalPat		PROC				ds.b	8						;Color0				ds.b	8						;Color1				ds.b	8						;Color2				ds.b	8						;Color3				ds.b	8						;Color4				ds.b	8						;Color5				ds.b	8						;Color6				ds.b	8						;Color7				ds.b	8						;Color8				ds.b	8						;Color9				ds.b	8						;Color10				ds.b	8						;Color11				ds.b	8						;Color12				ds.b	8						;Color13				ds.b	8						;Color14				ds.b	8						;Color15				ENDP; LLD.Point******************************							** CiDrvr: Printer Driver IW **	bitmapDrvr				**							** Current Rev: Nov. 1987	**							******************************PrintPoint		PROC	EXPORT;------------------------------------------------------------------------------;; NAME: 		MakeBlankLine;; PURPOSE:		To make a blank line;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------* Line Making process. Time is critical				EXPORT	MakeBlankLineMakeBlankLine	stz		BlankFlag				bra		commonMakeLineBlankFlag		DS.B 2						;0= blank, $ffff=not blank;------------------------------------------------------------------------------;; NAME: 		MakeLine;; PURPOSE:		Makes one print line;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------*  Real line making. Time is critical				EXPORT	MakeLine	MakeLine		lda		#$FFFF				sta		BlankFlag		;set flag indicating not a blank lineCommonMakeLine	;				lda		DrvrRect+2		Current Left picture size				sta		CurrentPoint 	;init current point to left side				ora		<PageRectPtr				beq		NoBlank				stz		BlankFlagNoBlank 		lda		DrvrBitMap+2 	;Take BitMap address				sta		<PtrBitMap				lda		DrvrBitMap+4				sta		<PtrBitMap+2				lda		<Quality 		;see if portrait or landscape				and		#$4000				beq		Portrait 		;branch if portrait				brl		Landscape		;it must be landscape;------------------------------------------------------------------------------;; PORTRAIT MODE;;------------------------------------------------------------------------------Portrait	;						Make all real points until the end of				PushLong #0								PushWord ContLine				PushWord DrvrBitMap+6				_Multiply				;Current line * bytes/line (RIGHT)				pla				clc				adc		<PtrBitMap		;add to start of bit map to get location				sta		<PtrBitMap				pla				adc		<PtrBitMap+2				sta		<PtrBitMap+2				lda		<Quality 		;get quality				and		#$03				beq		Mode380C 		;branch if 320 mode high color				cmp		#2				beq		Mode380W 		;branch if 320 mode high res				brl		Mode640			;else its 640 mode;******************************************************************************;; 320 MODES;;******************************************************************************;; 320 mode (ALL BEST TEXT) (BEST COLOR, 50% red., 50% red. and vert. cond.);Mode380W	;				lda		#PutPoint3				bra		Stuff320;; 320 mode;Mode380C	;				lda <quality 			;look at quality				and #$2000				;look at vertical sizing bit				beq x4					;branch if normal; 320 mode (BEST COLOR, vert. condensed)				lda		#PutPoint2bis		printing Rect				bra		Stuff320; 320 mode (BEST COLOR, normal)X4	;				lda		#PutPoint1Stuff320		sta		Stuff320A+1		;stuff the routines address				sta		Stuff320AO+1 	;stuff the odd address routines				lda		WasImage 		;see if an image already was found				beq		Ck320P			;branch if no image yet				jmp		Not320ClrX		;go image it;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Do a quick empty buffer check;;;;;;;;;Ck320P	;;Now check that there are at least 12 points (any less is not worth doing)				lda		DrvrRect+6		;get right				sec				sbc		DrvrRect+2		;subtract left				cmp		#13				bcs		Q320Clr				jmp		Not320Clr		;jump, not worth doing;Now calculate the right wordQ320Clr ;				lda		DrvrRect+6				dec		a				;because not included				lsr		a				;convert to byte address				dec		a				;back up to at least two full bytes				dec		a				sta		QLeft;Now do partial word compares that are to the left				lda		DrvrRect+2		;get left				lsr		a				tay				bcc		Q320Loop 		;branch if starts out even;The first left pixel is odd				lda		[<PtrBitmap],y				and		#$FF0F				cmp		#$FF0F				bne		Not320Clr		;branch if not clear				iny				iny;This is the main routine which checks for all white (16 bits at a time)Q320Loop	;				lda		[<PtrBitmap],y				cmp		#$ffff				bne		Not320Clr		;branch if not clear				iny				iny				cpy		QLeft				bcc		Q320Loop;Now check for partial words at the far right				lda		Qleft				dec		a				;so we don't miss a byte				asl		a				;convert back to pixel address				tax						;(X-reg. holds pixel address)Ck320R	;				txa				lsr		a				;determine if even or odd pixel				tay						;get byte address				php						;save status of even or odd				lda		[<PtrBitmap],y	;get word with pixel in it				plp				bcs		Qodd;Look at even pixel point				and		#$00f0				cmp		#$00f0				bne		Not320Clr				bra		Next320R;Look at odd pixel pointQodd	;				and		#$000f				cmp		#$000f				bne		Not320Clr		;branch if not whiteNext320R	;				inx				cpx		DrvrRect+6				bne		Ck320R;We arrive here if all the pixel points are WHITE				rts;We arrive here if the buffer isn't clearNot320Clr	;				inc		WasImage 		;turn on image flag				rts;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Not320ClrX	;;;Now setup for the loop (figure out odd or even);				lda		CurrentPoint 	;get current point index				lsr		a				lda		CurrentPoint 	;(need to start with current point)				bcs		XX320O			;branch if starts out odd;This does the even onesXX320E	;				lsr		a				;convert to byte address				tay				lda		[<PtrBitmap],y	;get the byte with pixel in it				and		#$f0				lsr		a				;shift to 6-3;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Stuff320A	;				jsr		PutPoint1		printing Rect				inc		CurrentPoint 	;inc. current point				lda		Currentpoint				cmp		DrvrRect+6		;see if to the far right				beq		XX320Done			  ;loop until far right;This does the odd onesXX320O	;				lsr		a				;convert to byte address				tay				lda		[<PtrBitmap],y	;get the byte with pixel in it				and		#$0f 			;mask to get pixel only				asl		a				asl		a				asl		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Stuff320AO	;				jsr		PutPoint1		printing Rect				inc		CurrentPoint 	;inc. current point				lda		Currentpoint				cmp		DrvrRect+6		;see if to the far right				bne		XX320E			;loop to even oneXX320Done	;				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		PutPoint3;; PURPOSE:		Takes the point and puts down the correct pattern into the buffer;				(for 3 levels) [2 print pixels];; PASSED:		(A-reg.) 				index into finalpat (print patterns);; RETURNED:	 NONE;;------------------------------------------------------------------------------PutPoint3	;				tax						;Color point *8				lda		CurrentPoint 	;get current point				asl		a				;times two (to which word)				clc				adc		<PageRectPtr 	;add to start				tay						;use as an index to data point				bit		<Quality 		;look at color/bw				bpl		Black3			;branch if bw				jsr		InitPattern		;get the print pattern************************************	Begin of 8 bit area for speedy calc				longa	off				sep		#$20				jsr		YRBSingle		;do yellow, red and blue single				iny				jsr		YRBSingle				rep		#$20				rts				longa	on*************************************** End of 8 bit area;;We arrive here if its black and white;Black3	;				jsr		InitPattern		;init. the pattern************************************	Begin of 8 bit area for speedy calc				longa	off				sep		#$20;do a yellowsingle				rol		StockYellow+1				lda		[<PtrYellow],y				ror		a				sta		[<PtrYellow],y;do a yellowsingle				iny				rol		StockYellow+1				lda		[<PtrYellow],y				ror		a				sta		[<PtrYellow],y				rep		#$20				rts				longa	on*************************************** End of 8 bit area;------------------------------------------------------------------------------;; NAME: 		PutPoint4;; PURPOSE:		Takes the point and puts down the correct pattern into the buffer;				(Only one print point per pixel);; PASSED:		(A-reg.) 				index into finalpat;; RETURNED:	 NONE;;------------------------------------------------------------------------------PutPoint4	;				tax						;Color point *8				lda		CurrentPoint				clc				adc		<PageRectPtr				tay				bit		<Quality				bpl		Black4				jsr		InitPattern************************************	Begin of 8 bit area for speedy calc				longa	off				sep		#$20				jsr		YRBSingle		;do yellow, red, and blue				rep		#$20				longa	on*********************************** 	End of 8 bit area				rtsBlack4	;				stz		StockYellow				lda		BlankFlag				beq		zero4				lda		FinalPat,x		;get the print pattern				sta		StockYellowzero4	;************************************	Begin of 8 bit area for speedy calc				longa	off				sep		#$20;do a yellowsingle				rol		StockYellow+1				lda		[<PtrYellow],y				ror		a				sta		[<PtrYellow],y				rep		#$20				rts				longa	on*************************************** End of 8 bit area				EJECT*************************************** NOTE: This code is in an 8-bit area				longa	off;------------------------------------------------------------------------------;; NAME: 		YRBSingle;; PURPOSE:		Rotates in a single YELLOW, RED, and BLUE pattern (1 level);; PASSED:		(Y-reg.) 				print buffer index;; RETURNED:	 NONE;;------------------------------------------------------------------------------YRBSingle	;				rol		StockRed+1		;do RED				lda		[<PtrRed],y				ror		a				sta		[<PtrRed],y				rol		StockBlue+1		;do BLUE				lda		[<PtrBlue],y				ror		a				sta		[<PtrBlue],y;do a yellow single				rol		StockYellow+1				lda		[<PtrYellow],y				ror		a				sta		[<PtrYellow],y				rts				longa	on*************************************** End of 8 bit area;------------------------------------------------------------------------------;; NAME: 		InitPattern;; PURPOSE:		Gets the print pattern for each color (yellow, red, blue);; PASSED:		(X-reg.) 				index into finalpat (print patterns);; RETURNED:	 NONE;;------------------------------------------------------------------------------InitPattern ;				lda		BlankFlag		;see if blank				beq		zeros				lda		FinalPat,x				sta		StockYellow		;set yellow pattern				lda		FinalPat+2,x				sta		StockRed 		;set red pattern				lda		FinalPat+4,x				sta		StockBlue		;set blue pattern				rtszeros	;				stz		StockRed 		;red patterns				stz		StockBlue				stz		StockYellow				rts;------------------------------------------------------------------------------;; NAME: 		PutPoint1;; PURPOSE:		Takes the point and puts down the correct pattern into the buffer;; PASSED:		(A-reg.) 				index into finalpat (print patterns);; RETURNED:	 NONE;;------------------------------------------------------------------------------PutPoint1	;				tax						;Color point *8				lda		CurrentPoint				asl		a				asl		a				clc				adc		<PageRectPtr				tay				bit		<Quality				bpl		Black1			;branch if blank and white				jsr		InitPattern		;init. the print patterns************************************	Begin of 8 bit area for speedy calc				longa	off				sep		#$20				jsr		PutYRB			;do yellow, red, blue bits				iny				jsr		PutYRB				iny				jsr		PutYRB				iny				jsr		PutYRB				rep		#$20				rts				longa	on****************************************** End of 8 bit areaBlack1	;				stz		StockYellow		;init the pattern to zeros				lda		BlankFlag		;see if want blank line				beq		zero1			;branch blank				lda		FinalPat,x		;get pattern				sta		StockYellow		;init. patternzero1	;************************************	Begin of 8 bit area for speedy calc				longa	off				sep		#$20				asl		StockYellow		;do PutYellow				lda		[<PtrYellow],y				ror		a				asl		StockYellow+1				ror		a				sta		[<PtrYellow],y				iny				asl		StockYellow		;do PutYellow				lda		[<PtrYellow],y				ror		a				asl		StockYellow+1				ror		a				sta		[<PtrYellow],y				iny				asl		StockYellow		;do PutYellow				lda		[<PtrYellow],y				ror		a				asl		StockYellow+1				ror		a				sta		[<PtrYellow],y				iny				asl		StockYellow		;do PutYellow				lda		[<PtrYellow],y				ror		a				asl		StockYellow+1				ror		a				sta		[<PtrYellow],y				rep		#$20				rts				longa	on*************************************** End of 8 bit area				EJECT*************************************** NOTE: 8-bit speedy area				longa	off;------------------------------------------------------------------------------;; NAME: 		PutYRB;; PURPOSE:		Rotates in two bits of yellow, red, blue pattern to print buffer;; PASSED:		(Y-reg.) 				print buffer index;; RETURNED:	 NONE;;------------------------------------------------------------------------------PutYRB	;				asl		StockRed 		;do RED bits				lda		[<PtrRed],y				ror		a				asl		StockRed+1				ror		a				sta		[<PtrRed],y				asl		StockBlue		;do BLUE bits				lda		[<PtrBlue],y				ror		a				asl		StockBlue+1				ror		a				sta		[<PtrBlue],y				asl		StockYellow		;do PutYellow				lda		[<PtrYellow],y				ror		a				asl		StockYellow+1				ror		a				sta		[<PtrYellow],y				rts				longa	on*************************************** End of 8 bit area				EJECT;******************************************************************************;; 640 MODES (Portrait);;******************************************************************************Mode640 ;						Mode 640				cmp		#1				beq		Mode640C;; 640 mode (All BEST TEXT) (BEST COLOR, 50% red., 50% red. and vert. cond.);				lda		#PutPoint4				bra		Stuff640R;; 640 mode;Mode640C	;				lda <quality				and #$2000				beq ii2; 640 mode (BEST COLOR, vertical condensed)				lda #PutPoint3				bra Stuff640R;640 mode (BEST COLOR, normal)ii2 ;				lda #PutPoint2;This stuffs the correct routine into the jsrStuff640R	;				sta Stuff640+1				sta Stuff641+1				sta Stuff642+1				sta Stuff643+1				lda		WasImage 		;see if an image already was found				beq		Ck640P			;branch if no image yet				jmp		Not640ClrX		;go image it;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Quick empty buffer checkCk640P	;;First check that there are at least 16 points (any less is not worth checking)				lda DrvrRect+6				sec				sbc DrvrRect+2				cmp #25				bcc NotQuicky2			;just image it;Now do any partial word compares which are to the far right				lda DrvrRect+6				dec a				lsr a				lsr a					;divide by 4 (because 4 pixels/word)				tay				dey						;to get to full word of data				lda [<PtrBitmap],y				sta WhichData			;save the rightmost word				lda DrvrRect+6				dec a				and #$0003				beq QRPixel0 			;branch if pixel zero				cmp #3					;see if full word				beq Quicky				;branch if full word				cmp #1				beq QRPixel1 			;branch if pixel oneQRPixel2	;				lda WhichData				and #$fcff				cmp #$fcff				bne NotQuicky2				bra StartRFullQRPixel1	;				lda WhichData				and #$f0ff				cmp #$f0ff				beq StartRFullNotQuicky2		jmp NotQuickyQRPixel0	;				lda WhichData				and #$c0ff				cmp #$c0ff				bne NotQuicky2StartRFull	;				dey				deyQuicky	;				lda DrvrRect+2				lsr a				lsr a				ina						;inc. in case of partial at far left				sta QLeft				;set left point;This is the main routine which checks for all white (16 bits at a time)QuickyL ;				lda [<PtrBitmap],y				cmp #$ffff				bne NotQuicky				dey				dey				bmi QLDone				cpy QLeft				bcs QuickyLQlDone	;;Now check for any partial words at the far left				ldy QLeft;Double check word to the right to be sure its white				lda [<PtrBitmap],y				cmp #$ffff				bne NotQuicky;Now check the last byte (or partial byte) for all white				dey				lda DrvrRect+2				and #$0003				beq QLPixel0				cmp #1				beq QLPixel1				cmp #2				beq QLPixel2QLPixel3	;				lda [<PtrBitmap],y				and #$ff03				cmp #$ff03				bne NotQuicky				rts						;Was all whiteQLPixel0	;				lda [<PtrBitmap],y				cmp #$ffff				bne NotQuicky				rts						;Was all whiteQLPixel1	;				lda [<PtrBitmap],y				and #$ff3f				cmp #$ff3f				bne NotQuicky				rts						;Was all whiteQLPixel2	;				lda [<PtrBitmap],y				and #$ff0f				cmp #$ff0f				bne NotQuicky				rts						;Was all whiteNotQuicky	;				inc		WasImage 		;indicate there was an image				rts				EXPORT	WasImage	WasImage		DS.B 2				EXPORT	WasImage1	WasImage1		DS.B 2				EXPORT	WasImage2	WasImage2		DS.B 2				Export	QLeftQleft			DS.B 2				Export	QCountQcount			DS.B 2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Not640ClrX	;				lda		CurrentPoint				lsr		a				lsr		a				sta		WhichPtY				lda		[<PtrBitMap],y				sta		WhichData				lda		CurrentPoint				and		#3				beq		GetPt640X		;=0				cpx		#1				beq		GetPt641 		;=1				cpx		#2				beq		GetPt642 		;=2				bra		GetPt643 		;=3GetPt640	;				inc		WhichPtYGetPt640X	;				ldy		WhichPtY				lda		[<PtrBitMap],y				sta		WhichData				and		#$C0				lsr		a				lsr		a				lsr		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Stuff640		jsr		PutPoint2		;put the pattern into the buffer				inc		CurrentPoint				lda		CurrentPoint				cmp		DrvrRect+6				beq		GetPtDoneGetPt641	;				lda		WhichData				and		#$30				ora		#$40 			For chip graphic column=1 mod(4)				lsr		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Stuff641		jsr		PutPoint2		put the pattern into the buffer				inc		CurrentPoint				lda		CurrentPoint				cmp		DrvrRect+6				beq		GetPtDoneGetPt642	;				lda		WhichData				and		#$0C				ora		#$20 			For chip graphic column=2 mod(4)				asl		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Stuff642		jsr		PutPoint2		put the pattern into the buffer				inc		CurrentPoint				lda		CurrentPoint				cmp		DrvrRect+6				beq		GetPtDoneGetPt643	;				lda		WhichData				and		#$03				ora		#$0C 			For chip graphic column=3 mod(4)				asl		a				asl		a				asl		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Stuff643		jsr		PutPoint2		printing Rect				inc		CurrentPoint				lda		CurrentPoint				cmp		DrvrRect+6				bne		GetPt640GetPtDone	;				rts				Export	WhichPtYWhichPtY		DC.W	0	;holds index into <PtrBitMap				Export	WhichDataWhichData		DC.W	0	;the actual data point				EJECT;------------------------------------------------------------------------------;; NAME: 		PutPoint2;; PURPOSE:		Takes the point and lays down the color print patterns;; PASSED:		(A-reg.) 				index into finalpat (print patterns);; RETURNED:	 NONE;;------------------------------------------------------------------------------PutPoint2	;						In A: Color*8				tax						;Current color pattern				lda		CurrentPoint				asl		a				clc				adc		<PageRectPtr				tay				bit		<Quality				bpl		Black2				jsr		InitPattern************************************	Begin of 8 bit area for speedy calc				longa	off				sep		#$20				jsr		PutYRB			;do yellow, red, and blue				iny				jsr		PutYRB			;do yellow, red, and blue				rep		#$20				rts				longa	on*************************************** End of 8 bit areaBlack2	;				stz		StockYellow				lda		BlankFlag				beq		zero2				lda		FinalPat,x				sta		StockYellowzero2	;************************************	Begin of 8 bit area for speedy calc				longa	off				lda		[<PtrYellow],y				sep		#$20				asl		StockYellow		;do PutYellow				ror		a				asl		StockYellow+1				ror		a				xba				asl		StockYellow		;do PutYellow				ror		a				asl		StockYellow+1				ror		a				rep		#$20				xba				sta		[<PtrYellow],y				rts				longa	on*************************************** End of 8 bit area				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		PutPoint2bis;; PURPOSE:		Takes the point and lays down the color print patterns;; PASSED:		(A-reg.) 				index into finalpat (print patterns);; RETURNED:	 NONE;;------------------------------------------------------------------------------PutPoint2bis	;						In A: Color*8				tax						;Current color pattern				lda		CurrentPoint 	;calculate address of point				asl		a				asl		a				clc				adc		<PageRectPtr				tay				bit		<Quality				bpl		Black2bis				jsr		InitPattern************************************	Begin of 8 bit area for speedy calc				longa	off				sep		#$20				jsr		YRBSingle		;do yellow, red, and blue single				iny				jsr		YRBSingle		;do yellow, red, and blue single				iny				jsr		YRBSingle		;do yellow, red, and blue single				iny				jsr		YRBSingle		;do yellow, red, and blue single				rep		#$20				rts				longa	on*************************************** End of 8 bit area;; Black and white;Black2bis	;				stz		StockYellow				lda		BlankFlag				beq		zero2b			;branch if want blank line				lda		FinalPat,x				sta		StockYellow		;set the print patternzero2b	;************************************	Begin of 8 bit area for speedy calc				longa	off				sep		#$20				rol		StockYellow+1	;do a yellow single				lda		[<PtrYellow],y				ror		a				sta		[<PtrYellow],y				iny				rol		StockYellow+1	;do a yellow single				lda		[<PtrYellow],y				ror		a				sta		[<PtrYellow],y				iny				rol		StockYellow+1	;do a yellow single				lda		[<PtrYellow],y				ror		a				sta		[<PtrYellow],y				iny				rol		StockYellow+1	;do a yellow single				lda		[<PtrYellow],y				ror		a				sta		[<PtrYellow],y				rep		#$20				rts				longa	on*************************************** End of 8 bit area				rts				EJECT;------------------------------------------------------------------------------;; LANDSCAPE Mode;;------------------------------------------------------------------------------LandScape	;				lda		<Quality				and		#$0001				beq		its320			;branch if 320 landscape mode				brl		Land640			;branch if 640 landscape mode;******************************************************************************;; 320 mode (Landscape);;******************************************************************************its320	;				PushLong #0				PushWord DrvrBitMap+6				PushWord HightLand				_Multiply				pla				sta		OffSetLand				pla						;Nothing				lda		ContLine 		;OffSet= Width*HightLand + ContLine/2				lsr		a				;for mode 320				clc				adc		OffSetland				sta		OffSetland				lda		<Quality 		;look at quality				and		#$0003				beq		LoopLandC		;branch if color;; 320 landscape mode;LoopLandW	;				lda <quality				and #$2000				beq x6; 320 mode landscape (BEST COLOR 50% and vert. cond., BEST TEXT vert. cond.,; BEST TEXT vert. and 50% reduction)x5	;				lda		#PutPoint4				bra		LStuff320A; 320 mode landscape (BEST COLOR 50% red., BEST TEXT normal, BEST TEXT 50% red.)x6	;				lda		#PutPoint3				bra		LStuff320A;; 320 mode landscape;LoopLandC	;				lda <quality				and #$2000				beq x8; 320 mode landscape (BEST COLOR vertical condensed)x7	;				lda		#PutPoint2				bra		LStuff320A; 320 mode landscape (BEST COLOR normal)x8	;				lda		#PutPoint1;We now stuff the correct subroutines addressLStuff320A	;				sta		LAddr3201+1				sta		LAddr3202+1				lda		WasImage 		;see if an image already was found				beq		Ck320L			;branch if no image yet				jmp		Not320XX 		;go image it;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Do a quick check for empty buffer;;;;;;;;;;;;;;Ck320L	;				lda		OffSetLand				sta		Qleft				lda		CurrentPoint				sta		QCount;Now determine if on an odd or even line				Lda		ContLine 		;get current line				lsr		a				bcs		Ql3Odd			;branch if odd;EVEN lineQL3Even ;				lda		Qleft				sec				sbc		DrvrBitMap+6 	;subtract right				sta		Qleft				tay				lda		[<PtrBitmap],y				and		#$00f0				cmp		#$00f0				bne		L320Image		;branch if an image				inc		QCount				lda		Qcount				cmp		DrvrRect+6				bne		QL3Even			;loop until done;We arrive here if theres no image to print				rts;Its an ODD lineQl3Odd	;				lda		Qleft				sec				sbc		DrvrBitMap+6 	;subtract right				sta		Qleft				tay				lda		[<PtrBitmap],y				and		#$000f				cmp		#$000f				bne		L320Image		;branch if an image				inc		QCount				lda		Qcount				cmp		DrvrRect+6				bne		QL3Odd			;loop until done;We arrive here if theres no image to print				rtsL320Image	;;We arrive here if the buffer has an image				inc		WasImage 		;set flag to indicate an image present				rts;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Not320XX	;;Now determine if on an odd or even line				Lda		ContLine 		;get current line				lsr		a				bcs		LLoop8Odd		;branch if odd;;EVEN address;LLoop8	;				lda		OffSetLand				sec				sbc		DrvrBitMap+6				sta		OffSetLand				tay				lda		[<PtrBitmap],y				and		#$00f0				lsr		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;LAddr3201	;				jsr		PutPoint1				inc		CurrentPoint				lda		Currentpoint				cmp		DrvrRect+6				bne		LLoop8				rts;;ODD address;LLoop8Odd	;				lda		OffSetLand				sec				sbc		DrvrBitMap+6				sta		OffSetLand				tay				lda		[<PtrBitmap],y				and		#$000f				asl		a				asl		a				asl		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;LAddr3202	;				jsr		PutPoint1				inc		CurrentPoint				lda		Currentpoint				cmp		DrvrRect+6				bne		LLoop8OddLLoopDone	;				rts;******************************************************************************;; Landscape 640 mode;;******************************************************************************Land640 ;				PushLong #0				PushWord DrvrBitMap+6				PushWord HightLand				_Multiply				;multiply RIGHT times height of bank				pla				sta		OffSetLand		;result				pla						;Nothing				lda		ContLine 		;OffSet= Width*HightLand + ContLine/2				lsr		a				;for mode 320				lsr		a				clc				adc		OffSetland				sta		OffSetland				lda		<Quality 		;look at quality				and		#$0002			;branch if BEST COLOR, normal or				beq		LoopL640C		;vertical condensed.;; 640 mode landscape;LoopL640W	;				lda <quality				and #$2000				;look at vert. condensed bit				beq i6					;branch if not vert. condensed; 640 mode landscape (BEST COLOR 50% and vert. cond., BEST TEXT vert. cond.,; BEST TEXT vert. and 50% reduction)i5	;				lda		#PutPoint4		;get address of correct subroutine				bra		LStuff640; 640 mode landscape (BEST COLOR 50% red., BEST TEXT normal, BEST TEXT 50% red.)i6	;				lda		#PutPoint3		;get address of correct subroutine				bra		LStuff640;; 640 mode landscape;LoopL640C	;				lda <quality				and #$2000				;look at vert. condensed bit				beq i4					;branch if not condensed; 640 mode landscape (BEST COLOR vertical condensed)i3	;				lda		#PutPoint3				bra		LStuff640; 640 mode landscape (BEST COLOR normal)i4	;				lda		#PutPoint2bisLStuff640	;				sta		LAStuff60+1				sta		LAStuff61+1				sta		LAStuff62+1				sta		LAStuff63+1				lda		WasImage 		;see if an image already was found				beq		Ck640L			;branch if no image yet				jmp		Not640XX 		;go image it;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Do a quick check for empty buffer;;;;;;;;;;;;;;Ck640L	;				lda		OffSetLand				sta		Qleft				lda		CurrentPoint				sta		QCount;Now determine which line we are on and vector to the correct routine				Lda		ContLine 		;get current line				and		#3				beq		QL6Zero				cmp		#1				beq		QL6One				cmp		#2				beq		QL6Two;Line (3)QL6Three	;				lda		Qleft				sec				sbc		DrvrBitMap+6 	;subtract right				sta		Qleft				tay				lda		[<PtrBitmap],y				and		#$0003				cmp		#$0003				bne		L640Image		;branch if an image				inc		QCount				lda		Qcount				cmp		DrvrRect+6				bne		QL6Three 		;loop until done;We arrive here if theres no image to print				bra		QNoImage;Line (2)QL6Two	;				lda		Qleft				sec				sbc		DrvrBitMap+6 	;subtract right				sta		Qleft				tay				lda		[<PtrBitmap],y				and		#$000c				cmp		#$000c				bne		L640Image		;branch if an image				inc		QCount				lda		Qcount				cmp		DrvrRect+6				bne		QL6Two			;loop until done;We arrive here if theres no image to printQNoImage	;				rts;Line (1)QL6One	;				lda		Qleft				sec				sbc		DrvrBitMap+6 	;subtract right				sta		Qleft				tay				lda		[<PtrBitmap],y				and		#$0030				cmp		#$0030				bne		L640Image		;branch if an image				inc		QCount				lda		Qcount				cmp		DrvrRect+6				bne		QL6One			;loop until done;We arrive here if theres no image to print				bra		QNoImage;Line (0)QL6Zero ;				lda		Qleft				sec				sbc		DrvrBitMap+6 	;subtract right				sta		Qleft				tay				lda		[<PtrBitmap],y				and		#$00c0				cmp		#$00c0				bne		L640Image		;branch if an image				inc		QCount				lda		Qcount				cmp		DrvrRect+6				bne		QL6Zero			;loop until done;We arrive here if theres no image to print				bra		QNoImageL640Image	;;We arrive here if the buffer has an image				inc		WasImage 		;set flag to indicate an image present				rts;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;Not640XX	;;;Now determine which line we are on and vector to the correct routine;				Lda		ContLine 		;get current line				and		#3				beq		IL6Zero				cmp		#1				beq		IL6One				cmp		#2				beq		IL6TwoIL6Three	;				lda		OffSetLand				sec				sbc		DrvrBitMap+6				sta		OffSetLand				tay						;use as index				lda		[<PtrBitmap],y				and		#$0003			;and out unwanted pixels				ora		#$000C			;or in correct palette base				asl		a				asl		a				asl		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;LAStuff63	;				jsr		PutPoint2bis				inc		CurrentPoint				lda		Currentpoint				cmp		DrvrRect+6				bne		IL6Three				rtsIL6Two	;				lda		OffSetLand				sec				sbc		DrvrBitMap+6				sta		OffSetLand				tay						;use as index				lda		[<PtrBitmap],y				and		#$000c				ora		#$0020			;or in correct pallete base				asl		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;LAStuff62	;				jsr		PutPoint2bis				inc		CurrentPoint				lda		Currentpoint				cmp		DrvrRect+6				bne		IL6Two				rtsIL6One	;				lda		OffSetLand				sec				sbc		DrvrBitMap+6				sta		OffSetLand				tay						;use as index				lda		[<PtrBitmap],y				and		#$0030				ora		#$0040			;or in correct pallete base				lsr		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;LAStuff61	;				jsr		PutPoint2bis				inc		CurrentPoint				lda		Currentpoint				cmp		DrvrRect+6				bne		IL6One				rtsIL6Zero ;				lda		OffSetLand				sec				sbc		DrvrBitMap+6				sta		OffSetLand				tay						;use as index				lda		[<PtrBitmap],y				and		#$00c0				lsr		a				lsr		a				lsr		a;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;NOTE: The address portion of the following jsr instruction is stuffed.;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;LAStuff60	;				jsr		PutPoint2bis				inc		CurrentPoint				lda		Currentpoint				cmp		DrvrRect+6				bne		IL6Zero				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		PointL320;; PURPOSE:		Gets a landscape 320 mode pixel data point;; PASSED:		NONE;; RETURNED:	 (A-reg.) 				Current pixel point in bit loc. 14-11;										(index into finalpat {print patterns});;------------------------------------------------------------------------------PointL320	;				ldy		OffSetLand				lda		[PtrBitmap],y				tax				Lda		ContLine 		;get current line				and		#$0001				bne		LEven				txa				and		#$00F0				lsr		a				rtsLEven			txa				and		#$000F				asl		a				asl		a				asl		a				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		PointL640;; PURPOSE:		Gets a landscape 640 mode pixel data point;; PASSED:		NONE;; RETURNED:	 (A-reg.) 				Current pixel point in bit loc. 14-11;										(index into finalpat {print patterns});;------------------------------------------------------------------------------PointL640	;				lda		ContLine				and		#$0003				tax				ldy		OffSetLand				lda		[PtrBitmap],y;Now figure out which pixel it is (remember 640 mode has 4 pixels / byte)CutQuart		cpx		#0				beq		Q0				Quarter 0 or 1				cpx		#1				beq		Q1								cpx		#2				beq		Q2;For pixel 3				and		#$03				ora		#$0C 			;for correct color table base				asl		a				asl		a				asl		a				rts;For pixel 1Q1				and		#$30				ora		#$40 			;for correct color table base				lsr		a				rts;For pixel 0Q0	;				and		#$C0				lsr		a				lsr		a				lsr		a				rts;For pixel 1Q2				and		#$0C				ora		#$20 			;for correct color table base				asl		a				rts;------------------------------------------------------------------------------;; Variables;;------------------------------------------------------------------------------				Export	OffSetLandOffSetLand		DC.W	0	;offset (landscape use)				Export	StockYellowStockYellow 	DC.W	0	;current print pattern for yellow				Export	StockRedStockRed		DC.W	0	;current print pattern for red				Export	StockBlueStockBlue		DC.W	0	;current print pattern for blue				ENDP; LLD.Port******************************							** CiDrvr: Printer Driver IW **	  SSCDrvr				**							** Current Rev: Nov. 1987	**							******************************SendChar		PROC	EXPORT	goto .skipssc;------------------------------------------------------------------------------;; NAME: 		InitSSC;; PURPOSE:		Initializes "Super Serial Card";; PASSED:		WORD 					Request Command;										 =0, same init. (do nothing);										 =1, open port only;										 =2, open port and reset printer;										 =3, resets printer only;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	InitSSC 	InitSSC 		pha				ldy		#GraphP				lda		MyWap,y			;get last init. entry				beq		Reinit			;branch if it's first time through(=0)				cmp		1,s				beq		EndInit			Same initialization				tax						;save previous in x-reg.				lda		1,s				No more init				cmp		#3				beq		EndInit			;branch if request=3				cpx		#3				beq		NoNeeded 		;branch if previous request=3;We arrive here if we need to open the portReInit	;				PushLong #0				PushLong #0				_PrDevOpen				;open the portNoNeeded		ldy		#GraphP				lda		1,s				;get the request				sta		MyWap,y			;save it for next time				cmp		#1				bne		EndInit			;branch if request=1				Entry ResetPrinterCodes				PushLong #resetPrinterCodes				jsr WriteStr 			;reset printer to its defaultsEndInit 		pla				rtsResetPrinterCodes	DC.B	2				DC.B	27,99			;reset printer to its internal defaults*InitGraph		dc		i1'16'*				dc		i1'09,67,68'	 disable line length*				dc		i1'09,84'		 disable basic tab*				dc		i1'09,70,68'	 disable keyboard input*				dc		i1'09,77,68'	 disable filtering LF*				dc		i1'09,76,68'	 disable LF after CF*				dc		i1'09,90'		 Final zap.skipssc				EJECT;------------------------------------------------------------------------------;; NAME: 		GoStatus;; PURPOSE:		Goes and Gets the status;; PASSED:		NONE;; RETURNED:	 (A-reg.) 				Status;;------------------------------------------------------------------------------				EXPORT	GoStatus	GoStatus		sep		#$30 			;0				longa	off				longi	off				phb						;2				lda		#0				;3				pha						;5				plb						;6				lda		$C110			;7				sta		<Status+4		;10 (NOTE: Stuffs the addr. in hook proc)				lda		#$1				;12 (Request code=1 (have input ready?)				ldy		#$10 			;14				ldx		#$c1 			;16				jsl		>0				;18(NOTE: addr. is stuffed by MakeStatus)				plb				rep		#$30				longa	on				longi	on				and		#1				rts;------------------------------------------------------------------------------;; NAME: 		MakeStatus;; PURPOSE:		Stuffs the addr. of the routine that gets the status into;				the routine "GoStatus".;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	MakeStatus	MakeStatus		phb				phk				plb				pha				tdc				clc				adc		#<Status 		;add the actual calling addr.				sta		GoStatus+19		;stuff the address of the routine				pla				plb				rts				EJECT;------------------------------------------------------------------------------;------------------------------------------------------------------------------;; Hook Procedures (Gets copied to zero page "<GO" where it is executed);; Switches to emulation mode and calls the SSC;------------------------------------------------------------------------------;------------------------------------------------------------------------------				longi	off				longa	off;NOTE: This routine is copied into zero page at "<Go"				EXPORT	HookProc	 Hook to SSCHookProc		sec					 ;0	put into emulation mode				xce					 ;1				phd					 ;2	save D-reg.				jsr		$C100		 ;3	Jump into SSC				pld					 ;6	restore D-reg.				clc					 ;7				xce					 ;8	back to 65816 mode				rtl					 ;9	Return;NOTE: This routine is copied into zero page at "<Status";This routine gets the status and puts into the A-reg.				sec					 ;10				xce					 ;11  put into emulation mode				phd					 ;12  save d-reg.				jsr		$C100		 ;13  jump SSC (NOTE: this addr. is stuffed)				php					 ;16  save the status bits				pla					 ;17  return with A-reg. = status bits				pld					 ;18  restore d-reg.				clc					 ;19				xce					 ;20  back to 65816 mode				rtl					 ;21				longi	on				longa	on				ENDP				EJECTSendToIM2		PROC	EXPORT;-----------------------------------------------------------;; This routine no longer used.  Commented out by Harry and; Steve on 10 Feb 88;				GOTO .skipprintcheck;------------------------------------------------------------------------------;; NAME: 		PrintCheck;; PURPOSE:		Get printers characteristics and set bits accordingly in 'PID';; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	PrintCheck	PrintCheck		phb				phk				plb;First init. printer				lda		#3				Needed just init SSC				jsr		InitSSC				jsr		MakeStatus				lda		#0				sta		LengthStr		;init string length				PushLong #P_SelfId		;ask for ImageWriter ID				jsr WriteStr*				jsr 	WaitStr 		 Wait the anwser				lda		LengthStr		ImageWriter 2 send at least 5 chars				cmp		#$5				bcc		rate				lda		Version			First and second char must be IW				cmp		#$5749				bne		rate;Now get the version number from the printer				ldy		#PID				sta		MyWap,y		 then 3rd and 4th is version				lda		Version+2				iny				iny				sta		MyWap,y				iny				iny				lda		#$0				Init attribut				sta		MyWap,y;Now scan looking for other features until terminating character				ldx		#3LoopC			lda		Version+1,x				and		#$00FF				cmp		#$0d 			End of the string				beq		EndC;Now check for color ribbon				cmp		#$43 			C for color rubbon				bne		NoColorC				lda		MyWap,y				ora		#$8000				sta		MyWap,y			;or in color ribbon bit				bra		NoFeeder;Now check for sheet feederNoColorC		cmp		#$46 			F for sheed feeder				bne		NoFeeder				lda		MyWap,y				ora		#$4000			;or in sheet feeder bit				sta		MyWap,yNoFeeder		inx						;go to next char.				cpx		LengthStr		;see if at end of string				bne		loopCRate	;EndC			plb				rts;------------------------------------------------------------------------------;; NAME: 		WaitStr;; PURPOSE:		Gets the printers ID string from the printer;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------WaitStr ;				lda		#$40				sta		count			;set repeat counterLoopWait	;				tsc				sta		<SaveStack2		;save the stack pointer				and		#$00FF				ora		#$0100				tcs				jsr		GoStatus 		;get printers status				bne		ReadChar				lda		<SaveStack2				tcs						;restore the stack pointer				dec		count			;dec. the counter				bne		loopwait 		;loop				rts;------------------------------------------------------------------------------; We arrive here when we have received a character from the printer.;; This recieves the charater and builds the ID string.;------------------------------------------------------------------------------ReadChar	;				lda		<SaveStack2				tcs						;restore the stack				PushWord #0				PushWord #0				_ReadChar				;read the character from the printer				pla				ldx		LengthStr		;get the current string byte pointer				sep		#$20				sta		Version,x		;store the byte in the string				rep		#$20				inc		LengthStr		;inc. to the next byte locaton				cpx		#15				;if 15 chars., done				bne		WaitStr				rts				Export	LengthStrLengthStr		DC.W	0	;length of string				EXPORT	VersionVersion 		DS.B	  16				;Imagewriters self ID bytes				Export	CountCount			DC.W	0	;counter				Export	P_SelfIdP_SelfId		DC.B	2	;Command to ask for printers self ID				DC.B	$1b,$3F								.skipprintcheck												;------------------------------------------------------------------------------;; NAME: 		SendRC;; PURPOSE:		Sends an appropriate carriage return or line feed when needed;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	SendRC		SendRC			ldy		#PenPosVW				lda		MyWap,y			;get current vertical pos.				clc				adc		#$10 			;add 16				sta		MyWap,y				cmp		<PageRect+4		;see if below page rect.				bcc		OkSendRC 		;branch if below				brl		FormFeed 		;if equal or above, just do form feedOkSendRC		PushLong #RCLF			;send carriage return and line feed				jsr WriteStr				rts;------------------------------------------------------------------------------;; NAME: 		ResetPrinter;; PURPOSE:		To reset the printer to its internal defaults and skip to start;				of page.;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	ResetPrinterResetPrinter	PushLong #RPrinter		;send reset printer command				jsr WriteStr				ldx		<PageRect		;get page rect top				jsr		SkipLigne		;skip that many lines								rts;-------------------------------------------------------------------------------;; Removed the code to set character to 10 cpi Pica. Elite, which is the default,; is faster.				Export	RPrinterRPrinter		DC.B	2					DC.B	27,99			;reset printer to defaults;------------------------------------------------------------------------------;; NAME: 		SendRCLF;; PURPOSE:		Sends carriage return/line feed until bottom of page rect..	When;				the bottom of page rect. is reached, a form feed is sent;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	SendRCLF	SendRCLF		ldy		#PenPosVW		;get the vertical pos.				lda		MyWap,y				clc				adc		#$10 			;add 16				sta		MyWap,y				cmp		<PageRect+4		;see if at bottom of page rect.				bcc		OkRC 			;if not at bottom or below then branch				brl		FormFeedPrg		;else just do form feedOkRC			PushLong #RCLF			;send a carriage return line feed				jsr WriteStr				rts				Export	RCLFRCLF			DC.B	2				DC.B	$0d,$0a ;carriage return, line feed chars.				;------------------------------------------------------------------------------;; NAME: 		MovePen;; PURPOSE:		Moves the pen to the horz. and vertical location specified.;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	MovePen 	MovePen 		sec				ldy		#PenPosVW				lda		MyWap,y			;get current vertical position				sbc		NewPenPosV		;sub. new vert. position				blt		okPenPos 		;branch if less than				beq		FinPenPos		;branch if already there;We arrive here if we are below vertical position we want to be at				pha						;push vert. difference				PushLong #ReverseFeed	;set to reverse line feeds				jsr WriteStr				plx				jsr		SkipLigne		;line feed back that many lines				PushLong #NormalFeed				jsr WriteStr 			;put back to normal line feed				bra		FinPenPos;We arrive here if we need to move down the pageOkPenPos	;				lda		NewPenPosV				sec				sbc		MyWap,y			;calc. no. of lines to skip down				tax				jsr		SkipLigne		;skip correct lines down pageFinPenPos	;				lda		NewPenPosV				ldy		#PenPosVW				sta		MyWap,y			;update vert. positon to new position				lda		NewPenPosH		;get horz. position				pha				PushLong #Hmove+3				PushWord #4				PushWord #0				_int2dec 				;convert to 4 decimal digits				lda Hmove+3				ora #$1010				sta Hmove+3				;convert to ASCII				lda Hmove+5				ora #$1010				;convert to ASCII				sta Hmove+5				PushLong #Hmove				jsr writeStr 			;move the print head to horz. position				rts				Export	ReverseFeedReverseFeed 	DC.B	2				DC.B	27,114			;line feeds go up the page				Export	NormalFeedNormalFeed		DC.B	2				DC.B	27,102			;line feeds go down the page				EJECT								;------------------------------------------------------------------------------;; NAME: 		SkipLigne;; PURPOSE:		To skip lines down the page;; PASSED:		(X-reg.) 				No. of lines to skip;; RETURNED:	 NONE;;------------------------------------------------------------------------------SkipLigne	;				phx						;save lines to skip				txa;;;;;;;;;;;;;;;;;;;;SPEED enhancement;;;;;;;;;;;;;;;;;;;;L99Loop ;				cmp #99					;see if more than or equal to 99 lines				blt Not99				;branch if less then 99				PushLong #h99line		;set line height to 99 lines and LF				jsr writestr				pla						;get lines to skip				sec				sbc #99					;subtract 99 lines				pha						;save it				bra L99loopNot99	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;				lsr		a				;div. by 16 (see how many 16 lines)				lsr		a				lsr		a				lsr		a				beq		NoBlock			;branch if not at least one 16 lines				pha				PushLong #heightline16		;set line height to 16 lines				jsr writestr				plx;This loop does line feeds (16 lines at a time)LoopASkip		phx				PushLong #RCLF			;do a Carriage return/line feed				jsr WriteStr				plx				dex						;dec. 16 line counter				bne		loopASkipNoBlock 		pla				and		#$000F			;now look only at lines less than 16				beq		EndSkip			;branch if no residual lines to do				tax;This loop does line feeds of only one line				phx				pushlong #HeightLine01				jsr WriteStr				plxLoopLSkip		phx				PushLong #SkipLine		;set line heigth to one and LF				jsr WriteStr				plx				dex						;dec. single line counter				bne		LoopLSkip								pushlong #HeightLine16				jsr WriteStrEndSkip 		rts;------------------------------------------------------------------------------;; NAME: 		LittleSkip;; PURPOSE:		Skips the number of lines as specified in the A-register.;				(skips only one line at a time);; PASSED:		(A-reg.);; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	LittleSkip	LittleSkip		taxLoopSkip		phxSuiteSkip		ldy		#PenPosVW				lda		MyWap,y			;get current vert. postion				clc				adc		#$1				sta		MyWap,y			;inc. and update				cmp		<PageRect+4		;see if at bottom				bcc		OkSkip			;branch if above bottom				jsr		FormFeedPrg		;do a form feed				bra		SuiteSkipOkSkip	;				pushlong #HeightLine01				jsr WriteStr				PushLong #SkipLine				jsr		WriteStr 		;skip a line				plx				dex				bne		LoopSkip 		;loop until at line or hit bottom				rts								;------------------------------------------------------------------------------;; NAME: 		FormFeedPrg;; PURPOSE:		To move to top of page;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	FormFeedPrg FormFeedPrg	 	PushLong #P_Feed 		;set for positive line feeds				jsr		WriteStr				lda		#0				ldy		#PenPosVW		;get vert. pos.				sta		MyWap,y			;init. to zero				lda		<PageRect		;get page top				lsr		a				;only half that				tax				jsr		SkipXLine		;skip that many lines				rts;------------------------------------------------------------------------------;; NAME: 		FormFeed;; PURPOSE:		Form feed to the top of the page rect.;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	FormFeed	FormFeed		PushLong #P_Feed 		;set for positive line feeds				jsr WriteStr				lda		#0				ldy		#PenPosVW				sta		MyWap,y			;init. vert. pen pos. to zero				ldx		<PageRect		;skip to the top of page rect.				jsr		SkipLigne				rts;------------------------------------------------------------------------------;; NAME: 		TextShoot;; PURPOSE:		To transfer text to the printer;; PASSED:		LONG 					Pointer to the text;				WORD 					Length of the text (in bytes);				WORD 					USERID;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	TextShoot	TextShoot* Stack: 1: rts*		 3: Direct page*		 5: Rtls*		 11: ID*		 13: length*		 15: Ptr Text				lda		17,s 			;get pointer to string				pha				lda		17,s				pha				PushWord #$0 			;Use no offset into text				lda		19,s 			;get length				pha				jsr		WriteTxt 		;write the text to the printer				rts;------------------------------------------------------------------------------;; NAME: 		SendSingleCar;; PURPOSE:		To send a single character to the printer;; PASSED:		(A-reg.) 				character to print (high byte);; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	SendSingleCarSendSingleCar	sta		SingleCar		;stuff the character				PushPtr SingleCar		;pointer to the text				PushWord #$0 			;no offset				PushWord #$1 			;Length is one				jsr		WriteTxt 		;write the character				rts				Export	SingleCarSingleCar		DC.B	'  '	;char. to print;------------------------------------------------------------------------------;; NAME: 		SendBPrep;; PURPOSE:		Prepares the printer before SendBuff loop;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	SendBPrep	SendBPrep		lda		<Quality				and		#$3				tax				lda		DrvrRect+6				jsr		CalcPoPiSuite2	;				clc				adc		<PageRectPtr				cmp		#$500				blt		oklong				lda		#$500okLong	;				sta		LongBuff				pha				PushLong #Graphic+3				PushWord #4				PushWord #0				_Int2Dec				lda		Graphic+3		To convert space ($20) into Zero ($30)				ora		#$1010			All other digits are between $30 and				sta		Graphic+3		$39				lda		Graphic+5				ora		#$1010				sta		Graphic+5;			*** MSL (what's wrong with bidirectional?);				PushLong #P_LeftRight	;Set for UniDirectional printing only;				jsr		WriteStr				PushLong #P_EliteProp	160 pixels per inch				jsr		WriteStr				PushLong #HeightLine16		;set line feed height to 16 lines				jsr		WriteStr				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		SendBuff;; PURPOSE:		Prints the buffers for the different colors from one band;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	SendBuff	SendBuff		bit		Vsizing				bpl		testmore				brl		SpeLandtestmore	;								bit		SpeDens				bpl		Normal				brl		SpeLand;;Normal density (no interlacing);Normal	;;First check to see if there was any image at all to print				lda		WasImage 		;see if there was an image				ora		WasImage1				ora		WasImage2				bne		GoNormalP		;branch if image				rts						;else no image to printGoNormalP	;				lda		#1				sta		FlagBlack		;flag to clear buffers next time				bit		<Quality				bmi		SendColor		;branch if color				brl		SendBW			;branch if BW;We arrive here if its colorSendColor	;				ldy		LongBuff 		Init Color Flag. Before printing				stz		FlagBlack		if flag=0 must not print this color				stz		FlagRed				stz		FlagYellow				stz		FlagBlue				jsr		MakeBlack		Calc black buff				lda		FlagYellow		If no Yellow we not print in yellow				beq		NoYellow				jsr		SendYellow				PushLong #RC 			Send a RC but no LF				jsr		WriteStr								lda	<DarkerMode				beq NoYellow;		*** Second pass for darker				jsr	SendYellow								PushLong #RC 			Send a RC but no LF				jsr		WriteStrNoYellow		lda		FlagRed			Check if red characters				beq		NoRed				jsr		SendRed				PushLong #RC 			Send a RC but no LF				jsr		WriteStr				lda	<DarkerMode				beq NoRed;		*** Second pass for darker				jsr	SendRed						PushLong #RC 			Send a RC but no LF				jsr		WriteStrNoRed			lda		FlagBlue 		Check if Blue characters				beq		NoBlue				jsr		SendBlue				PushLong #RC 			Send a RC but no LF				jsr		WriteStr				lda	<DarkerMode				beq NoBlue;		*** Second pass for darker				jsr	SendBlue							PushLong #RC 			Send a RC but no LF				jsr		WriteStrNoBlue			lda		FlagBlack		Check if Black characters				beq		NoBlack				jsr		SendBlack				PushLong #RC 			Send a RC but no LF				jsr		WriteStr								lda	<DarkerMode				beq NoBlack;		*** Second pass for darker				jsr	SendBlack				PushLong #RC 			Send a RC but no LF				jsr		WriteStrNoBlack 		bit quality				bpl noBlackstr3				PushLong #P_Black		Send Print in Black to IW2				jsr		WriteStrnoBlackstr3 ;				rts;-----------------------------------------------------------------------------; This checks for an blank line (no data) and sets flagblack);-----------------------------------------------------------------------------SendBW	;;				ldy 	LongBuff;loopBW 		lda 	[<PtrYellow],y	 ;look at buffer;				bne 	SBWxx			 ;branch if data;				dey;				dey;				bpl 	loopBW;				lda 	#0				 ;if we get here, it was blank;SBWxx			anop;				sta 	FlagBlack;				lda 	FlagBlack;				beq 	NoBW			 ;branch if nothing to print				bit quality				bpl noBlackstr2				PushLong #P_Black		Send Print in Black to IW2				jsr		WriteStrnoBlackstr2 ;				PushLong #Graphic		;put into graphics mode				jsr		WriteStr				PushLong <PtrYellow		Send Black Buffer				PushWord #0				PushWord LongBuff				jsr	  WriteTxt					PushLong #RC 			Send a RC but no LF				jsr		WriteStr				lda	<DarkerMode				beq NoBW				;		*** Second pass for darker				PushLong #Graphic		;put into graphics mode				jsr		WriteStr				PushLong <PtrYellow		Send Black Buffer				PushWord #0				PushWord LongBuff				jsr	  WriteTxt					PushLong #RC 			Send a RC but no LF				jsr		WriteStrNoBW			rts				Export	EndLBuffEndLBuff		DC.W	0;------------------------------------------------------------------------------;; Special Modes (Interlaced);;------------------------------------------------------------------------------SpeLand ;;First see if there was an image (do nothing if none)				lda		WasImage 		;see if either interlaced have images				ora		WasImage1				ora		WasImage2				bne		GoSpeImgs		;branch if there was an image				rtsGoSpeImgs	;				lda		#1				sta		FlagBlack		;flag to clear buffers next time				PushLong #P_EliteProp				jsr		WriteStr				bit		<Quality				bpl		SpeBW				brl		SpeColor;;Interlaced black and white;SpeBW	;				bit quality				bpl noBlackstr8				PushLong #P_Black		Send Print in Black to IW2				jsr		WriteStrnoBlackstr8 ;				PushLong #Graphic				jsr		WriteStr				PushLong <PtrYellow		Send Black Buffer				PushWord #0				PushWord LongBuff				jsr	  WriteTxt				lda	<DarkerMode				beq NoDarkerInt1								PushLong #RC 			Send a RC but no LF				jsr		WriteStr								PushLong #Graphic				jsr		WriteStr				PushLong <PtrYellow		Send Black Buffer				PushWord #0				PushWord LongBuff				jsr	  WriteTxtNoDarkerInt1	lda #1				jsr LittleSkip			;skip down one print scan line				jsr DefIOHSpe				bit quality				bpl noBlackstr9				PushLong #P_Black		Send Print in Black to IW2				jsr		WriteStrnoBlackstr9 ;				PushLong #Graphic		;print the second line interlaced				jsr		WriteStr				PushLong <PtrYellow		Send Black Buffer				PushWord #0				PushWord LongBuff				jsr	  WriteTxt				lda	<DarkerMode				beq NoDarkerInt2				PushLong #RC 			Send a RC but no LF				jsr		WriteStr								PushLong #Graphic		;print the second line interlaced				jsr		WriteStr				PushLong <PtrYellow		Send Black Buffer				PushWord #0				PushWord LongBuff				jsr	  WriteTxtNoDarkerInt2	jsr DefIOHandle				jsr RevPaper 			;reverse the paper back up 1 scan line				brl NoBlacks;;We arrive here if its COLOR with 50% reduction or vert. condensed (interlaced);SpeColor	;				ldy		LongBuff 		Init Color Flag. Before printing				stz		FlagBlack		if flag=0 must not print this color				stz		FlagRed				stz		FlagYellow				stz		FlagBlue				jsr		MakeBlack		Calc black buff				jsr		DefIOHSpe				ldy		LongBuff				jsr		MakeBlack				jsr		DefIOHandle				lda		FlagYellow		If no Yellow we not print in yellow				beq		NoYellowS				jsr		SendYellow								lda	<DarkerMode				beq NoDarkerYellow1								jsr		SendYellowNoDarkerYellow1	lda		#1				jsr		LittleSkip				jsr		DefIOHSpe				jsr		SendYellow								lda	<DarkerMode				beq NoDarkerYellow2								jsr		SendYellowNoDarkerYellow2	jsr		DefIOHandle				jsr		RevPaperNoYellowS		lda		FlagRed			Check if red characters				beq		NoRedS				jsr		SendRed				lda	<DarkerMode				beq NoDarkerRed1								jsr		SendRedNoDarkerRed1	lda		#1				jsr		LittleSkip				jsr		DefIOHSpe				jsr		SendRed								lda	<DarkerMode				beq NoDarkerRed2								jsr		SendRedNoDarkerRed2	jsr		DefIOHandle				jsr		RevPaperNoRedS			lda		FlagBlue 		Check if Blue characters				beq		NoBlueS				jsr		SendBlue				lda	<DarkerMode				beq NoDarkerBlue1								jsr		SendBlueNoDarkerBlue1	lda		#1				jsr		LittleSkip				jsr		DefIOHSpe				jsr		SendBlue				lda	<DarkerMode				beq NoDarkerBlue2								jsr		SendBlueNoDarkerBlue2	jsr		DefIOHandle				jsr		RevPaperNoBlueS 		lda		FlagBlack		Check if Black characters				beq		NoBlackS				jsr		SendBlack				lda	<DarkerMode				beq NoDarkerBlack1								jsr		SendBlackNoDarkerBlack1	lda		#1				jsr		LittleSkip				jsr		DefIOHSpe				jsr		SendBlack				lda	<DarkerMode				beq NoDarkerBlack2								jsr		SendBlackNoDarkerBlack2	jsr		DefIOHandle				jsr		RevPaperNoBlackS		bit quality				bpl noBlackstr4				PushLong #P_Black		Send Print in Black to IW2				jsr		WriteStrnoBlackstr4 ;				PushLong #HeightLine16		;set the line feed to 16 print lines				jsr		WriteStr				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		RevPaper;; PURPOSE:		Reverses the paper a half print line;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------RevPaper	;				ldy		#PenPosVW				lda		MyWap,y			;get the vertical pos.				sec				sbc		#1				;dec. it by one				sta		MyWap,y				PushLong #ReverseSpe 	;reverse on half print line				jsr		WriteStr				rts;------------------------------------------------------------------------------;; NAME: 		MakeBlack;; PURPOSE:		Determines the BLACK buffer bit values and sets each of the;				color flags if there is data to be printed for that color.;; PASSED:		(Y)						Index into buffer to start at;; RETURNED:	 NONE;;------------------------------------------------------------------------------				EXPORT	MakeBlack	MakeBlack		phx						;save x-reg.				bra		MakerBlackLoopBlack		lda		[<PtrYellow],y	Calculate black buffer by ANDing  on the				and		[<PtrRed],y		3 color buffers: Red+Yellow+Blue=Black				and		[<PtrBlue],y				sta		[<PtrBlack],y				bne		SomeBlack		;branch if some black bits;We arrive here if there are no black bits				lda		[<PtrYellow],y	;look at the yellow bits				beq		QQNoYellow		;branch if no yellow bits				sta		FlagYellow		;flag that we have some yellowQQNoYellow		lda		[<PtrRed],y		;look at the red bits				beq		QQNoRed			;branch if no red bits				sta		FlagRedQQNoRed 		lda		[<PtrBlue],y 	;look at the blue bits				beq		MakerBlack		;branch if no blue bits				sta		FlagBlue				bra		MakerBlack		;branch for next group of bits;We arrive here if there are some black bitsSomeBlack	;				sta		FlagBlack		set FlagBlack.				tax						;save black bits in x-reg.;										 For the other colors, if one bit is				eor		[<PtrYellow],y	 Black, we must not print this bit in				sta		[<PtrYellow],y	 the other color (EOR out that bit)				beq		QNoYellow		;branch if no yellow bits				sta		FlagYellow		;Set Yellow flagQNoYellow	;				txa						;get black bits				eor		[<PtrRed],y		;EOR out red where there's black				sta		[<PtrRed],y				beq		QNoRed			;branch if no red bits				sta		FlagRed			;Set red flagQNoRed	;				txa						;get black bits				eor		[<PtrBlue],y 	;EOR out blue where there's black				sta		[<PtrBlue],y				beq		MakerBlack		;branch if no blue bits				sta		FlagBlue 		;Set blue flagMakerBlack		dey				dey				bpl		LoopBlack				plx						;restore x-reg.				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		SendYellow;; PURPOSE:		Prints the yellow buffer;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------SendYellow	;				PushLong #P_Yellow		Send Print in Yellow to IW2				jsr		WriteStr				PushLong #Graphic		;Sending graphic chars.				jsr		WriteStr				PushLong <PtrYellow		Send Yellow Buffer				PushWord #0				PushWord LongBuff				jsr		WriteTxt 				rts;------------------------------------------------------------------------------;; NAME: 		SendRed;; PURPOSE:		Prints the red buffer;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------SendRed ;				PushLong #P_Red			Send Print in red to IW2				jsr		WriteStr				PushLong #Graphic		;sending graphics chars.				jsr		WriteStr				PushLong <PtrRed 		Send red Buffer				PushWord #$0				PushWord LongBuff				jsr		WriteTxt 				rts				EJECT;------------------------------------------------------------------------------;; NAME: 		SendBlue;; PURPOSE:		Prints the blue buffer;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------SendBlue	;				PushLong #P_Blue 		Send Print in Blue to IW2				jsr		WriteStr				PushLong #Graphic				jsr		WriteStr				PushLong <PtrBlue		Send Blue Buffer				PushWord #$0				PushWord LongBuff				jsr		WriteTxt 				rts;------------------------------------------------------------------------------;; NAME: 		SendBlack;; PURPOSE:		Sends the Black buffer;; PASSED:		NONE;; RETURNED:	 NONE;;------------------------------------------------------------------------------SendBlack	;				bit quality				bpl noBlackstr				PushLong #P_Black		Send Print in Black to IW2				jsr		WriteStrnoBlackstr	;				PushLong #Graphic				jsr		WriteStr 		;sending graphics chars.				PushLong <PtrBlack		Send Black Buffer				PushWord #$0				PushWord LongBuff				jsr		WriteTxt 				rts				EJECT;Carriage Return				Export	RCRC				DC.B	1				DC.B	$0d;Sending Graphic data				Export	GraphicGraphic 		DC.B	6				DC.B	27,71,00,00,00,00;Move print head to horizontal position specified				Export	HmoveHmove			DC.B	6				DC.B	27,70,00,00,00,00;Set the line feed hight to 1, CR, LF				Export	SkipLine******** MSLSkipLine		DC.B	2,$0d,$0a								export HeightLine01HeightLine01	DC.B	4				DC.B	27,84,$30,$31;Set the heigth of a line feed to 16 print lines				Export	HeightLine16HeightLine16	DC.B	4				DC.B	27,84,$31,$36*********************************************************************** Note from Suki Lee   5/5/1988* The comment here and the usage of this command is incorrect. This * command sets the distance between lines to be 99/144th of an inch,* not 99 lines. The default distance is 24/144th (6 lines per inch),* this command roughly quadruples the line feed distance.*;Set the height of a line feed to 99 print lines (for fast vertical pos.)				Export	H99LineH99Line 		DC.B	6				DC.B	27,84,$39,$39	;set line feed to 99 print lines				DC.B	$0d,$0a ;carriage return, line feed;Reverse up a half a line				Export	ReverseSpeReverseSpe		DC.B	10				DC.B	27,114				;reverse line feed				DC.B	27,84,30,31 		;set line feed to one print line				DC.B	$0d,$0a 			;carriage return, line feed				DC.B	27,102				;forward line feed;Do a form feed				Export	P_FeedP_Feed			DC.B	1				DC.B	12;UniDirectional printing				Export	P_LeftRightP_LeftRight 	DC.B	2				DC.B	27,62;Elite printing (160 dpi)				Export	P_ElitePropP_EliteProp 	DC.B	2				DC.B	27,80;Print in Black				Export	P_BlackP_Black 		DC.B	3				DC.B	27,75,48;Select yellow ribbon				Export	P_YellowP_Yellow		DC.B	3				DC.B	27,75,49;Select red ribbon				Export	P_RedP_Red			DC.B	3				DC.B	27,75,50;Select blue ribbon				Export	P_BlueP_Blue			DC.B	3				DC.B	27,75,51				EXPORT	FlagBlack	FlagBlack		brk		00FlagRed 		brk		00FlagYellow		brk		00FlagBlue		brk		00LongBuff		brk		00				ENDP; LLD.ExitsLldExits		PROC	EXPORT;------------------------------------------------------------------------------;; Low Level EXITS;;------------------------------------------------------------------------------; NOTE: we need to save 2 RTL's;; Take 12 bytes of parameters off the stack;				EXPORT	LldExit12	LldExit12		tax				lda 5,s				sta 17,s				lda 3,s				sta 15,s				lda 1,s				sta 13,s				pla				pla				pla				pla				pla				pla				brl LLDexitX;; Take 10 bytes of parameters off the stack;				EXPORT	LldExit10	LldExit10		tax				lda 5,s				sta 15,s				lda 3,s				sta 13,s				lda 1,s				sta 11,s				pla				pla				pla				pla				pla				brl LLDexitX;; Take 8 bytes of parameters off the stack;				EXPORT	LldExit8	LldExit8	  	tax				lda 5,s				sta 13,s				lda 3,s				sta 11,s				lda 1,s				sta 9,s				pla				pla				pla				pla				brl LLDexitX;; Take 6 bytes of parameters off the stack;				EXPORT	LldExit6	LldExit6	  	tax				lda 5,s				sta 11,s				lda 3,s				sta 9,s				lda 1,s				sta 7,s				pla				pla				pla				brl LLDexitX;; Take 4 bytes of parameters off the stack;				EXPORT	LldExit4	LldExit4	  	tax				lda 5,s				sta 9,s				lda 3,s				sta 7,s				lda 1,s				sta 5,s				pla				pla				brl LLDexitX;; Take 2 bytes of parameters off the stack;				EXPORT	LldExit2	LldExit2	  	tax				lda 5,s				sta 7,s				lda 3,s				sta 5,s				lda 1,s				sta 3,s				plaLLDExitX	;				txa;; Take zero bytes of parameters off the stack;				EXPORT	LLDexit0	LLDexit0		cmp #1				rtl				ENDP;--------------------------------; StrCmp;;	quick'n'dirty pascal string;	comparison... case insensitive,;	assumes alphabetic characters only.;StrCmp			PROC	EXPORT				input s1:l,s2:l				begin				lda #0				; zero out high byte of accumulator				shortm				lda [s2]			; string length.				tayloop			lda [s1],y				cmp #'a'			; is it lowercase (with our limited definition of lowercase)				blt @cont				subword a,#$20,a	; fold it to upper.@cont			cmp [s2],y				bne exit				dey				bpl loopexit			longm				iny				tya				return a				ENDP								