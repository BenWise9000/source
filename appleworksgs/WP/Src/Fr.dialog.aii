	load 'macros.dump'	include 'driver.equ'	include 'wp.equ';-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	D_BlinkButton	IMPORT	W_CalcDocRect	IMPORT	D_CloseDialog	IMPORT	W_CurDoc	IMPORT	X_DialogFromScrap	IMPORT	X_DialogToScrap	IMPORT	W_FindIt	IMPORT	D_GetNewModalDialog	IMPORT	W_InvalScroll	IMPORT	W_ReplaceAll	IMPORT	W_ReplaceFind	IMPORT	W_ReplaceIt	IMPORT	W_StartOver	IMPORT	W_def_replace	IMPORT	W_def_search	IMPORT	W_FindRepDlg	IMPORT	W_Hand	IMPORT	W_ignoreValue	IMPORT	W_Ptr	IMPORT	Q_Rect	IMPORT	W_Selected	IMPORT	W_wholeValue	IMPORT	W_Caret	IMPORT	CaretOff;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	W_DispCharsIn	ENTRY	W_DispCharsOut	ENTRY	W_FindRepFilter	ENTRY	W_FindRepWork	ENTRY	W_FindReplace	ENTRY	W_findactive	ENTRY	W_foundonce	ENTRY	W_hibounds	ENTRY	W_lowbounds	ENTRY	W_replactive	ENTRY	W_visRect*****************************************************************															  ;*		  FR.DIALOG -- drive the Find/Replace dialog		  ;*															  ;*************************************************************************************************************************************	Includes...** Monday, May 1, 1989 1:51:41 AM********************************************************************		****************************************************************W_FindNext	PROC		EXPORT			;Using	W_FRData			;Using	W_FRdlgData		begin	+b		pushlong #W_visRect			; get the docrect		jsl	  W_CalcDocRect		lda	  >W_def_search	 		; anything to find?		and	  #$ff		bne	  nodialog		jsl	  W_FindReplace	 		; if not, bring up the dialog		bra	  byenodialog	jsl	  W_FindIt		  	; if so... well, you know.bye	return		ENDP****************************************************************W_FindReplace	PROC		EXPORT			;Using	W_FRData			;Using	W_FRdlgData			;Using	WPGlobals			;Using	ScreenData		local	dialog:l,theitem:w		local	W_Hand:l,W_Ptr:l,Q_Rect:r		begin	+b								  		; compute the visRect and position		tool _SetPort,in=(W_CurDoc:l)	; the document		lda W_Caret		beq @nocaret		jsl CaretOff@nocaret		pushlong #W_visRect			; get the docrect		jsl	  W_CalcDocRect		pushlong #W_visRect			; globalize it		_LocalToGlobal		pushlong #W_visRect+4		_LocalToGlobal		lda	  W_visRect		 		; too low to use the low bounds?		cmp	  W_lowbounds		bge	  usehigh		movelong W_lowbounds,>W_FindRepDlg		movelong W_lowbounds+4,>W_FindRepDlg+4		moveword W_lowbounds,W_visRect+4		bra	  gotvisusehigh	movelong W_hibounds,>W_FindRepDlg		movelong W_hibounds+4,>W_FindRepDlg+4		moveword W_hibounds,W_visRectgotvis	pushlong #W_visRect		; I've got the W_visRect, now localize		_GlobalToLocal		pushlong #W_visRect+4		_GlobalToLocal		moveword #1,W_replactive   ; force W_Buttons to be turned off		moveword #1,W_findactive		moveword #0,W_foundonce		pushlong #W_def_replace		jsl	  W_DispCharsIn		pushlong #W_def_search		jsl	  W_DispCharsIn		jsl	  X_DialogFromScrap		spacelong		pushlong #W_FindRepDlg		jsl	  D_GetNewModalDialog		pulllong dialogloop	spaceword		pushlong #W_FindRepFilter+$80000000		_ModalDialog		pullword theitem		beq	  loop		cmp	  #$100		   ; is it a button?		blt	  button		cmp	  #$200		   ; is it a LineEdit thing?		blt	  edit		cmp	  #$300		   ; is it a check box?		blt	  checkitedit	brl	  loop			; << nothing here >>checkit	spaceword		pushlong dialog		pushword theitem		_GetDItemValue		pla		eor	  #1		pha		pushlong dialog		pushword theitem		_SetDItemValue		brl	  loopbutton	jsr	  getOptions		lda	  theitem		cmp	  #6			  	; Done?		beq	  done		dec	  a			   		; if not, do some real work		jtl	  W_FindRepWork		brl	  loopdone	pushlong dialog		jsl	  D_CloseDialog		jsl	  X_DialogToScrap		jsl	  W_InvalScroll		return*--------------------------------------------------------------**		   Get the values of the options check boxes		  ;*--------------------------------------------------------------*getOptions	spaceword		spacelong		pushlong dialog		pushword #$202		   ; D_Ignore case		_GetControlDItem		_GetCtlValue		pullword >W_ignoreValue		spaceword		spacelong		pushlong dialog		pushword #$203		   ; Whole word(s)		_GetControlDItem		_GetCtlValue		pullword >W_wholeValue		rts		ENDP******************************************************************   W_FindRepFilter -- does all the special work while the dialog*		is active.  The following W_Key translations are effected.**		W_Key				MEANING*		-----------------------------------------------*		Apple-F/RETURN 	click Find Next*		Apple-R			click Replace*		Apple-T			click Replace, then Find*		Apple-A			click Replace All*		Apple-1			click Go To Beginning*		Apple-D/ESC		click Done*		Apple-I			click D_Ignore Case*		Apple-W			click Whole Word(s)*		Option-TAB	 	Insert TAB in LineEdit record*		Option-return  	Insert return in LineEdit record*****************************************************************W_FindRepFilter	PROC		EXPORT			;Using	W_FRData			;Using	W_FRdlgData			;Using	WPGlobals		input	dlgptr:l,eventptr:l,itemptr:l		output   handled:w		local	thekey:w,themods:w		begin	+b*--------------------------------------------------------------**	  First, check to see which W_Buttons should be active	  ;*--------------------------------------------------------------*		pushlong dlgptr		pushword #$100		   ; W_searchEdit		pushlong #W_def_search	 ; put this here so it sticks arounds		_GetIText		pushlong #W_def_search		jsl	  W_DispCharsOut		pushlong dlgptr		pushword #$101		   ; W_replaceEdit		pushlong #W_def_replace		_GetIText		pushlong #W_def_replace		jsl	  W_DispCharsOut		lda	  >W_def_search	 ; get W_Search string length		and	  #$ff			; low byte		jeq	  nosearch		lda	  W_findactive	  ; was it already active?		jne	  checkreplace		inc	  W_findactive	  ; it is now!		pushword #0			  ; D_Activate the control		spacelong		pushlong dlgptr		pushword #1			  ; find next		_GetControlDItem		_HiliteControl		pushword #0			  ; D_Activate the control		spacelong		pushlong dlgptr		pushword #4			  ; replace all		_GetControlDItem		_HiliteControl		brl	  checkreplace	; check the replace stringnosearch	lda	  W_findactive	  	; was it already inactive?		jeq	  keycheck		stz	  W_findactive	  		; it is now!		pushword #255				; deactivate the control		spacelong		pushlong dlgptr		pushword #1			  		; find next		_GetControlDItem		_HiliteControl		pushword #255				; deactivate the control		spacelong		pushlong dlgptr		pushword #4			  		; replace all		_GetControlDItem		_HiliteControl		brl	  noreplacecheckreplace	lda	  W_Selected		jeq	  noreplace		lda	  W_foundonce		jeq	  noreplace		lda	  W_replactive		jne	  keycheck		inc	  W_replactive		pushword #0			  ; D_Activate the control		spacelong		pushlong dlgptr		pushword #2			 ; replace		_GetControlDItem		_HiliteControl		pushword #0			  ; D_Activate the control		spacelong		pushlong dlgptr		pushword #3			 ; replace, then find		_GetControlDItem		_HiliteControl		brl	  keychecknoreplace	lda	  W_replactive		jeq	  keycheck		stz	  W_replactive		pushword #255			; deactivate the control		spacelong		pushlong dlgptr		pushword #2			  ; replace		_GetControlDItem		_HiliteControl		pushword #255			; deactivate the control		spacelong		pushlong dlgptr		pushword #3			  ; replace, then find		_GetControlDItem		_HiliteControl*--------------------------------------------------------------**				 Now check for W_Key equivalents				;*--------------------------------------------------------------*keycheck	stz	  handled		lda	  [eventptr]	  ; event what		cmp	  #3			  ; W_Key down		beq	  W_Key		cmp	  #5			  ; auto W_Key		beq	  W_Key		brl	  exitW_Key	moveword [eventptr]:#2,thekey   ; event message		cmpw	 theKey,#27	  ; ESC?		bne	  notESC		lda	  #6			  ; Done		ldx	  #1			  ; simple button		jsr	  FakeButton		brl	  exitnotESC	moveword [eventptr]:#$E,themods ; event modifiers		lda	  themods		and	  #$0100		  ; is the apple W_Key down?		jeq	  notapple*--------------------------------------------------------------**				  Check Apple W_Key equivalents				 ;*--------------------------------------------------------------*		lda	  thekey		cmp	  #'f'		bne	  notFind		lda	  W_findactive		jeq	  exit		lda	  #1			  ; Find Next		ldx	  #1			  ; simple button		jsr	  FakeButton		brl	  exitnotFind	cmp	  #'r'		bne	  notReplace		lda	  W_replactive		jeq	  exit		lda	  #2			  ; Replace		ldx	  #1			  ; simple button		jsr	  FakeButton		brl	  exitnotReplace	cmp	  #'t'		bne	  notThen		lda	  W_replactive		jeq	  exit		lda	  #3			  ; Replace, then Find		ldx	  #1			  ; simple button		jsr	  FakeButton		brl	  exitnotThen	cmp	  #'a'		bne	  notAll		lda	  W_findactive		jeq	  exit		lda	  #4			  ; Replace All		ldx	  #1			  ; simple button		jsr	  FakeButton		brl	  exitnotAll	cmp	  #'i'		bne	  notIgnore		lda	  #$202		   ; D_Ignore Case		ldx	  #2			  ; check box		jsr	  FakeButton		brl	  exitnotIgnore	cmp	  #'w'		bne	  notWhole		lda	  #$203		   ; Whole Word(s)		ldx	  #2			  ; check box		jsr	  FakeButton		brl	  exitnotWhole	cmp	  #'1'		bne	  notStart		lda	  #5			  ; Start Over		ldx	  #1			  ; simple button		jsr	  FakeButton		brl	  exitnotStart	cmp	  #'d'		bne	  notDone		lda	  #6			  ; Done		ldx	  #1			  ; simple button		jsr	  FakeButton		brl	  exitnotDone	brl	  exit			; no more apple- things*--------------------------------------------------------------**				  Check other W_Key equivalents				 ;*--------------------------------------------------------------*notApple	lda	  themods		and	  #$0800		  ; option?		beq	  notOption		lda	  theKey		cmp	  #9			  ; Tab?		bne	  notTab		moveword #$4,[eventptr]:#2		brl	  exitnotTab	cmp	  #13			 ; return?		bne	  notReturn		moveword #$5,[eventptr]:#2notReturn	brl	  exitnotOption	lda	  theKey		cmp	  #9			  	; tab?		beq	  keepkey		cmp	  #8			  	; <-?		beq	  keepkey		cmp	  #21			 	; ->?		beq	  keepkey		cmp	  #32			 	; normal W_Char?		bge	  keepkey		cmp	  #13			 	; return?		bne	  nokey		   		; Don't let bogus char's through!		lda	  W_findactive	  	; let CR thru only if find is active		beq	  nokey		   		; (I don't want junk in my LE fields!)keepkey	brl	  exitnokey	inc	  handled		 	; I 'handled' it.  Go away.		moveword #0,[itemptr]exit	return				   	; You do it.*--------------------------------------------------------------**   Fake a D_MouseDown on a control.  A = item ID, X = ctl type  ;*--------------------------------------------------------------*FakeButton	sta	  [itemptr]		cpx	  #1		bne	  noblink		pushlong dlgptr		pushword [itemptr]		jsl	  D_BlinkButtonnoblink	inc	  handled		 ; forget the W_Key event.		rts		ENDP******************************************************************   W_DispCharsIn(string:l)*****************************************************************W_DispCharsIn	PROC		EXPORT		input	string:l		begin		short		lda	  [string]		beq	  bye		tayloop	lda	  [string],y		cmp	  #$9		bne	  nottab		lda	  #$4		bra	  storeitnottab	cmp	  #$d		bne	  next		lda	  #$5storeit	sta	  [string],ynext	dey		bne	  loopbye	long		return		ENDP******************************************************************   W_DispCharsOut(string:l)*****************************************************************W_DispCharsOut	PROC		EXPORT		input	string:l		begin		short		lda	  [string]		beq	  bye		tayloop	lda	  [string],y		cmp	  #$4		bne	  nottab		lda	  #9		bra	  storeitnottab	cmp	  #$5		bne	  next		lda	  #$dstoreit	sta	  [string],ynext	dey		bne	  loopbye	long		return		ENDP****************************************************************W_FRData	PROC		EXPORT		EXPORT	W_findactive		EXPORT	W_replactive		EXPORT	W_foundonce		EXPORT	W_target		EXPORT	W_firstpar		EXPORT	W_firstline		EXPORT	W_firstoff		EXPORT	W_lastpar		EXPORT	W_lastline		EXPORT	W_lastoff		EXPORT	W_FindRepWork		EXPORT	W_visRect		EXPORT	W_lowbounds		EXPORT	W_hiboundsW_findactive	DC.W	1	; is there anything to find?W_replactive	DC.W	1	; is there anything to replace it with?W_foundonce	DC.W	0	; have I found anything yet?W_target		DS.B 64			  		; the >real< W_Search stringW_firstpar		DS.B 2			   ; limits of found Q_TextW_firstline		DS.B 2W_firstoff		DS.B 2W_lastpar			DS.B 2W_lastline		DS.B 2W_lastoff			DS.B 2W_FindRepWork		DC.L	W_FindIt	DC.L	W_ReplaceIt	DC.L	W_ReplaceFind	DC.L	W_ReplaceAll	DC.L	W_StartOverW_visRect	DC.W	0,0,100,640	; visible portion of D_WP window (local)W_lowbounds	DC.W	106,25,195,615W_hibounds	DC.W	17,25,106,615		ENDP		END