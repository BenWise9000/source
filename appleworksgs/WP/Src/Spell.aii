	load 'macros.dump'	include 'm16.newprodos'	include 'driver.equ'	include 'wp.equ';------------------------------------------;; Equates from procedure W_SpellData;;------------------------------------------DictAux		equ $8001UDictAux	equ $8002DictType	equ	$d0SPNOERR		equ $00				 ; ;*** Error codes ;***SPACTIVE	equ $01SPINACTIVE	equ $02SPNOMEM		equ $03SPTOOMANY	equ $04SPBADRESULT	equ $05SPBADMODE	equ $06SPBADREF	equ $07SPPRODOS	equ $08SPCANTDOIT	equ $09SPCBREAK	equ $00				 ; ;*** Constants ;***SPCMISSPELL	equ $01SPCMISPUNC	equ $02SPCCAP		equ $04SPCHYPH		equ $08SPCREPEAT	equ $10SPMAXUDICT	equ $08SPMAXALTS	equ $10SPMSENT		equ $00SPMNOSENT	equ $01SPHJump		equ $0100SPHSubst	equ $0200SPHaccept	equ $0300SPHReplace	equ $0400SPHCancel	equ $0500SPHFinish	equ $0600;-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	W_Caret	IMPORT	CaretOff	IMPORT	D_LoadSegment	IMPORT	D_UnloadSegment	IMPORT	D_AlertBox	IMPORT	D_BeachBall	IMPORT	W_CurDoc	IMPORT	W_DelSelect	IMPORT	D_DefDictPath	IMPORT	D_DictPathHdl	IMPORT	W_EndOffset	IMPORT	W_FindLine	IMPORT	W_GetAddr	IMPORT	D_GetVol2	IMPORT	W_GotoEnd	IMPORT	W_InvSelect	IMPORT	W_InvalScroll	IMPORT	D_LoadSegNum	IMPORT	W_MakeCaret	IMPORT	D_MyId	IMPORT	D_NumberTable	IMPORT	W_PasteStr	IMPORT	W_SelectOff	IMPORT	W_SelectText	IMPORT	D_SetCursor	IMPORT	W_StartLine	IMPORT	THCloseFiles	IMPORT	THDlg	IMPORT	THOpenFiles	IMPORT	THShutDown	IMPORT	THStartUp	IMPORT	W_UpdateAfter	IMPORT	W_UpdateDoc	IMPORT	W_WordBounds	IMPORT	D_WriteConfig	IMPORT	W_addr	IMPORT	W_LastP	IMPORT	D_NewWord	IMPORT	W_offset	IMPORT	W_Ptr	IMPORT	W_StartOffset	IMPORT	W_StartPar	IMPORT	D_Deref	IMPORT	D_NeedHand	IMPORT	D_DisposePtr	IMPORT	D_DrawSFItem	IMPORT	D_GetDialog640	IMPORT	D_OpenSFReply	IMPORT	D_ONameRef	IMPORT	D_OPathRef	IMPORT	D_OFileGood	import	D_SFPGetFile2		IMPORT	D_Alert3	Case	OBJECT	IMPORT	SPCheck	import	SPCloseDlg	import	SPShutDown	import	SPStartUp	import	SPOpenUDict	import	SPCloseFiles	import	SPJumpLoc	import	SPDlg	import	THStartUp	import	THOpenFiles	import	THDlg	import	THCloseFiles	import	THShutDown	import	SPEditUDict	import	SPNewUDict	Case	OFF		;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	W_AddrToLineOff	ENTRY	W_BadWord	ENTRY	W_ComdTable	ENTRY	W_DictName	ENTRY	W_FindDict	ENTRY	W_GoodWord	ENTRY	W_KillSPTH	ENTRY	W_LoadSpell	ENTRY	W_LoadThes	ENTRY	W_MakeWord	ENTRY	W_RMEnd	ENTRY	W_RepMessage	ENTRY	W_SPAuxFilt	ENTRY	W_SPTitle	ENTRY	W_SPTypeList	ENTRY	W_spDlgPos	ENTRY	W_SpHandleErr	ENTRY	W_spPar	ENTRY	W_StartSpell		IF (Network > 1) THEN	ENTRY	W_UDictNetwork		ENDIF	ENTRY	UserDict	ENTRY	W_UserRef	ENTRY	W_WhatWord	ENTRY	W_cancelled;	ENTRY	W_NoBadWords	ENTRY	W_spVisRect	ENTRY	W_AddStr1		ENTRY	W_ASCIIDICT	ENTRY	W_ASCIITYPELIST*****************************************************************															  ;*	 GSworks word processor W_Spelling checker and W_Thesaurus	;*______________________________________________________________**															  ;*	 Original dictionary/W_Thesaurus interface by Bob Hearn	 ;*	 Original MultiScribe GS integration by Kevin Harvey	  ;*	 GSworks integration and comments by Jeff Erickson		;*______________________________________________________________**															  ;*		CONTENTS:											 ;*			  W_CheckSpelling								   ;*			  W_Thesaurus									   ;*			  W_EditUserDict									;*															  ;**************************************************************************************************************************************	Includes...** Wednesday, May 3, 1989 2:49:45 AM**************************************************************************************************************************************   W_CheckSpelling -- check the W_Document for W_Spelling errors*****************************************************************W_CheckSpelling	PROC		EXPORT			;Using	W_SpellData			;Using	WPGlobals		begin	+b		jsl	  W_StartSpell		jcs	  exit;			  case_jsl SPOpenFiles		stz	  W_cancelled				lda W_Caret		beq @1		jsl CaretOff@1		lda	  W_StartPar		sta	  W_spPar		ldx	  W_StartOffset		jsl	  W_WordBounds	  ; start at begining of the W_Documentloop	jsl	  W_GetAddr		 ; spell-check the paragraph		pushlong ax		pushlong #W_ComdTable	  ; command table		pushword #spMnoSent	  ; doesn't start at a sentence		pushlong #W_SpHandleErr	; exception handler		pushlong W_CurDoc		pushlong #W_Cancelled		case_jsl SPCheck		lda	  W_cancelled		bne	  done		inc	  W_spPar		   ; Am I done?		lda	  W_spPar		cmp	  W_LastP		bgt	  nomore		ldx	  #W_TextHeader		bra	  loopnomore	pushlong W_CurDoc		_SetPort		jsl W_SelectOff		stz W_Caret		; why?		jsl W_GotoEnd;		spaceword			---- this is pointless.;		pushword #okBox;		pushlong #W_NoBadWords;		jsl	  D_AlertBox;		pladone	call D_SetCursor,in=(#WatchCursor:w);			  case_jsl SPCloseFiles		case_jsl SPCloseDlg		case_jsl SPShutDown		jsl	  W_KillSPTH		jsl	  W_InvalScrollexit	return		ENDP******************************************************************   W_StartSpell -- load the SP segment and open the dictionaries*****************************************************************W_StartSpell	PROC		EXPORT			;Using	D_GlobalData			;Using	D_ModuleData			;Using	W_SpellData		local	path:l,upath:l,len:w		local	access:w,pathname:l,pcount:w		error	err		begin		stzl upath				moveword #-1,err		jsl	  W_LoadSpell	   		; load spell segments		jcs	  exit		jsl	  W_FindDict			; find the dictionary, if necessary		jcs	  exit		call D_SetCursor,in=(#WatchCursor:w)			pushword >D_MyId		   	; startup						cpzl >D_DictPathHdl			; if we read a pathname out of the config file, use it.			beq useDefault				; else try the standard path.				lda >D_DictPathHdl+2				tax				lda >D_DictPathHdl				rcall D_Deref,out=(path:ax)	   	; (directory containing the dictionary)				bra startItuseDefault				movelong #D_DefDictPath,path		startIt		pushlong path				case_jsl SPStartUp			bcc	  W_started			cmp	  #SPactive			jne	  closeW_started			spacelong		IF (Network ² 1) THEN			pushlong path				; For the userdict,		ELSE			pushlong #W_UDictNetwork	; if it's a network version, get the user's userdict.		ENDIF			pushlong #UserDict			jsl W_AddStr1			pulllong upath			bcc @1			stzl upath			brl exit		@1			call D_GetVol2,in=(upath:l),out=(a:w),err=(err)			jcs exit						moveword #2,pcount			movelong upath,pathname			tool _Get_File_Info,in=(!pcount:l),err=(err)			moveword [upath],len			; convert from Class 1 string to C String.			spacelong			pushlong upath			addlong upath,#2,5:s			pushword #0			pushword len			_BlockMove			moveword #0,[upath]:len			; yes this *is* safe.			lda err			beq openIt			pushlong upath			pushword #DictType			pushlong #UDictAux			case_jsl SPNewUDict			bcs exitopenIt		spaceword			pushlong upath			case_jsl SPOpenUDict			pullword W_UserRef			bcs exit			stz err			bra exit		close				case_jsl SPCloseFilesexit					cpzl upath		beq @2			call D_DisposePtr,in=(upath:l)@2		return		ENDP******************************************************************   W_SpHandleErr -- W_Handle a spell checker exception*****************************************************************W_SpHandleErr	PROC		EXPORT			;Using	W_SpellData			;Using	WPGlobals		input	errcode:w,wstart:l,wend:l,arg:l,prevend:l		output   result:w		begin	+b		cmpw	 errcode,#spCbreak		bne	  samepar		moveword #spHfinish,result	  ; if so, STOP		brl	  exitsamepar	call D_BeachBall		pushlong W_CurDoc		_SetPort		pushword W_spPar		  			; make the word visible and select it		spacelong			   			;\		pushword W_spPar		   			; push W_StartLine and W_StartOffset		pushlong wstart		  			;		jsl	  W_AddrToLineOff  			;/		pushword W_spPar		spacelong			   			;\		pushword W_spPar		   			; push W_EndLine and W_EndOffset		pushlong wend					;		jsl	  W_AddrToLineOff  			;/		pushlong #W_spVisRect		jsl	  W_SelectText		jsl	  W_InvSelect		jsl	  W_MakeWord					; copy the W_Selected word w/o font info		moveword #spHaccept,result	  	; accept until further notice.		cmpw	 errcode,#spCrepeat	 	; repeat?		jne	  norepeat		pushword >D_Alert3		pushword >D_Alert3+4		subword W_spDlgPos,>D_Alert3,a	; offset to new position		addword a,#5,a					; 5 pixels down to be centered vertically.		addword a,>D_Alert3+4,>D_Alert3+4		addword #5,W_spDlgPos,>D_Alert3				; ask if the user wants it deleted		call D_AlertBox,in=(#YesNoBox:w,#W_RepMessage:l),out=(y:w)				pullword >D_Alert3+4				; restore the alert's real position		pullword >D_Alert3				cpy	  #1			  			; yes?		jeq	  deleteit		cpy	  #3			  			; no?		jeq	  exit		moveword #spHcancel,result	  	; must be cancel.		inc	  W_cancelled				; ...so the caret will stop where you are. 		brl	  exitdeleteit		pushword W_spPar		  			; make the word visible and select it		spacelong			   			;\		pushword W_spPar		   			; push W_StartLine and W_StartOffset		pushlong prevend		  			;		jsl	  W_AddrToLineOff  			;/		pushword W_spPar		spacelong			   			;\		pushword W_spPar		   			; push W_EndLine and W_EndOffset		pushlong wend					;		jsl	  W_AddrToLineOff  			;/		pushlong #W_spVisRect		jsl	  W_SelectText		jsl	  W_DelSelect	   			; delete the text (and D_Update)		moveword #spHjump,result		lda	  W_StartPar					; get address to continue looking		ldx	  W_StartOffset		jsl	  W_GetAddr		CASE	OBJECT 		sta	  >SPJumpLoc		txa		sta	  >SPJumpLoc+2		CASE	OFF 		brl	  exitnorepeat	spaceword		pushword W_spDlgPos		pushlong #W_BadWord				; address of erroneous word		pushword errcode		 		; error code (default?)		pushlong #W_GoodWord	   			; address of replacement word		pushlong #0			  			; useless routine		pushword W_UserRef		case_jsl SPDlg		pla					  			; accept		jeq	  exit		cmp	  #3			  			; add to dictionary?		jeq	  exit		cmp	  #1			  			; replace		beq	  replace		moveword #SPHCancel,result	  	; must be cancel		inc	  W_cancelled		brl	  exitreplace	moveword #SPHReplace,result		cmpw	 errcode,#SPcCap 		; Capitalization error?		bne	  pasteit		lda	  W_GoodWord					; Did the user offer a replacement?		and	  #$ff		bne	  pasteit		pushlong #W_BadWord				; If not, just capitalize the bad word		pushlong #W_GoodWord		pushlong #32		_BlockMove		lda	  W_GoodWord+1		and	  #$ffdf		sta	  W_GoodWord+1pasteit	pushlong W_CurDoc		_SetPort		spacelong		spacelong		pushlong #W_GoodWord		jsl	  W_PasteStr		pulllong ax			  			; who cares about this stuff?		pulllong ax		lda	  W_StartPar					; Restart at the beginning		ldx	  W_StartOffset	 			; of the replacement text.		jsl	  W_GetAddr		CASE	OBJECT 		sta	  >SPJumpLoc		txa		sta	  >SPJumpLoc+2		CASE	OFF 		pushword W_StartPar		pushword W_StartLine		jsl	  W_UpdateAfterexit	return		ENDP******************************************************************   W_AddrToLineOff(par:w,W_addr:l)->line:w,off:w*****************************************************************W_AddrToLineOff	PROC		EXPORT		input	par:w,W_addr:l		output  line:w,off:w		local	paddr:l,temp:l		begin		lda	  par		ldx	  #0		jsl	  W_GetAddr		movelong ax,paddr		sublong  W_addr,paddr,temp		moveword temp,off		spaceword		pushword par		pushword off		jsl	  W_FindLine		pullword line		return		ENDP******************************************************************   W_Thesaurus -- bring up the W_Thesaurus dialog for the first*		word after the insertion point*****************************************************************W_Thesaurus	PROC		EXPORT			;Using	W_SpellData			;Using	WPGlobals			;Using	D_GlobalData			;Using	D_ModuleData		local	newword:l,par:w,soff:w,eoff:w,rect:r		local	path:l		begin	+b		rcall W_WordBounds,in=(W_StartPar:a,W_StartOffset:x),out=(par:a,soff:x,eoff:y)		cmpw	 soff,eoff		bne	  wordthere		spaceword		pushword #OKBox		pushlong #W_WhatWord		jsl	  D_AlertBox		pla		brl	  exitwordthere	jsl	  W_LoadThes		jcs	  exit		jsl	  W_FindDict		jcs	  exit		call D_SetCursor,in=(#WatchCursor:w)				pushword >D_MyId		   	; startup					cpzl >D_DictPathHdl			; if we read a pathname out of the config file, use it.		beq useDefault				; else try the standard path.			lda >D_DictPathHdl+2			tax			lda >D_DictPathHdl			rcall D_Deref,out=(path:ax)	   	; (directory containing the dictionary)			bra startItuseDefault			movelong #D_DefDictPath,path		startIt	pushlong path			case_jsl THStartUp		bcc	  W_started		cmp	  #spActive		jne	  closeW_started	;		case_jsl THOpenFiles			but it's already open.  ÑÑ MSL 7/27/89;		jcs	  close		pushlong W_CurDoc		_SetPort		pushword par		spaceword		pushword par		pushword soff		jsl	 W_FindLine		pushword soff		pushword par		spaceword		pushword par		pushword eoff		jsl	 W_FindLine		pushword eoff		pushlong #0			  		; use whole doc rect		jsl	  W_SelectText		jsl	  W_InvSelect		jsl	  W_MakeWord		spacelong					; returns address of new word		pushlong #W_BadWord		case_jsl THDlg		pulllong newword		cpzl newword		beq	  close		pushlong newword		pushlong #W_GoodWord		pushlong #32		_BlockMove		spacelong		spacelong		pushlong #W_GoodWord		jsl	  W_PasteStr		pulllong ax			  		; who cares about this stuff?		pulllong ax;		re-select the word.		rcall W_WordBounds,in=(W_StartPar:a,W_StartOffset:x),out=(par:a,soff:x,eoff:y)		pushword par		spaceword		pushword par		pushword soff		jsl	 W_FindLine		pushword soff		pushword par		spaceword		pushword par		pushword eoff		jsl	 W_FindLine		pushword eoff		pushlong #0			  		; use whole doc rect		jsl	  W_SelectText		jsl	  W_InvSelect;		jsl	  W_MakeCaret		pushword W_StartPar		pushword W_StartLine		jsl	  W_UpdateAfter		close  	;		case_jsl THCloseFiles		; THShutdown closes it.		case_jsl THShutDown		jsl	  W_KillSPTHexit	return		ENDP******************************************************************   W_EditUserDict -- edit the user dictionary*****************************************************************W_EditUserDict	PROC		EXPORT			;Using	W_SpellData		local	modifiers:w,where:l,when:l,msg:l,what:w		local	pathname:l		begin	+b		tool _GetNextEvent,in=(#0:w,!what:l),out=(a:w)		lda modifiers		and #optionKey		sta modifiers@start	jsl	  W_StartSpell	  			; find the user dictionary		jcs	  exit		stzl pathname;		lda modifiers;		beq @goahead;		tool _SFPGetFile2,in=(#100:w,#50:w,#D_DrawSFItem:l,#0:w,#W_AsciiDict:l,#0:l,#W_AsciiTypeList:l,#D_GetDialog640:l,#0:l,#D_OpenSFReply:l);		lda	>D_OFileGood;		beq @goahead;		movelong >D_OPathRef,pathname;		lda [pathname];		tay;		iny;		iny;		lda #0;		shortm;		sta [pathname],y;		longm;		incl pathname;		incl pathname		@goahead		call D_SetCursor,in=(#WatchCursor:w)		pushword W_UserRef		pushlong pathname		case_jsl SPEditUDict		case_jsl SPShutDown		jsl	  W_KillSPTHexit	return		ENDP******************************************************************   W_FindDict -- find the main dictionary*****************************************************************W_FindDict	PROC		EXPORT			;Using	W_SpellData			;Using	WPglobals			;Using	D_ModuleData	  	; << driver <<		local	access:w,pathname:l,pcount:w		local	thpath:l,tmp:l		error	err		begin		stz err		stzl thpath		call D_SetCursor,in=(#arrowCursor:w)		spacelong			; for AddStr1		cpzl >D_DictPathHdl		beq useDefault		lda >D_DictPathHdl+2		tax		lda >D_DictPathHdl		rcall D_Deref,out=(s:ax)	; get the path from the config file				bra doAdduseDefault				pushlong #D_DefDictPath	   		doAdd		pushlong #W_DictName		jsl	  W_AddStr1		pulllong thpath		bcc @1		dec err		stzl thpath		brl exit@1		moveword #2,pcount		movelong thpath,pathname		tool _Get_File_Info,in=(!pcount:l)		jcc	  exitask4it	call D_SFPGetFile2,in=(#100:w,#50:w,#0:w,#W_SPTitle:l,#W_SPAuxFilt:l,#W_SPTypeList:l,#D_GetDialog640:l,#0:l,#D_OpenSFReply:l)		pushlong W_CurDoc		  		; redraw under the SF dialog		_BeginUpdate		pushlong W_CurDoc		jsl	  W_UpdateDoc		pushlong W_CurDoc		_EndUpdate		lda	>D_OFileGood		bne	gotsp		dec err		brl exitgotsp	cpzl >D_DictPathHdl		beq @1		tool _DisposeHandle,in=(>D_DictPathHdl:l)	; get rid of the old one@1		movelong >D_OPathRef,>D_DictPathHdl		tool _DisposeHandle,in=(>D_ONameRef:l)		; not used...		lda >D_DictPathHdl+2		tax		lda >D_DictPathHdl		rcall D_Deref,out=(tmp:ax)		addword [tmp]:#2,#2,x						subword a,#12,[tmp]:y						; strip off the filename ÔDictionaryÕ		addlong tmp,#2,s		pushlong tmp		pushword #0		phx		stx tmp		_BlockMove		tool _HUnlock,in=(>D_DictPathHdl:l)				addword tmp,#16,a							; Allow space for up to ÔUser.DictionaryÕ to be added.		tool _SetHandleSize,in=(#0:w,a:w,>D_DictPathHdl:l)		jsl	  D_WriteConfig	 		; Save the pathname in the config file		lda >D_DictPathHdl+2		; just in case it moved when I resized itÉ		tax		lda >D_DictPathHdl		rcall D_Deref		call D_GetVol2,in=(ax:l),out=(a:w),err=(err)		exit	cpzl thpath		beq @2		call D_DisposePtr,in=(thpath:l)@2		return		ENDP******************************************************************   W_SPAuxFilt -- used above**	Filters for a file named Dictionary and of the correct auxtype*****************************************************************W_SPAuxFilt	PROC		EXPORT			;Using	W_SpellData		input	direntry:l		output	result:w		local	tmp:l,size:w		begin	+b		stz	  result		movelong [direntry]:#$A,tmp				moveword [tmp]:#2,size		cmp #10					; length of ÔdictionaryÕ		bne done		ldx #2		ldy #4;	  * See if it's really named dictionary.loop	lda [tmp],y		and #$5F5F				; convert to Uppercase		cmp W_DictName,x		bne done				iny		iny		inx		inx				cpx #10		blt loop				cmpl [direntry]:#$2C,#dictAux		bne	  done		moveword #2,resultdone	return		ENDP******************************************************************   W_MakeWord -- copy the W_Selected text into W_BadWord, stripping*		font information (or, rather, the first 30 chars of it)*****************************************************************W_MakeWord	PROC		EXPORT			;Using	W_SpellData			;Using	WpGlobals		local	W_Ptr:l,W_offset:w,count:w		begin		lda	  W_StartPar		ldx	  #0		jsl	  W_GetAddr		movelong ax,W_Ptr		subword  W_EndOffset,W_StartOffset,count		ldy	  W_StartOffset		ldx	  #0		stz	  W_BadWord		shortmmloop	lda	  [W_Ptr],y		cmp	  #$20		bge	  gotit		cmp	  #$d		bge	  gotit		cmp	  #9		bge	  gotit		cmp	  #1		bne	  skip1		cmp	  #5		bge	  skip0		inyskip1	inyskip0	iny		bra	  mloopgotit	inx		sta	  W_BadWord,x		cpx	  #30		beq	  gotword		iny		cpy	  W_EndOffset		bne	  mloopgotword	txa		sta	  W_BadWord		longm		return		ENDP******************************************************************   W_LoadSpell -- load the W_Spelling checker segments*   W_LoadThes -- load the W_Thesaurus segments*   W_KillSPTH -- unload the speller/W_Thesaurus segments*_______________________________________________________________**   NOTE: The speller segments must immediately follow the WP*		segment in the order SPTHSTATIC, SP, TH, SPTH.  Also,*		the word processing module must be module #0, and*		must be loaded.*****************************************************************W_LoadSpell	PROC		EXPORT			;Using	W_SpellData			;Using	D_ModuleData		error	oops		begin		call D_LoadSegment,in=(#segSP:w,#1:w),out=(a:l),err=oops		bcs	  exit		call D_LoadSegment,in=(#segSPTH:w,#1:w),out=(a:l),err=oopsexit	return		ENDP****************************************************************W_LoadThes	PROC		EXPORT			;Using	W_SpellData			;Using	D_ModuleData		error	oops		begin		call D_LoadSegment,in=(#segTH:w,#1:w),out=(a:l),err=oops		bcs	  exit		call D_LoadSegment,in=(#segSPTH:w,#1:w),out=(a:l),err=oopsexit	return		ENDP****************************************************************W_KillSPTH	PROC		EXPORT			;Using W_SpellData		begin		cpzl >D_DictPathHdl		beq @1		tool _HUnlock,in=(>D_DictPathHdl:l)	@1				Call D_UnloadSegment,in=(#segSP:w,#1:w)		Call D_UnloadSegment,in=(#segTH:w,#1:w)		Call D_UnloadSegment,in=(#segSPTH:w,#1:w)		return		ENDPW_AddStr1	PROC	EXPORT		input s1:l,s2:l		output result:l		local size:w,hdl:l,ptr:l		error err		begin +b				moveword #-1,err		addword [s1],[s2],a		bvc @1		brl exit@1		addword a,#2,size		bvc @2		brl exit@2		call D_NeedHand,in=(#0:w,size:w),out=(hdl:l)		bcs exit				rcall D_Deref,in=(hdl:ax),out=(result:ax)				subword size,#2,[result]		addlong #2,result,ptr		moveword [s1],size		incl s1		incl s1				tool _BlockMove,in=(s1:l,ptr:l,#0:w,size:w)				addwl size,ptr		moveword [s2],size		incl s2		incl s2				tool _BlockMove,in=(s2:l,ptr:l,#0:w,size:w)		stz err		exit	return		ENDP****************************************************************W_SpellData	PROC		EXPORT		EXPORT	UserDict		EXPORT	W_DictName		EXPORT	W_SPTitle		EXPORT	W_SPTypeList		EXPORT	W_SPAddr		EXPORT	W_THAddr		EXPORT	W_SPTHAddr		EXPORT	W_RepMessage		EXPORT	W_RMEnd		EXPORT	W_SpellMess		EXPORT	W_ThesMess;		EXPORT	W_NoBadWords		EXPORT	W_WhatWord		EXPORT	W_BadWord		EXPORT	W_GoodWord		EXPORT	W_spPar		EXPORT	W_cancelled		EXPORT	W_spDlgPos		EXPORT	W_spLowPos		EXPORT	W_spHighPos		EXPORT	W_spVisRect		EXPORT	W_UserRef		EXPORT	W_ComdTable		EXPORT	W_CharMapTable		EXPORT	W_CharBucket			IF (Network > 1) THEN		EXPORT 	W_UDictNetwork			ENDIF		EXPORT	W_AsciiTypeList		EXPORT	W_AsciiDictUserDict	str1 'User.Dictionary'W_DictName	str1 'DICTIONARY'W_SPTitle		str 'Please open the dictionary file.'W_AsciiDict		str 'Select a text file to import into the user dictionary:'W_SPTypeList	DC.W	1				DC.W	$8000				DC.W	dictType				DC.L	dictAuxW_AsciiTypeList DC.W	2				DC.W	$8000				DC.W	4	; TXT				DC.L	0				DC.W	$8000				DC.W	$B0	; SRC				DC.L	0						IF (Network > 1) THENW_UDictNetwork	STR1 '@:'		ENDIF		*--------------------------------------------------------------*W_RepMessage	DC.B	W_RMEnd-W_RepMessage-1	DC.B	'A duplicated word has been found.'	DC.B	$0d	DC.B	'Should the second occurrence be deleted?'W_RMEndW_SpellMess	str 'There is not enough memory to check spelling.'W_ThesMess	str 'There is not enough memory to use the thesaurus.';W_NoBadWords	str 'No more errors found.'W_WhatWord	str 'Please select a word and try again.'W_BadWord	DS.B 33	; 32 byte string + length byteW_GoodWord	DS.B 33 ; "    "    "        "     "W_spPar		DS.B 2W_cancelled	DS.B 2W_spDlgPos	DC.W	109W_spLowPos	DC.W	109W_spHighPos	DC.W	20W_spVisRect	DC.W	0,0,90,640W_UserRef		DS.B 2W_ComdTable		DC.B	2,4,3,3,3,2,2,2,2,1,2,2,2,0,2,2	DC.B	2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1	DC.B	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;W_CharMapTable	;	DC.B	$8E,$8F,$80,$B1,$A5,$99,$9A,$85,$A0,$83,$84,$C2,$86,$87,$8A,$82;	DC.B	$88,$89,$8D,$A1,$8C,$8B,$A4,$95,$A2,$93,$94,$C6,$97,$A3,$96,$81;	DC.B	?  ,$F8,?  ,?  ,?  ,?  ,?  ,$E1,?  ,?  ,?  ,?  ,?  ,?  ,$92,$E9;	DC.B	?  ,?  ,?  ,?  ,?  ,?  ,?  ,?  ,?  ,?  ,?  ,?  ,?  ,?  ,$91,$ED;	DC.B	$A8,$AD,?  ,?  ,?  ,?  ,?  ,$AE,$AF,?  ,?  ,;	'?!  f= "". AAOOo';	DC.B	'--""""/ yY/ <>ff';	DC.B	'  ""%AEAEEIIIIOO';	DC.B	' OUUUi          'W_CharBucket	DC.B	0,$ff		ENDP		END