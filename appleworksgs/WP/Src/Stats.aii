	load 'macros.dump'	include 'driver.equ'	include 'wp.equ';-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	D_CloseDialog	IMPORT	W_GetAddr	IMPORT	D_GetNewModalDialog	IMPORT	W_GetParRec	IMPORT	W_LastP	IMPORT	W_StatDlg	IMPORT	W_Char	IMPORT	Q_Line	IMPORT	W_NumPgs			IMPORT	W_Ptr	IMPORT	W_shiftTab	IMPORT	W_stStatText	**********************************************************************	includes***** Wednesday, May 3, 1989 5:00:57 AM**************************************************************************************************************************************   W_Statistics -- display the following information about the*		current word processing W_Document:**					   Number of characters*					   Number of words			  \*					   Number of lines			   Y\___,*					   Number of paragraphs		   <|/|*					   Number of pages**   A word is defined as one or more printing characters*		followed by any amount of white space.  A paragraph*		is defined as one or more characters, starting with*		a printing character, ending with a carriage return.*		(NOTE: This is not the same as Kevin's definition,*		as it excludes empty paragraphs, page breaks, and*		pictures.)*****************************************************************W_Statistics	PROC		EXPORT			;Using	WPGlobals			;Using	W_StatData		local	W_Char:l,word:l		local	Q_Line:w,para:w,page:w		local	dialog:l,pcount:w,W_Ptr:l		local	inword:w,inpar:w		begin	+b		movelong #-1,W_Char		; Don't count final CR!		stz	  word		stz	  word+2		stz	  Q_Line		stz	  para		moveword W_NumPgs,page	 ; gee, dat were hard. (keeyuk!)*--------------------------------------------------------------**				  Loop through the paragraphs				 ;*--------------------------------------------------------------*		moveword #1,pcount	   	; WHY NOT ZERO, KEVIN?ploop	stz	  inword		  	; --- Paragraph loop ---		lda	  pcount		jsl	  W_GetParRec		movelong ax,W_Ptr		moveword [W_Ptr]:#W_pAttr,a  		; What kind of paragraph?		jne	  nextpar		 			; not Q_Text?  forget it!		moveword [W_Ptr]:#W_pLastLine,a	 	; how many lines?		bne	  notempty					; (0 = just a CR)		inc	  Q_Line						; inc Q_Line count, NOT paragraph count		brl	  nextparnotempty	addword  a,Q_Line,Q_Line	 	; change Q_Line count		stz	  inpar		lda	  pcount		ldx	  #W_TextHeader		jsl	  W_GetAddr					; get the starting address of the Q_Text		movelong ax,W_Ptrcloop	lda	  [W_Ptr]		   				; --- Character loop ---		and	  #$ff						; (low byte only)		cmp	  #13			 			; CR?		bne	  notCR		lda	  inword		beq	  noCRword		addwl	#1,wordnoCRword	addwl	#1,W_Char		 		; CR's are characters, too!		brl	  nextparnotCR	cmp	  #9			  			; Tab?		bne	  notTab		lda	  inword		beq	  noTabWord		addwl	#1,word		stz	  inwordnoTabWord	brl	  nextcharnotTab	cmp	  #' '						; space?		bne	  notBlank		lda	  inword		beq	  noBlankWord		addwl	#1,word		stz	  inwordnoBlankWord	brl	  nextcharnotBlank	bgt	  realchar				; is it a code character?		asl	  a			   				; if so, get number of bytes to shift		tax		lda	  >W_shiftTab,x		clc					  			; and shift the pointer		adc	  W_Ptr			 			; <addwl W_shiftTab:x,W_Ptr / brl cloop>		sta	  W_Ptr			 			;			  -- or --		jcc	  cloop		   				; <lda W_shiftTab,x/addwl a,W_Ptr/brl cloop>		inc	  W_Ptr+2		brl	  cloop		   				; but DON'T increment the W_Char count!realchar	moveword #1,inword		moveword #1,inparnextchar	addwl	#1,W_Char		 		; FINALLY increment the W_Char count		inc	  W_Ptr			 			; increment the pointer and loop		jne	  cloop		inc	  W_Ptr+2		   				; <incl W_Ptr / brl cloop>		brl	  cloopnextpar	lda	  inpar		beq	  checkdone		inc	  paracheckdone	cmpw	 pcount,W_LastP		beq	  gotstats		inc	  pcount		brl	  ploop*--------------------------------------------------------------**	 Now that we have the numbers, let's put them to use!	 ;*--------------------------------------------------------------*gotstats	pushlong W_Char		pushlong #W_stStatText+4		pushword #6			  ; max. length		pushword #0			  ; unsigned		_Long2Dec		pushlong word		pushlong #W_stStatText+11		pushword #6			  ; max. length		pushword #0			  ; unsigned		_Long2Dec		pushword Q_Line		pushlong #W_stStatText+18		pushword #6			  ; max. length		pushword #0			  ; unsigned		_Int2Dec		pushword para		pushlong #W_stStatText+25		pushword #6			  ; max. length		pushword #0			  ; unsigned		_Int2Dec		pushword page		pushlong #W_stStatText+32		pushword #6			  ; max. length		pushword #0			  ; unsigned		_Int2Dec*--------------------------------------------------------------**				   Do the dialog (finally!)				   ;*--------------------------------------------------------------*		spacelong		pushlong #W_StatDlg		jsl	  D_GetNewModalDialog		pulllong dialogloop	spaceword		pushlong #0			  ; default filter		_ModalDialog		pla					  ; item number -- only one item to hit!		beq	  loop		pushlong dialog		jsl	  D_CloseDialog		return		ENDP		END