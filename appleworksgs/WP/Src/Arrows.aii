	load 'macros.dump'	include 'driver.equ'	include 'wp.equ';-----------------------------------------------;;   Imported addresses;;-----------------------------------------------	IMPORT	D_IsAlphaNum	IMPORT	X_BOffset	IMPORT	W_BotLine	IMPORT	W_BotPar	IMPORT	W_eOffset	IMPORT	W_FindLine	IMPORT	W_GetAddr	IMPORT	W_GetBegLine	IMPORT	W_GetEndLine	IMPORT	W_GetEndPar	IMPORT	W_GetHPos	IMPORT	W_GetLRecPtr	IMPORT	W_GetParRec	IMPORT	W_LessRoom	IMPORT	W_MakeCaret	IMPORT	W_NextCharBack	IMPORT	W_ParRec	IMPORT	W_PixelToOffset	IMPORT	W_StartLine	IMPORT	W_StartOffset	IMPORT	W_StartPar	IMPORT	W_TopLine	IMPORT	W_TopPar	IMPORT	W_WordBounds	IMPORT	W_LastP	IMPORT	Q_Line	IMPORT	W_offset;-----------------------------------------------;;   Forward addresses and entries;;-----------------------------------------------	ENTRY	W_GetNewOffset	ENTRY	W_GoDownLine	ENTRY	W_GoUpLine	ENTRY	W_OpArr	ENTRY	SkipTable*********************************************************************  All the includes...** Wednesday, April 26, 1989 6:53:57 PM********************************************************************								***************************************************************** W_GetFirstChar(par,W_offset):W_offsetW_GetFirstChar	PROC		EXPORT		input par:w,offset:w		output OOffset:w		local ChrPtr:l		begin		moveword #W_TextHeader,OOffset		cmp offset		bcs GotO		moveword offset,OOffsetGotO	lda par		ldx Ooffset		jsl W_GetAddr		movelong ax,ChrPtr		ldy #0		shortmLoop	lda [ChrPtr],y		cmp #sp		bcs GotOne		xba		lda #0		xba		asl a		tax		jmp (ChrTable,x)ChrTable	DC.W	0,Skip3							;0,1			DC.W	Skip2,Skip2						;2,3			DC.W	Skip2,GotOne					;4,5			DC.W	GotOne,GotOne					;6,7			DC.W	0,GotOne						;8,9			DC.W	0,0								;a,b			DC.W	0,GotOne						;c,dSkip3	inySkip2	iny		iny		bra LoopGotOne	longm		tya		clc		adc OOffset		sta OOffsetNoFind	longm		return		ENDP***************************************************************** W_GetNextChar(par,W_offset):W_offsetW_GetNextChar	PROC		EXPORT		input par:w,W_offset:w		output OOffset:w		local ChrPtr:l,Found:w		begin		moveword W_offset,OOffset		stz Found		lda par		ldx W_offset		jsl W_GetAddr		movelong ax,ChrPtr		ldy #0		shortmLoop	lda [ChrPtr],y		cmp #sp		bcs GotOne		xba		lda #0		xba		asl a		tax		jmp (ChrTable,x)ChrTable	DC.W	0,Skip3							;0,1			DC.W	Skip2,Skip2						;2,3			DC.W	Skip2,GotOne					;4,5			DC.W	GotOne,GotOne					;6,7			DC.W	0,GotOne						;8,9			DC.W	0,0								;a,b			DC.W	0,CrGotOne						;c,dSkip3	inySkip2	inySkip1	iny		bra LoopCrGotOne		lda found		beq NoFindGotOne		inc found		lda found		cmp #1		beq Skip1		longm		tya		clc		adc W_offset		sta OOffsetNoFind	longm		return		ENDP***************************************************************** W_BackChar(par:w,Q_Line:w,W_offset:w)par:w,Q_Line:w,W_offset:wW_BackChar	PROC		EXPORT		input Par:w,Q_Line:w,W_offset:w		local X_BOffset:w,W_eOffset:w,W_ParRec:l		output Opar:w,OLine:w,OOffset:w		begin		moveword Par,Opar		moveword Q_Line,OLine		pha		pushword par		pushword Q_Line		jsl W_GetBegLine		pullword X_BOffset		pha		pushword Par		pushword X_BOffset		jsl W_GetFirstChar		pla		sta OOffset		cmp W_offset		bcs W_GoUpLine		pha		pha		pushword par		pushword Q_Line		pushword W_offset		jsl W_NextCharBack		pla		pla		sta OOffset		brl BCExitW_GoUpLine		lda Q_Line		beq NextPar		dec OLine		pha		pushword Opar		pushword OLine		jsl W_GetEndLine		pullword OOffset		brl BCExitNextPar		lda Opar		cmp #1		beq BCExitPLoop		dec OPar		lda Opar		jsl W_GetParRec		movelong ax,W_ParRec		moveword [W_ParRec]:#W_pAttr,a		cmp #W_Picture		beq PLoop		cmp #W_PgBrk		beq PLoop		pha		pushword OPar		jsl W_GetEndPar		pullword OOffset		moveword [W_ParRec]:#W_pLastLine,a		dec a		sta OLineBCExit	return		ENDP***************************************************************** W_ForChar(par,Q_Line,W_offset)par,Q_Line,W_offsetW_ForChar	PROC		EXPORT		input Par:w,Q_Line:w,W_offset:w		local X_BOffset:w,W_eOffset:w,W_ParRec:l		output Opar:w,OLine:w,OOffset:w		begin		moveword Par,Opar		moveword Q_Line,OLine		pha		pushword Par		pushword W_offset		jsl W_GetNextChar		pla		sta OOffset		cmp W_offset		bne DoFind		lda Opar		cmp W_LastP		jeq BCExit		moveword #W_TextHeader,OOffsetPLoop		inc Opar		lda Opar		jsl W_GetParRec		movelong ax,W_ParRec		moveword [W_ParRec]:#W_pAttr,a		cmp #W_Picture		beq NextF		cmp #W_PgBrk		bne DoFindNextF		lda Opar		cmp W_LastP		beq BCExit		bra PLoopDoFind		cmpw Opar,par		bne NoSkip		cmpw OLine,Q_Line		bne NoSkip		pha		pushword Opar		pushword Oline		jsl W_GetEndLine		pla		cmp OOffset		bcs BCExitNoSkip		pha		pushword Opar		pushword OOffset		jsl W_FindLine		pullword OLine		sec		sbc Q_Line		cmp #1		bne BCExit		pha		pushword Opar		pushword Oline		jsl W_GetBegLine		pullword OOffsetBCExit	return		ENDP***************************************************************** RightArrowW_WPRightArrow	PROC		EXPORT		input TaskRec:l		local NewOffset:w,NewPar:w,NewLine:w		local ptr:l,chgsize:w,lastword:w,offset:w		begin		moveword [TaskRec]:#Omodifiers,a		bit #shiftKey		jne DoHigh		bit #optionKey		bne W_OpArr		bit #appleKey		bne AppArr		call W_ForChar,in=(W_StartPar:w,W_StartLine:w,W_StartOffset:w),out=(W_StartPar:w,W_StartLine:w,W_StartOffset:w)		jsl W_MakeCaret		brl RAExitAppArr		call W_GetEndLine,in=(W_StartPar:w,W_StartLine:w),out=(W_StartOffset:w)		jsl W_MakeCaret		brl RAExitW_OpArr	call W_ForChar,in=(W_StartPar:w,W_StartLine:w,W_StartOffset:w),out=(NewPar:w,NewLine:w,NewOffset:w)		cmpw NewPar,W_StartPar		bne @again					; if it's not the same line/paragraph, we want to try again, using									; the new line/paragraph.		cmpw NewLine,W_StartLine			beq DoSearch@again	moveword NewPar,W_StartPar		moveword NewLine,W_StartLine		moveword NewOffset,W_StartOffset		bra W_OpArr				; this should never inf loop; should stop at the bottom of the document.DoSearch		moveword W_StartPar,NewPar		moveword W_StartLine,NewLine		stz chgSize		rcall W_GetAddr,in=(NewPar:a,#0:x),out=(ptr:ax)		rcall W_WordBounds,in=(NewPar:a,W_StartOffset:x),out=(offset:y)		call W_GetBegLine,in=(NewPar:w,NewLine:w),out=(y:w)		deysearchloop				addword y,chgSize,y		iny		stz chgSize				 		lda [ptr],y		and #$FF		ckChange		cmp #W_Time+1		bge ckWord		asl a		tax		moveword SkipTable:x,chgSize 		brl searchloopitsSpace		brl searchloopckWord	jsl D_IsAlphaNum		bcc @inWord		cmp #'$'		beq @inWord		cmp #'%'		beq @inWord		cmp #'£'		beq @inWord		cmp #'¢'		beq @inWord		cmp #'¥'		beq @inWord		cmp #'€'		beq @inWord		bra itsSpace@inWord			rcall W_WordBounds,in=(NewPar:a,y:x)	; y = new offset.		cpy offset		bge gotit		dey		brl searchloopgotit	sty NewOffsetGoChar	call W_FindLine,in=(NewPar:w,NewOffset:w),out=(NewLine:w)UseNew	moveword NewPar,W_StartPar		moveword NewOffset,W_StartOffset		moveword NewLine,W_StartLine		jsl W_MakeCaret		brl RAExitDoHighRAExit		return		ENDP***************************************************************** LeftArrowW_WPLeftArrow	PROC		EXPORT		EXPORT	W_OpArr		input TaskRec:l		local NewOffset:w,NewPar:w,NewLine:w,ptr:l		local lastword:w,inword:w,offset:w,trailchange:w,char:w		local chgSize:w,lastchange:w,prevchar:w		begin		moveword [TaskRec]:#Omodifiers,a		bit #shiftKey		jne DoHigh		bit #optionKey		bne W_OpArr		bit #appleKey		bne AppArr		call W_BackChar,in=(W_StartPar:w,W_StartLine:w,W_StartOffset:w),out=(W_StartPar:w,W_StartLine:w,W_StartOffset:w)		jsl W_MakeCaret		brl RAExitAppArr		pha		pushword W_StartPar		pushword W_StartLine		jsl W_GetBegLine		pullword W_StartOffset		jsl W_MakeCaret		brl RAExitW_OpArr		;				call W_BackChar,in=(W_StartPar:w,W_StartLine:w,W_StartOffset:w),out=(NewPar:w,NewLine:w,NewOffset:w)		cmpw NewPar,W_StartPar		bne @again					; if it's not the same line/paragraph, we want to try again, using									; the new line/paragraph.		cmpw NewLine,W_StartLine			beq DoSearch@again	moveword NewPar,W_StartPar		moveword NewLine,W_StartLine		moveword NewOffset,W_StartOffset		bra W_OpArr				; this should never inf loop; should stop at the top of the document.DoSearch		moveword W_StartPar,NewPar		moveword W_StartLine,NewLine		moveword W_StartOffset,offset		stz lastChange			; this will be set before it can be used.		stz inword		stz trailchange		moveword #-1,chgSize	; counteract the initial ‘iny’ in the loop.				call W_GetBegLine,in=(NewPar:w,NewLine:w),out=(y:w)		sty lastword		dey		rcall W_GetAddr,in=(NewPar:a,#0:x),out=(ptr:ax)		; Loop throught the data in the paragraph, looking for your current position.		; Remember where the last word started.  Remember where the last change run started.		; If your word trails a change, use that position as your word start position.		ldy lastwordsearchloop				addword y,chgSize,y		iny		cpy offset		bge gotit		stz chgSize				 		lda [ptr],y		and #$FF		ckChange		cmp #W_Time+1		bge ckWord		asl a		tax		moveword SkipTable:x,chgSize 		lda trailChange		bne searchloop		sty lastChange		inc trailChange		brl searchloopitsSpace		stz trailchange		stz inword		brl searchloopckWord	ldx inword		bne itsSpace				jsl D_IsAlphaNum		bcc @inWord		cmp #'$'		beq @inWord		cmp #'%'		beq @inWord		cmp #'£'		beq @inWord		cmp #'¢'		beq @inWord		cmp #'¥'		beq @inWord		cmp #'€'		beq @inWord		bra itsSpace@inWord	phy				; Skip over the word.		rcall W_WordBounds,in=(NewPar:a,y:x)	; y = new offset.		dey		plx		; old offset				inc inword		lda trailchange		beq @off		stx lastword		stz trailchange		brl searchloop@off	stx lastword		brl searchloopgotit	moveword lastword,NewOffsetGoChar	call W_FindLine,in=(NewPar:w,NewOffset:w),out=(NewLine:w)UseNew	moveword NewPar,W_StartPar		moveword NewOffset,W_StartOffset		moveword NewLine,W_StartLine		jsl W_MakeCaret		brl RAExitDoHighRAExit		return		EXPORT SkipTable; These are the run sizes -1.SkipTable	DC.W	0,2,1,1,1,0,0,0;                     | | | | | | Time;					  | | | | | Date;					  | | | | Page #;					  | | | Color;					  | | Style;					  | Size;					  Font;		ENDP***************************************************************** UpArrowW_DoUpArrow	PROC		EXPORT		input TaskRec:l		local W_ParRec:l,NewPar:w,NewLine:w		begin		moveword [TaskRec]:#Omodifiers,a		and #$200		jne DoHigh		moveword [TaskRec]:#Omodifiers,a		and #$800		jne W_OpArr		moveword [TaskRec]:#Omodifiers,a		and #$100		bne AppArr		pha		pha		pha		pushword W_StartPar		pushword W_StartLine		pushword W_StartOffset		jsl W_GoUpLine		pullword W_StartOffset		pullword W_StartLine		pullword W_StartPar		jsl W_MakeCaret		brl RAExitAppArr		jsl W_MakeCaret		moveword W_TopLine,NewLine		lda W_TopPar		cmp #-1		bne GotTop		stz W_TopLine		lda #1GotTop		sta NewParGotNewPar		lda NewPar		jsl W_GetParRec		movelong ax,W_ParRec		moveword [W_ParRec]:#W_pAttr,a		and #W_PgBrk		beq ParOk		dec NewPar		lda NewPar		jsl W_GetParRec		movelong ax,W_ParRec		moveword [W_ParRec]:#W_pLastLine,a		dec a		sta NewLineParOk		pha		pushword W_StartPar		pushword W_StartLine		pushword W_StartOffset		pushword NewPar		pushword NewLine		jsl W_GetNewOffset		pullword W_StartOffset		cmpw NewLine,W_StartLine		bne IsNew		cmpw NewPar,W_StartPar		bne IsNew		cmp #1		bne DecIt		lda NewLine		beq IsNewDecIt		lda NewLine		beq DecPar		dec NewLine		bra ParOkDecPar		dec NewPar		lda NewPar		jsl W_GetParRec		movelong ax,W_ParRec		moveword [W_ParRec]:#W_pLastLine,a		dec a		sta NewLine		brl GotNewParIsNew		moveword NewPar,W_StartPar		moveword NewLine,W_StartLine		jsl W_MakeCaretW_OpArrDoHighRAExit		return		ENDP***************************************************************** DownArrowW_DoDownArrow	PROC		EXPORT		input TaskRec:l		local W_ParRec:l,NewPar:w,NewLine:w		begin		moveword [TaskRec]:#Omodifiers,a		and #$200		jne DoHigh		moveword [TaskRec]:#Omodifiers,a		and #$800		jne W_OpArr		moveword [TaskRec]:#Omodifiers,a		and #$100		bne AppArr		pha		pha		pha		pushword W_StartPar		pushword W_StartLine		pushword W_StartOffset		jsl W_GoDownLine		pullword W_StartOffset		pullword W_StartLine		pullword W_StartPar		jsl W_MakeCaret		brl RAExitAppArr		jsl W_MakeCaret		moveword W_BotLine,NewLine		lda W_BotPar		cmp #-1		bne NotBot		lda W_LastP		jsl W_GetParRec		movelong ax,W_ParRec		moveword [W_ParRec]:#W_pLastLine,a		dec a		sta NewLine		lda W_LastPNotBot		sta NewPar		jsl W_GetParRec		movelong ax,W_ParRec		moveword [W_ParRec]:#W_pAttr,a		and #W_PgBrk		beq ParOk		inc NewPar		stz NewLineParOk		pha		pushword W_StartPar		pushword W_StartLine		pushword W_StartOffset		pushword NewPar		pushword NewLine		jsl W_GetNewOffset		pullword W_StartOffset		moveword NewPar,W_StartPar		moveword NewLine,W_StartLine		jsl W_MakeCaretW_OpArrDoHighRAExit		return		ENDP****************************************************************W_GoUpLine	PROC		EXPORT		input par:w,Q_Line:w,W_offset:w		output Opar:w,OLine:w,OOffset:w		local W_ParRec:l		begin		moveword #W_TextHeader,OOffset		moveword par,OPar		lda Q_Line		beq AtTopPar		dec a		sta OLine		pha		pushword Opar		pushword Oline		pha		pushword par		pushword Q_Line		pushword W_offset		jsl W_GetHPos		jsl W_PixelToOffset		pullword OOffset		Brl GULExitAtTopPar		lda par		cmp #1		jeq GUlExit		sta OParPLoop		dec OPar		lda OPar		jsl W_GetParRec		movelong ax,W_ParRec		moveword [W_ParRec]:#W_pAttr,a		cmp #W_Picture		beq PLoop		cmp #W_PgBrk		beq PLoop		moveword [W_ParRec]:#W_pLastLine,a		dec a		sta OLine		pha		pushword Opar		pushword Oline		pha		pushword par		pushword Q_Line		pushword W_offset		jsl W_GetHPos		jsl W_PixelToOffset		pullword OOffsetGULExit		return		ENDP****************************************************************W_GoDownLine	PROC		EXPORT		input par:w,Q_Line:w,W_offset:w		output Opar:w,OLine:w,OOffset:w		local W_ParRec:l		begin		moveword par,OPar		jsl W_GetParRec		movelong ax,W_ParRec		pha		pushword par		pushword [W_ParRec]:#W_pLastLine		jsl W_GetBegLine		pullword OOffset		lda Q_Line		sta OLine		inc a		cmpw a,[W_ParRec]:#W_pLastLine		bcs AtBotPar		sta OLine		pha		pushword Opar		pushword Oline		pha		pushword par		pushword Q_Line		pushword W_offset		jsl W_GetHPos		jsl W_PixelToOffset		pullword OOffset		Brl GULExitAtBotPar		lda par		cmp W_LastP		jeq GUlExit		sta OParPLoop		inc OPar		lda OPar		jsl W_GetParRec		movelong ax,W_ParRec		moveword [W_ParRec]:#W_pAttr,a		cmp #W_Picture		beq PLoop		cmp #W_PgBrk		beq PLoop		stz OLine		pha		pushword Opar		pushword Oline		pha		pushword par		pushword Q_Line		pushword W_offset		jsl W_GetHPos		jsl W_PixelToOffset		pullword OOffsetGULExit		return		ENDP****************************************************************W_GetNewOffset	PROC		EXPORT		input par:w,Q_Line:w,W_offset:w,OPar:w,OLine:w		output OOffset:w		local W_ParRec:l		begin		moveword #W_TextHeader,OOffset		pha		pushword Opar		pushword Oline		pha		pushword par		pushword Q_Line		pushword W_offset		jsl W_GetHPos		jsl W_PixelToOffset		pullword OOffset		return		ENDP***************************************************************** W_CalcFBytes(FontId,color,FontID,color):bytesW_CalcFBytes	PROC		EXPORT		input FontID1:l,color1:w,FontID2:l,color2:w		output bytes:w		begin		stz bytes		cmpw FontId1,FontID2		beq SameFont		moveword #3,bytesSameFont		cmpb FontId1+2,FontId2+2		beq SameStyle		addword #2,bytes,bytesSameStyle		cmpb FontId1+3,FontId2+3		beq SameSize		addword #2,bytes,bytesSameSize		cmpb color1,color2		beq SameColor		addword #2,bytes,bytesSameColor		return		ENDP***************************************************************** W_WriteFBytes(ptr:l,FontId,color,FontID,color):bytesW_WriteFBytes	PROC		EXPORT		input ptr:l,FontID1:l,color1:w,FontID2:l,color2:w		begin		cmpw FontId1,FontID2		beq SameFont		moveword #1,[ptr]		moveword FontId2,[ptr]:#1		addlong #3,ptr,ptrSameFont		cmpb FontId1+2,FontId2+2		beq SameStyle		lda FontId2+1			;2 is in the high		shortm		lda #2				   ;flag is in the low		longm		sta [ptr]		addlong #2,ptr,ptrSameStyle		cmpb FontId1+3,FontId2+3		beq SameSize		lda FontId2+2			;3 is in the high		shortm		lda #3				   ;flag is in the low		longm		sta [ptr]		addlong #2,ptr,ptrSameSize		cmpb color1,color2		beq SameColor		lda color2-1			;2 is in the high		shortm		lda #4				   ;flag is in the low		longm		sta [ptr]SameColor		return		ENDP***************************************************************** W_WriteFBytes2(par:w,W_offset:w,FontId,color,FontID,color):bytesW_WriteFBytes2	PROC		EXPORT		EXPORT	W_WriteFBytesNB		EXPORT	W_WriteFBytesNE		lda #0		sta 4+6+6+2+2,s		  ;sorry guys, storing in the output		brl WFBGutsW_WriteFBytesNB		;				lda #-1		sta 4+6+6+2+2,s		  ;sorry guys, storing in the output		brl WFBGutsW_WriteFBytesNE		;				lda #1		sta 4+6+6+2+2,s		  ;sorry guys, storing in the outputWFBGuts		input par:w,W_offset:w,FontID1:l,color1:w,FontID2:l,color2:w		output bytes:w		local CheckEnd:w,fbytes:w,ptr:l		begin		moveword bytes,CheckEnd		stz bytes		pha		pushlong FontID1		pushword color1		pushlong FontID2		pushword color2		jsl W_CalcFBytes		pullword fbytes		lda CheckEnd		bmi NotBeg		lda W_offset		cmp #W_TextHeader		bne NotBeg		rcall W_GetAddr,in=(par:a,#0:x),out=(ptr:ax)		movelong FontID2,[ptr]		moveword color2,[ptr]:#4		bra AbortNotBeg		lda CheckEnd		cmp #1		beq NormalWF		addword W_offset,fbytes,x		rcall W_GetAddr,in=(par:a),out=(ptr:ax)		cmpb [ptr],#cr		bne NormalWFAbort	moveword fbytes,bytes		pushword par		pushword W_offset		pushword bytes		jsl W_LessRoom		brl SameColorNormalWF		lda par		ldx W_offset		jsl W_GetAddr		movelong ax,ptr		cmpw FontId1,FontID2		beq SameFont		moveword #1,[ptr]		moveword FontId2,[ptr]:#1		addlong #3,ptr,ptrSameFont		cmpb FontId1+2,FontId2+2		beq SameStyle		lda FontId2+1			;2 is in the high		shortm		lda #2				   ;flag is in the low		longm		sta [ptr]		addlong #2,ptr,ptrSameStyle		cmpb FontId1+3,FontId2+3		beq SameSize		lda FontId2+2			;3 is in the high		shortm		lda #3				   ;flag is in the low		longm		sta [ptr]		addlong #2,ptr,ptrSameSize		cmpb color1,color2		beq SameColor		lda color2-1			;2 is in the high		shortm		lda #4				   ;flag is in the low		longm		sta [ptr]SameColor		return		ENDP***************************************************************** W_JunkLeft (par:w,Q_Line:w,W_offset:w):W_offsetW_JunkLeft	PROC		EXPORT		input par:w,Q_Line:w,W_offset:w		output OOffset:w		local ChrPtr:l,LinePtr:l		begin		moveword W_offset,OOffset		cmp #W_TextHeader		jeq NoFind		spacelong		pushword par		pushword Q_Line		jsl W_GetLRecPtr		pullLong LinePtr		moveword [linePtr]:#W_lOffset,OOffset		lda par		ldx #0		jsl W_GetAddr		movelong ax,ChrPtr		ldy OOffset		shortmLoop		cpy W_offset		jcs NoFind		lda [ChrPtr],y		cmp #sp		bcs GotOne						xba		lda #0		xba		asl a		tax		jmp (ChrTable,x)ChrTable	DC.W	0,Skip3						;0,1			DC.W	Skip2,Skip2					;2,3			DC.W	Skip2,GotOne				;4,5			DC.W	GotOne,GotOne				;6,7			DC.W	0,GotOne					;8,9			DC.W	0,0							;a,b			DC.W	0,Skip1						;c,dSkip3	inySkip2	inySkip1	iny		bra LoopGotOne		iny		sty OOffset		bra LoopNoFind	longm		return		ENDP***************************************************************** W_JunkRight (par:w,Q_Line:w,W_offset:w):W_offsetW_JunkRight	PROC		EXPORT		input par:w,Q_Line:w,W_offset:w		output NewOffset:w		begin		pha		pushword par		pushword W_offset		jsl W_GetFirstChar		pla		sta NewOffsetJRExit		return		ENDP;	****************************************************************;	* W_GetNWLeft(par,W_offset):W_offset;	W_GetNWLeft	PROC		EXPORT;	;			input par:w,W_offset:w;			output OOffset:w;			local ChrPtr:l;			begin;	;			moveword #W_TextHeader,OOffset;			cmp W_offset;			bge GotO;			moveword W_offset,OOffset;	;	GotO	rcall W_GetAddr,in=(par:a,Ooffset:x),out=(ChrPtr:ax);	;			ldy #0;			shortm;	Loop	lda [ChrPtr],y;			cmp #sp;			beq Skip1;			bge GotOne;	;			xba;			lda #0;			xba;			asl a;			tax;			jmp (ChrTable,x);	;	ChrTable	DC.W	0,Skip3							;0,1;				DC.W	Skip2,Skip2						;2,3;				DC.W	Skip2,GotOne					;4,5;				DC.W	GotOne,GotOne					;6,7;				DC.W	0,Skip1							;8,9;				DC.W	0,0								;a,b;				DC.W	0,GotOne						;c,d;	;	Skip3	iny;	Skip2	iny;	Skip1	iny;			bra Loop;	;	GotOne	longm;			tya;			clc;			adc OOffset;			sta OOffset;	;	NoFind	longm;			return;	;			ENDP		END