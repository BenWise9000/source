;--------------------------------------------------------------------------;;       m16.MSL;;;;---------------------------------------------------------------------------;; WaitMouse;;        Wait for a click MACRO&lab     WaitMouse&lab	; ~b&SYSINDEX pha         pushword #0         _Button         pla         beq ~b&SYSINDEX~c&SYSINDEX pha          pushword #0         _Button         pla         bne ~c&SYSINDEX MEND;---------------------------------------------------------------------------;; Break; MACRO&lab    Break &param&lab	; 		IF	&nbr(&syslist) GOTO .gotone		        macerr 'Break macro: no input parameter specified.'        mexit.gotone        lda >$00C025		IF	(&param='cap') GOTO .gotcaps		IF	(&param='caps') GOTO .gotcaps		IF	(&param='capslock') GOTO .gotcaps		IF	(&param='opt') GOTO .gotopt		IF	(&param='option') GOTO .gotopt		IF	(&param='closedapple') GOTO .gotopt		IF	(&param='fan') GOTO .gotfan		IF	(&param='apple') GOTO .gotfan		IF	(&param='cmd') GOTO .gotfan		IF	(&param='openapple') GOTO .gotfan		IF	(&param='shift') GOTO .gotshift		IF	(&param='ctl') GOTO .gotctl		IF	(&param='control') GOTO .gotctl		IF	(&param='ctrl') GOTO .gotctl		IF	(&param='cntl') GOTO .gotctl		IF	(&param='cntrl') GOTO .gotctl        macerr 'Break macro: unable to decipher parameter.'.gotcaps        and #%00000100		GOTO .didit.gotopt        and #%01000000		GOTO .didit.gotfan        and #%10000000		GOTO .didit.gotshift        and #%00000001		GOTO .didit.gotctl        and #%00000010.didit        beq ~b&SYSINDEX        brk~b&SYSINDEX	;  MEND;---------------------------------------------------------------------------;; IsNil;;       see if a longword is zero MACRO&lab     IsNil &param&lab     lda &param         ora &param+2 MEND;---------------------------------------------------------------------------;; SetBorder <colour>;;        set the border colour MACRO&lab     SetBorder &param&lab     lda >$E0C034		IF	&nbr(&syslist) GOTO .setit         and #$000F         inc a         and #$000F         pha         lda >$E0C034         and #$FFF0         ora 1,s         sta >$E0C034         pla		GOTO .exit.setit   anop         and #$FFF0         ora &param         sta >$E0C034.exit    anop MEND MACRO&lab	GetBorder	&arg&lab	lda		>$e0c034		and		#$f		sta		&arg MEND;---------------------------------------------------------------------------;; WaitKey <key>;;       Wait for any key or for a specific key; MACRO&lab     WaitKey &param&lab	; ~b&SYSINDEX lda >$C000         and #$80         beq ~b&SYSINDEX		IF	&nbr(&syslist) GOTO .specfic         sta >$C010		GOTO .exit.specfic anop         lda >$C000         sta >$C010         and #$7F         cmp &param         bne ~b&SYSINDEX.exit    anop MEND;---------------------------------------------------------------------------;; Click;;       click the speaker MACRO&lab    Click&lab    lda >$00C030 MEND;---------------------------------------------------------------------------;; SetVol;; MACRO&lab SetVol &param&lab lda >$00C03C     and #$FFF0     ora &param     sta >$00C03C MEND;---------------------------------------------------------------------------;; RCall - register Call;;        MACRO&lab    RCall &routine,&in,&out&lab	;         lcla &outnum        lcla &innum        lcla &count        lclc &inreg        lclc &outreg        lclc &inp        lclc &outp        lclc &reg&innum  seta &nbr(&in)&outnum seta &nbr(&out)		IF ((&innum = 0) and (&in ­ '')) or ((&outnum = 0) and (&out ­ '')) THEN			macerr 'RCall macro: all parameters to this macro must be in parentheses.'			mexit		ENDIF&count  seta 1		IF	&innum=0 GOTO .call		IF	&innum<4 GOTO .inloop        macerr 'RCall macro: too many inputs (3 maximum)'        mexit.inloop&inreg  setc &substr(&in[&count],&len(&in[&count])-2,3)		IF	(&inreg­':ax') and (&inreg­':xy') and (&inreg­':ay') GOTO .in2&reg    setc &substr(&in[&count],&len(&in[&count])-1,2)&inp    setc &substr(&in[&count],1,&len(&in[&count])-3)        movelong &inp,&reg		GOTO .incont.in2&inreg  setc &substr(&in[&count],&len(&in[&count])-1,2)		IF	(&inreg­':a') and (&inreg­':x') and (&inreg­':y') GOTO .inerr&reg    setc &substr(&in[&count],&len(&in[&count]),1)&inp    setc &substr(&in[&count],1,&len(&in[&count])-2)        moveword &inp,&reg		GOTO .incont.inerr		macerr "RCall macro: missing input register specification"        mexit.incont&count  seta &count+1		IF	&count²&innum GOTO .inloop.call        jsl &routine&count  seta 1		IF	&outnum=0 GOTO .exit		IF	&outnum<4 GOTO .outloop        macerr 'RCall macro: too many outputs (3 maximum)'		GOTO .exit.outloop&outreg setc &substr(&out[&count],&len(&out[&count])-2,3)		IF	(&outreg­':ax') and (&outreg­':xy') and (&outreg­':ay') GOTO .out2&reg    setc &substr(&out[&count],&len(&out[&count])-1,2)&outp   setc &substr(&out[&count],1,&len(&out[&count])-3)        movelong &reg,&outp		GOTO .outcont.out2&outreg setc &substr(&out[&count],&len(&out[&count])-1,2)		IF	(&outreg­':a') and (&outreg­':x') and (&outreg­':y') GOTO .outerr&reg    setc &substr(&out[&count],&len(&out[&count]),1)&outp   setc &substr(&out[&count],1,&len(&out[&count])-2)        moveword &reg,&outp		GOTO .outcont.outerr        macerr 'RCall macro: missing output register specification'        mexit.outcont&count  seta &count+1		IF	&count²&outnum GOTO .outloop.exit   anop        MEND;---------------------------------------------------------------------------;;       ABS;;        MACRO&lab    ABS &op&lab	; 		IF	&nbr(&syslist) GOTO .getop.aop        tax		GOTO .gotop.getop		IF	(&op='a') GOTO .aop        moveword &op,a.gotop        bpl ~b&SYSINDEX        dec a           ; NEG        eor #$FFFF		IF	&nbr(&syslist) GOTO .putop		GOTO .exit.putop        moveword a,&op.exit~b&SYSINDEX	;         MEND;---------------------------------------------------------------------------;;       NEG;;        MACRO&lab    NEG &op&lab	; 		IF	&nbr(&syslist) GOTO .getop		GOTO .gotop.getop		IF	(&op='a') GOTO .gotop        moveword &op,a.gotop        dec a        eor #$FFFF      ; NOT		IF	&nbr(&syslist) GOTO .putop		GOTO .exit.putop        moveword a,&op.exit        MEND;---------------------------------------------------------------------------;;       Not;;        MACRO&lab    NOT &op&lab	; 		IF	&nbr(&syslist) GOTO .getop		GOTO .geta.getop		IF	(&op='a') GOTO .gotop        moveword &op,a		GOTO .gotop.geta        tay.gotop        beq ~b&SYSINDEX        lda #0        bra ~c&SYSINDEX~b&SYSINDEX	;         lda #1~c&SYSINDEX	; 		IF	&nbr(&syslist) GOTO .putop		GOTO .exit.putop        moveword a,&op.exit        MEND;---------------------------------------------------------------------------;;       BNot;;        MACRO&lab    BNOT &op&lab	; 		IF	&nbr(&syslist) GOTO .getop		GOTO .gotop.getop		IF	(&op='a') GOTO .gotop        moveword &op,a.gotop        eor #$FFFF		IF	&nbr(&syslist) GOTO .putop		GOTO .exit.putop        moveword a,&op.exit        MEND;---------------------------------------------------------------------------;;       Swap;; MACRO&lab    Swap &param1,&param2&lab    moveword &param1,x        moveword &param2,&param1        moveword x,&param2 MEND;---------------------------------------------------------------------------;;       SwapL;; MACRO&lab    SwapL &param1,&param2&lab    pushlong &param1        movelong &param2,&param1        pulllong &param2 MEND;---------------------------------------------------------------------------;;       dbg	- bizarre debugging method using WDM statements...;		;        MACRO&lab    dbg &num&lab 	;	DC.B	$42, &num        MEND;----------------------------------------------------------------------            MACRO&lab        Mull4 &op&lab        clc            rol &op            rol &op+2            clc            rol &op            rol &op+2            MEND			MACRO			MacErr						lclc &msg			lcla &num			lcla &count			&num		seta &nbr(&syslist)			IF (&num = 0) THEN				mexit			ENDIF&msg	setc ''&count		seta 1			WHILE (&count ² &num) DO				IF (&substr(&syslist[&count],1,1) = '"') or (&substr(&syslist[&count],1,1) = '''') THEN&msg				setc &concat(&msg,&substr(&syslist[&count],2,&len(&syslist[&count])-2))				ELSE&msg				setc &concat(&msg,&syslist[&count])				ENDIF&count			seta &count+1			ENDWHILE&msg		setc &concat(&msg,'  Proc: ')&msg		setc &concat(&msg,&sysmod)			aerror &msg						MEND