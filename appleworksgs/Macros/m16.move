; M16.MOVE	ÑConverted APW macros;---------------------------------------------------------------------------;           Move a word as a fixedpoint;            MACRO&lab        MoveFixWord &from,&to            stz &to            moveword &from,&to+2            MEND;--------------------------------------------------------------------------;           Move a 3 byte address;            MACRO&lab        MoveAddr &from,&to            lclc &char            lclc &newfrom	&char       setc &substr(&from,1,1)		IF	&char­'#' GOTO .normal&newfrom 	setc &substr(&from,2,&len(&from)-1)            moveword #<&newfrom,&to            moveword #>&newfrom,&to+1            mexit.normal            moveword &from,&to            moveword &from+1,&to+1            MEND;.........................................................................;            MACRO&lab        MoveX     &from,&to&lab	;             lclc      &char            lclc      &from1            lclc      &to1            lclc      &from2            lclc      &to2&from1      setc      &concat(&from,'+4')&to1        setc      &concat(&to,'+4')&from2      setc      &concat(&from,'+8')&to2        setc      &concat(&to,'+8')&char       setc &substr(&from,&len(&from),1)		IF	&char­']' GOTO .chk2&from1      setc      &concat(&from,':#4')&from2      setc      &concat(&from,':#8').chk2&char       setc &substr(&to,&len(&to),1)		IF	&char­']' GOTO .domove&to1        setc      &concat(&to,':#4')&to2        setc      &concat(&to,':#8').domove            movelong  &from,&to            movelong  &from1,&to1            moveword  &from2,&to2            MEND;.........................................................................;              MACRO&lab          moverect  &from,&to&lab	;               lclc      &char              lclc      &from1              lclc      &to1&from1        setc      &concat(&from,'+4')&to1          setc      &concat(&to,'+4')&char         setc &substr(&from,&len(&from),1)		IF	&char­']' GOTO .chk2&from1        setc      &concat(&from,':#4').chk2&char         setc &substr(&to,&len(&to),1)		IF	&char­']' GOTO .domove&to1          setc      &concat(&to,':#4').domove              movelong  &from,&to              movelong  &from1,&to1              MEND;.........................................................................;              MACRO&lab          movel     &from,&to&lab	;               movelong  &from,&to              MEND              MACRO&lab          movew     &from,&to&lab	;               moveword  &from,&to              MEND              MACRO&lab          moveb     &from,&to&lab	;               movebyte  &from,&to              MEND			  MACRO&lab		  mover		&from,&to&lab			  MoveRect	&from,&to			  MEND;.........................................................................;           MACRO&lab       Movebyte  &from,&to&lab			lclc	&newfrom			lcla	&ppos&newfrom	setc	&from&ppos		seta	&pos('.',&newfrom)			IF &ppos=0 GOTO .noeval			eval &newfrom&newfrom	setc 'a'.noeval			shortm			MoveWord  &newfrom,&to			longm           MEND;.........................................................................;           MACRO&lab       MoveLong  &from,&to&lab	; 		   lclc	&newfrom&newfrom	setc	&from		IF &newfrom­'?' GOTO .notfromdc&newfrom	setc	'ax'.notfromdc		IF	&len(&newfrom)­&len(&to) GOTO .doreally           lcla  &xxp&xxp       seta &pos(&to,&newfrom)		IF	not (&xxp) GOTO .doreally           mexit.doreally		IF	&newfrom­'s' GOTO .SCont1           pulllong &to           mexit.SCont1		IF	&to­'s' GOTO .SCont2           pushlong &newfrom           mexit.SCont2           lclc  &ldreg           lclc  &char2           lclc  &foo&foo       setc &substr(&newfrom,&len(&newfrom),1)&char2     setc &substr(&newfrom,1,1)		IF	(&to='ax') GOTO .dorpax		IF	(&to='ay') GOTO .dorpay		IF	(&to='xy') GOTO .dorpxy		GOTO .doreally2.dorpax		IF	(&newfrom='xy') GOTO .doxy2ax		IF	(&newfrom='ay') GOTO .doay2ax		GOTO .dorpax2.doxy2ax			txa.doay2ax			tyx			mexit		.dorpax2&ldreg     setc 'x'		IF	(&char2­'[') GOTO .normax		IF	(&foo­']') GOTO .zpoffax           moveword &newfrom:#2,x           moveword &newfrom,a           mexit.zpoffax		   moveword &newfrom+2,x		   moveword	&newfrom,a		   mexit.normax           moveword &newfrom,a		IF	&char2='#' GOTO .dorpimm		GOTO .dorpadd.dorpay		IF	(&newfrom='xy') GOTO .doxy2ay		IF	(&newfrom='ax') GOTO .doax2ay		GOTO .dorpay2.doxy2ay			txa			mexit.doax2ay				txy			mexit		.dorpay2&ldreg     setc 'y'		IF	(&char2­'[') GOTO .normay		IF	(&foo­']') GOTO .zpoffay           moveword &newfrom:#2,x           moveword &newfrom,a           txy           mexit.zpoffay           moveword &newfrom+2,x           moveword &newfrom,a           txy           mexit.normay		IF	(&foo­']') GOTO .normxy           moveword &newfrom,x           moveword &newfrom:#2,a           tay           mexit.normxy           moveword &newfrom,a		IF	&char2='#' GOTO .dorpimm		GOTO .dorpadd.dorpxy		IF	(&newfrom='ax') GOTO .doax2xy		IF	(&newfrom='ay') GOTO .doay2xy		GOTO .dorpxy2.doax2xy		txy.doay2xy		tax		mexit		.dorpxy2&ldreg     setc 'y'		IF	(&char2­'[') OR (&foo=']') GOTO .normxy           lcla &foffset&foffset   seta &pos(':',&newfrom)&char2     setc &substr(&newfrom,1,&foffset-1)           moveword &newfrom,a		   tax		   iny		   iny		   lda &char2,y		   tay		   mexit.normxy           moveword &newfrom,x		IF	&char2='#' GOTO .dorpimm.dorpadd		IF	(&foo=']') GOTO .indexed           moveword &newfrom+2,&ldreg           mexit.indexed           moveword &newfrom:#2,&ldreg           mexit.dorpimm&char2     setc &substr(&newfrom,2,&len(&newfrom)-1)           ld&ldreg #^&char2           mexit.doreally2           lcla  &ypushed           lcla  &xpushed           lcla  &sameoff           lcla  &yinced           lcla  &yhas2           lclc  &streg           lclc  &fdisp           lclc  &tdisp           lclc  &floc           lclc  &tloc           lclc  &char           lclc  &fchar           lclc  &tchar           lclc  &newto           lcla  &foffset           lcla  &toffset           lcla  &num&fchar     setc &substr(&newfrom,1,1)&tchar     setc &substr(&to,1,1)&foffset   seta &pos(':',&newfrom)&toffset   seta &pos(':',&to)&fdisp     setc  '*'&tdisp     setc  '*'		IF	&foffset=0 GOTO .nofoff&floc      setc &substr(&newfrom,1,&foffset-1)&fdisp     setc &substr(&newfrom,&foffset+1,&len(&newfrom)-&foffset).nofoff		IF	&toffset=0 GOTO .notoff&tloc      setc &substr(&to,1,&toffset-1)&tdisp     setc &substr(&to,&toffset+1,&len(&to)-&toffset).notoff		IF	not (&foffset and &toffset) GOTO .notsame&num       seta &pos(&tdisp,&fdisp)		IF	&num=0 GOTO .notsame		IF	&len(&fdisp)­&len(&tdisp) GOTO .notsame		IF	(&tchar='[') and (&fchar­'[') GOTO .notsame		IF	(&fchar='[') and (&tchar­'[') GOTO .notsame&sameoff   seta  1.notsame; FOO!		IF	(&newfrom='ax') or (&newfrom='ay') GOTO .regmove		IF	(&newfrom='xy') GOTO .regmoveflip		GOTO .domw.regmove		lclc &newfrom2&newfrom2   setc 'a'&num       seta 0		IF	&newfrom='ax' GOTO .didy&num       seta &pos(']:',&to)		IF	&num=0 GOTO .didy           phy.didy           moveword &newfrom2,&to&newfrom2   setc &substr(&newfrom,2,1)&tchar     setc &substr(&to,&len(&to),1)		IF	&tchar­']' GOTO .normregmove           moveword &newfrom2,&to:#2           mexit.normregmove		IF	&num=0 GOTO .doney           pla           iny           iny&num       seta &pos(']:',&to)&newto     setc &substr(&to,1,&num)&newto     setc &concat(&newto,',y')           sta &newto           mexit.doney           moveword &newfrom2,&to+2           mexit		   .regmoveflip		lclc &newfrom2&newfrom   setc 'y'&tchar     setc &substr(&to,&len(&to),1)&num       seta &pos(']:',&to)		IF	&num=0 GOTO .noy           phy&newfrom2   setc 'x'		GOTO .didy.noy		IF	&tchar­']' GOTO .normregmove2           moveword &newfrom,&to:#2		GOTO .movefirstreg.normregmove2           moveword &newfrom,&to+2.movefirstreg&newfrom   setc 'x'           moveword &newfrom,&to           mexit.domw		IF	(&foffset=0) or (&toffset=0) GOTO .nosave		IF	(&tdisp='x') or (&tdisp='y') or (&tdisp='s') GOTO .nosave		IF	(&fdisp='y') and (&tchar='[') GOTO .savey		IF	(&fdisp='x') and (&tchar­'#') and (&tchar­'[') GOTO .savex		GOTO .nosave.savey           phy&ypushed   seta  1		GOTO .nosave.savex           phx&xpushed   seta  1.nosave           MoveWord  &newfrom,&to		IF	&ypushed GOTO .gety		IF	&xpushed GOTO .getx		GOTO .dohigh.gety           ply&ypushed   seta  0		GOTO .dohigh.getx           plx&xpushed   seta  0.dohigh&streg     setc  'a'		IF	&foffset GOTO .fromoff		IF	&fchar='[' GOTO .fromzp		IF	&fchar='!' GOTO .fromlocal		IF	&fchar='#' GOTO .fromimm		IF	&newfrom='ax' GOTO .fromxhigh		IF	(&newfrom='ay') or (&newfrom='xy') GOTO .fromyhigh           lda   &newfrom+2		GOTO .doto.fromyhigh&streg    setc  'y'		GOTO .doto.fromxhigh&streg    setc  'x'		GOTO .doto.fromlocal           lda   #0		GOTO .doto.fromimm&newfrom   setc &substr(&newfrom,2,&len(&newfrom)-1)           lda   #^&newfrom		GOTO .doto.fromzp		IF	&toffset=0 GOTO .fromzpnophy		IF	&tdisp­'y' GOTO .fromzpnophy           phy&ypushed   seta  1.fromzpnophy           ldy   #2           lda   &newfrom,y&yhas2     seta  1		GOTO .doto.fromoff		IF	&fdisp='y' GOTO .fromy		IF	&fchar='[' GOTO .fromzpoff		IF	&fdisp='x' GOTO .fromx		IF	&fdisp='s' GOTO .froms		IF	(&toffset=0) or (&tchar='[') GOTO .nollx		IF	(&tdisp='y') or (&tdisp='s') GOTO .nollx		IF	&sameoff GOTO .nollx           ldx   &fdisp.nollx           lda   &floc+2,x		GOTO .doto.fromzpoff		IF	&tdisp­'y' GOTO .fromzpoffldy           phy&ypushed   seta  1.fromzpoffldy&char      setc &substr(&fdisp,1,1)		IF	&char='#' GOTO .xxximmzp		IF	&toffset=0 GOTO .fzponoldy		IF	&sameoff GOTO .fzponoldy		IF	(&tdisp='y') or (&tchar='[') GOTO .fzpoldy		GOTO .fzponoldy.fzpoldy           ldy   &fdisp.fzponoldy           iny           iny		GOTO .doxxximmzp.xxximmzp             ldy   &fdisp+2.doxxximmzp           lda   &floc,y		GOTO .doto.froms           lda   &floc+2,s		GOTO .doto.fromy		IF	&fchar='[' GOTO .fromyzp           lda   &floc+2,y		GOTO .doto.fromyzp           iny           iny&yinced    seta  1           lda   &floc,y		GOTO .doto.fromx           lda   &floc+2,x		GOTO .doto.doto		IF	&toffset GOTO .tooff		IF	&tchar='[' GOTO .tozp		IF	&tchar='#' GOTO .toimm           st&streg  &to+2           mexit.toimm&newto     setc &substr(&to,2,&len(&to)-1)           st&streg  #^&newto           mexit.tozp		IF	&yhas2 GOTO .tozpnoload           ldy   #2.tozpnoload           st&streg  &to,y           mexit.tooff		IF	&tdisp='x' GOTO .tox		IF	&tdisp='y' GOTO .toy		IF	&tdisp='s' GOTO .tos		IF	&tchar='[' GOTO .tozpoff		IF	(&fchar='[') or (&sameoff) or (&foffset=0) GOTO .noloadx		IF	(&fdisp='s') or (&fdisp='y') GOTO .noloadx           ldx   &tdisp.noloadx           st&streg  &tloc+2,x           mexit.tozpoff		IF	&sameoff GOTO .noloady&char      setc &substr(&tdisp,1,1)		IF	&char='#' GOTO .tozpoffimm		IF	(&fchar='[') or (&fdisp='y') GOTO .xdoldyx		IF	&foffset=0 GOTO .xnoldyx		GOTO .xnoldyx.xdoldyx           ldy   &tdisp.xnoldyx           iny           iny		GOTO .noloady.tozpoffimm           ldy   &tdisp+2.noloady           st&streg  &tloc,y           mexit.tos           st&streg  &tloc+2,s           mexit.toy		IF	&tchar='[' GOTO .toyzp		IF	not (&ypushed) GOTO .toydo           ply.toydo		IF	(&fchar='[') and (&fdisp='y') GOTO .specialy           st&streg &tloc+2,y           mexit.specialy           st&streg &tloc,y           mexit.toyzp		IF	&yinced GOTO .toyzpdo		IF	not (&ypushed) GOTO .toypush           ply.toypush           iny           iny.toyzpdo           st&streg  &tloc,y           mexit.tox		IF	not (&xpushed) GOTO .toxdo           plx.toxdo           st&streg  &tloc+2,x           mend;.........................................................................;           MACRO&lab       MoveWord  &from,&to&lab	; 		IF	&from­&to GOTO .doreally			mexit		.doreally		lclc	&newfrom		lcla	&ppos&newfrom	setc &from&ppos	seta	&pos('.',&newfrom)		IF &ppos=0 GOTO .noeval		eval &newfrom&newfrom	setc 'a'.noeval			IF	&newfrom­'s' GOTO .SCont1           pullword &to           mexit.SCont1		IF	&to­'s' GOTO .SCont2           pushword &newfrom           mexit.SCont2           lcla  &sameoff           lcla  &nox2           lcla  &noy2           lclc  &streg           lclc  &fdisp           lclc  &tdisp           lclc  &floc           lclc  &tloc           lcla  &foffset           lcla  &toffset           lclc  &fchar           lclc  &tchar           lcla  &num           lclc  &trans&fchar     setc &substr(&newfrom,1,1)&tchar     setc &substr(&to,1,1)&foffset   seta &pos(':',&newfrom)&toffset   seta &pos(':',&to)		IF	&foffset=0 GOTO .nofoff&floc      setc &substr(&newfrom,1,&foffset-1)&fdisp     setc &substr(&newfrom,&foffset+1,&len(&newfrom)-&foffset).nofoff		IF	&toffset GOTO .gettoff		GOTO .setnox2.gettoff&tloc      setc &substr(&to,1,&toffset-1)&tdisp     setc &substr(&to,&toffset+1,&len(&to)-&toffset)		IF	(&tdisp='s') or (&tdisp='y') or (&tchar='[') GOTO .setnox2		GOTO .setnoy2.setnox2&nox2      seta  1		IF	(&tdisp='y') GOTO .notoff.setnoy2&noy2      seta  1.notoff		IF	not (&foffset and &toffset) GOTO .notsame&num       seta &pos(&tdisp,&fdisp)		IF	&num=0 GOTO .notsame		IF	&len(&fdisp)­&len(&tdisp) GOTO .notsame		IF	(&tchar='[') and (&fchar­'[') GOTO .notsame		IF	(&fchar='[') and (&tchar­'[') GOTO .notsame&sameoff   seta  1.notsame&streg     setc  'a'		IF	&foffset GOTO .fromoff		IF	(&newfrom='a') or (&newfrom='x') or (&newfrom='y') GOTO .fromreg		IF	(&fchar='[') GOTO .fromlda		IF	(&fchar='!') GOTO .fromlocal		IF	(&to='x') or (&to='y') GOTO .fromtoreg.fromlda		IF &fchar='#' AND &pos(&substr(&newfrom,2,1),'<^>')=0 THEN			lda		#<&substr(&newfrom,2,&len(&newfrom)-1)		ELSE			lda		&newfrom		ENDIF		GOTO .doto.fromlocal&floc      setc &substr(&newfrom,2,&len(&newfrom)-1)           tdc           clc           adc   #&floc		GOTO .doto.fromreg&streg     setc  &newfrom		GOTO .doto.fromtoreg		IF (&to='x') THEN			ldx &newfrom		ELSE			ldy &newfrom		ENDIF        MEXIT.fromoff		IF	(&fdisp='x') or (&fdisp='y') or (&fdisp='s') GOTO .foffreg		IF	&fchar='[' GOTO .fromoffzp		IF	(&nox2) GOTO .dofromoff		IF	not (&tdisp='x') GOTO .dofromoff           phx.dofromoff           ldx   &fdisp           lda   &concat(&floc,',x')		IF	&nox2 GOTO .doto		IF	not (&tdisp='x') GOTO .doto           plx		GOTO .doto.fromoffzp		IF	&noy2 GOTO .dofromoffzp           phy.dofromoffzp           ldy   &fdisp           lda   &concat(&floc,',y')		IF	&noy2 GOTO .doto           ply		GOTO .doto.foffreg           lda   &concat(&floc,',',&fdisp).doto		IF	(&to='a') or (&to='x') or (&to='y') GOTO .dotoreg           lclc &foo&foo       setc &substr(&to,1,1)		IF	(&foo­'[') or (&streg='a') GOTO .notfoo&trans     setc  &concat('t',&streg,'a')           &trans&streg     setc 'a'.notfoo		IF	&toffset GOTO .tooff           st&streg  &to           mexit.dotoreg		IF	(&newfrom=&to) GOTO .dotoregend		IF	(&newfrom='a') or (&newfrom='x') or (&newfrom='y') GOTO .dotoreg2		IF	(&to='a') GOTO .dotoregend&fdisp		setc  'a'			GOTO .dotoreg2really.dotoreg2&fdisp		setc &newfrom.dotoreg2really&trans     setc  &concat('t',&fdisp,&to)           &trans.dotoregend           mexit.tooff		IF	(&tdisp='x') or (&tdisp='y') or (&tdisp='s') GOTO .dotooff		IF	&tchar='[' GOTO .tooffzp		IF	&sameoff GOTO .noloadx           ldx   &tdisp.noloadx           st&streg  &concat(&tloc,',x')           mexit.tooffzp		IF	&sameoff GOTO .noloady           ldy   &tdisp.noloady           st&streg  &concat(&tloc,',y')           mexit.dotooff           st&streg  &concat(&tloc,',',&tdisp)           mend;..............................................................................;;          Store zero long - stzl;;    Stzl addr     Stzl addr:x    Stzl addr:offset    Stzl addr:#offset      ;;    This macro will do a store zero on both the high and low bytes of a;    long word.;.............................................................................. MACRO&lab stzl &loc&lab	;  lcla &offset lclc &rest lclc &disp&offset seta &pos(':',&loc)		IF	&offset>2 GOTO .dooff stz &loc stz &loc+2 mexit.dooff&rest setc &substr(&loc,1,&offset-1)&disp setc &substr(&loc,&offset+1,&len(&loc)-&offset)		IF	&disp='x' GOTO .doit ldx &disp.doit stz &rest,x stz &rest+2,x MEND