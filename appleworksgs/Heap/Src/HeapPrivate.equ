;; HeapPrivate.equ;; Heap memory managment module equates;; Copyright © 1989 Claris Corporation;; 6/8/89 Kevin A. Watts;;--------------------------------------------------------------; Conditional assembly flags - now defined in makefile;ZeroInit		equ	1	; initialize handles to zero?;ErrorCheck	equ	2	; error checking code?;Verbose		equ	0	; verbose? (1=WordBox,2=AlertBox);VerboseErrors	equ	0	; alerts on normal errors?;Debug		equ	0	; debugging?;Profile		equ	0	; profiling?;Profile		equ	's'	; profiling?;Squeezing	equ	1	; SqueezeHeap?;GrowBlocks	equ	1	; grow blocks in place?;HeapIO		equ	3	; 1 = H_WriteHeap, 2 = H_ReadHeap;DriverSupport	equ	1	; Driver creation of zero page?;VariableDSegSize	equ	1	; Variable sized data segments?;VariableISegSize	equ	0	; Variable sized index segments?;UseLastResort	equ	0	; Use last resort allocation strategy?; DEBRK - debugging macro	MACRO	DEBRK  IF Debug THEN	brk  ENDIF	ENDM; DEBRK2 - debugging macro	MACRO	DEBRK2  IF Debug OR ErrorCheck THEN	brk  ENDIF	ENDM; DEBRK3 - debugging macro	MACRO	DEBRK3  IF VerboseErrors THEN;	brk  ENDIF	ENDM;--------------------------------------------------------------H_THIS_VERSION	equ	$71H_VERSION7	equ	$70H_ISEG_SIZE	equ	$1000	; 4K index segments (1K indices)H_DSEG_SIZE	equ	$4000	; 16K data segmentsH_MIN_COMPACT	equ	(H_DSEG_SIZE/8)	; free space required before compactH_MIN_SQUEEZE	equ	40	; segments must have this must free space				; to be a candidate for squeezing intoH_LARGE_BLOCK_SIZE	equ	$1000	; blocks ³ 4K will be allocated as handlesH_LARGE_BLOCK_FLAG	equ	$FF00H_LARGE_BLOCK_FLAG2	equ	$EE00H_FREE_INDEX_FLAG	equ	$A000H_BLOCK_OVERHEAD	equ	2	; size of overhead in each heap block; verify that certain variables are correct in relation to each other  IF (H_LARGE_BLOCK_FLAG ² H_LARGE_BLOCK_FLAG2) OR (H_LARGE_BLOCK_FLAG2 ² H_FREE_INDEX_FLAG) OR (H_FREE_INDEX_FLAG < $8000) THEN	AERROR	'Must have H_LARGE_BLOCK_FLAG > H_LARGE_BLOCK_FLAG2 > H_FREE_INDEX_FLAG ³ $8000'  ENDIF  IF (H_LARGE_BLOCK_FLAG MOD $100) ­ 0 THEN	AERROR	'H_LARGE_BLOCK_FLAG must have low byte = $00'  ENDIF  IF (H_LARGE_BLOCK_FLAG2 MOD $100) ­ 0 THEN	AERROR	'H_LARGE_BLOCK_FLAG2 must have low byte = $00'  ENDIF  IF (H_FREE_INDEX_FLAG MOD $1000) ­ 0 THEN	AERROR	'H_FREE_INDEX_FLAG must have low 3 nibbles = $000'  ENDIF	include	'Heap.equ'; -----------; H_HeaderRec equatesH_Header		equ	H_HeaderRec.HeaderH_Version		equ	H_HeaderRec.VersionH_HeaderPtr	equ	H_HeaderRec.HeaderPtrH_NumISegments	equ	H_HeaderRec.NumISegmentsH_NumDSegments	equ	H_HeaderRec.NumDSegmentsH_FreeIndex	equ	H_HeaderRec.FreeIndexH_EndIndex	equ	H_HeaderRec.EndIndexZHEADER_SHORT_SIZE	equ	H_HeaderRec.ZHEADER_SHORT_SIZEH_FreeListArray	equ	H_HeaderRec.FreeListArray	H_ISegHandleLo	equ	H_HeaderRec.ISegHandleLoH_ISegHandleHi	equ	H_HeaderRec.ISegHandleHiH_DSegHandleLo	equ	H_HeaderRec.DSegHandleLoH_DSegHandleHi	equ	H_HeaderRec.DSegHandleHiH_ISegPtrLo	equ	H_HeaderRec.ISegPtrLoH_ISegPtrHi	equ	H_HeaderRec.ISegPtrHiH_DSegPtrLo	equ	H_HeaderRec.DSegPtrLoH_DSegPtrHi	equ	H_HeaderRec.DSegPtrHiZHEADER_SIZE	equ	H_HeaderRec.ZHEADER_SIZEH_FreeLists	equ	H_HeaderRec.FreeListsHANDLE_ARRAY	equ	H_HeaderRec.HANDLE_ARRAY;------------H_SegmentRec	RECORD	0	; Structure of a heap data segmentSegFreeList	DS.W H_N_FREE_LISTS	; free list heads for each block sizeSegSize		DS.W 1	; segment sizeSegEnd		DS.W 1	; offset to never used portion of segmentSegFreeSpace	DS.W 1	; total free space in segmentSegNumBlocks	DS.W 1	; number of blocks in segmentDSEG_HDR_SIZE	equ	*SegData		equ	*	ENDR	; H_Segment ----------------------; N.B. there is code that assumes that H_SegFreeList = 0H_SegFreeList	equ	H_SegmentRec.SegFreeListH_SegSize		equ	H_SegmentRec.SegSizeH_SegEnd		equ	H_SegmentRec.SegEndH_SegFreeSpace	equ	H_SegmentRec.SegFreeSpaceH_SegNumBlocks	equ	H_SegmentRec.SegNumBlocksDSEG_HDR_SIZE	equ	H_SegmentRec.DSEG_HDR_SIZE; minimum allowable data segment sizeH_MIN_DSEG_SIZE	equ	H_LARGE_BLOCK_SIZE+DSEG_HDR_SIZE;------------H_BlockRec	RECORD	0	; Structure of a data blockBlockSize		DS.W 1	; block sizeData		equ	*	ENDR	; H_Block ----------------------H_BlockSize	equ	H_BlockRec.BlockSizeH_Data		equ	H_BlockRec.Data;------------; H_VariablesRec equates; 'Globals' - maintain value across heap callsH_ZPptr		equ	H_VariablesRec.H_ZPptrH_IsLocked	equ	H_VariablesRec.H_IsLockedH_MaxSegments	equ	H_VariablesRec.H_MaxSegmentsH_HeaderSize	equ	H_VariablesRec.H_HeaderSizeH_DSegHOffsetLo	equ	H_VariablesRec.H_DSegHOffsetLoH_DSegHOffsetHi	equ	H_VariablesRec.H_DSegHOffsetHiH_ISegPOffsetLo	equ	H_VariablesRec.H_ISegPOffsetLoH_ISegPOffsetHi	equ	H_VariablesRec.H_ISegPOffsetHiH_DSegPOffsetLo	equ	H_VariablesRec.H_DSegPOffsetLoH_DSegPOffsetHi	equ	H_VariablesRec.H_DSegPOffsetHi; 'Locals' - not assumed to maintain value across heap callsBlockSize		equ	H_VariablesRec.BlockSizeCopyHdr		equ	H_VariablesRec.CopyHdrDP		equ	H_VariablesRec.DPDataSize		equ	H_VariablesRec.DataSizeEndPtr		equ	H_VariablesRec.EndPtrErrorFlag		equ	H_VariablesRec.ErrorFlagFreeListOffset	equ	H_VariablesRec.FreeListOffsetHasMoved		equ	H_VariablesRec.HasMovedIndex		equ	H_VariablesRec.IndexISegPtr		equ	H_VariablesRec.ISegPtrSkipLastResort	equ	H_VariablesRec.SkipLastResortMaxFreeSeg	equ	H_VariablesRec.MaxFreeSegMaxFreeSpace	equ	H_VariablesRec.MaxFreeSpaceNewHeap		equ	H_VariablesRec.NewHeapOffset		equ	H_VariablesRec.OffsetOldIndex		equ	H_VariablesRec.OldIndexOldPtr		equ	H_VariablesRec.OldPtrOldSize		equ	H_VariablesRec.OldSizePtr		equ	H_VariablesRec.PtrSegHandle		equ	H_VariablesRec.SegHandleSegment		equ	H_VariablesRec.SegmentSegPtr		equ	H_VariablesRec.SegPtrSegSize		equ	H_VariablesRec.SegSize;------------  IF H_LARGE_BLOCK_SIZE > (H_DSEG_SIZE-DSEG_HDR_SIZE) THEN	AERROR	'Must have H_LARGE_BLOCK_SIZE ² (H_DSEG_SIZE-DSEG_HDR_SIZE)'  ENDIF;--------------------------------------------------------------; Driver routines and globals	IMPORT	D_ReadHandle	IMPORT	D_WriteHandle	IMPORT	D_ReadHandle2	IMPORT	D_WriteHandle2	IMPORT	D_NeedHand	IMPORT	D_NeedHandle	IMPORT	D_GrowHandle	IMPORT	D_GrowLHandle	;IMPORT	D_ZeroBlock	- done in Heap.equ for Driver:Init.aii	IMPORT	D_CheckPurge	IMPORT	D_AlertBox	IMPORT	D_WordBox	IMPORT	D_CloseWordBox	IMPORT	D_SystemHandle	IMPORT	D_TopModule